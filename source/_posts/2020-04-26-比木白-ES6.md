---
title: 比木白-ES6
date: 2020-04-26 11:04:47
tags: [ECMAScript 2015, ES6, javascript]
categories: ES6
comments: true
---

# ES6语法重点

在最近阅读了《深入理解ES6》这本书之后,发现ES6中有一些不为人所熟悉的部分却成为了提升开发效率的利器,所以将这些语法重点进行规整总结,分享输出给各位小伙伴.

## 块级作用域

### 临时死区

  ES6中的块级作用域为了防止变量提升,产生了临时死区的方案,也就是说如果你在let、const定义块级作用域变量之前,直接使用此名称的变量,临时死区里面的逻辑就会报错,在执行同步代码度过临时死区之前,使用任何名称的变量都会报错,直到执行过临时死区之后,才会解封.

  ```js
    "use strict"
    //这时候a变量不存在变量提升,会报语法错误
    console.log(a);
    let a = 'a,china,my hometown~';
    console.log(a);
    //这里打印: a,china,my hometown~
  ```

### for循环中的块级作用域

  ES6中for循环块级作用域中使用的let和const定义变量,和在普通的块级作用域中定义变量不同.for循环块级作用域中是循环的每一次都会声明赋值变量,不是对上次迭代变量的叠加或者累计,而是重新赋值声明,值等于上一次迭代变量加一.在for...in循环获取对象的属性集合项中,也是每一次迭代都会重新声明赋值属性.
  
  ```js
    let arr = [];
    for(let i = 0; i < 10; i++) {
        arr.push(()=>{
            console.log(i);
        });
    }
    arr.forEach((item) => {
        item();
    });
    //这里打印:
    //0
    //1
    //2
    //3
    //4
    //5
    //6
    //7
    //8
    //9
  ```

### 块级作用域最佳实践

  > ES6块级作用域最佳实践

  尽量在业务开发中,全部使用const定义数据,只有认识到此数据是要进行计算的,就使用let定义数据.
  
  > 原因

  大部分的数据是不可变的,只是作为查询或者展示,而可变的用于前端计算赋值的数据在实际应用场景当中很少很少.
  
## 字符串  
  
### 以码位而非字符来匹配字符

  在没有引入Unicode之前,正则表达式使用以一个16位编码也就是两个码位来匹配一个字符,那时候2^16次方个字符在计算机的字符世界中是够用的,但是在引入Unicode之后,2^16次方个字符在诺大的字符集当中非常吃不消,所以正则表达式新增了u描述符,以一个码位也就是32位编码来匹配一个Unicode字符.至此,所有Unicode字符被分为两类,基本平面(BMP)以及辅助平面,BMP是在2^16次方哥字符之内的,而其余超出的则是辅助平面范围
  
  ```js
    let str = '𠮷';
    console.log(str.length);                    //2,已超过BMP范围,转以辅助平面
    console.log(str.charAt(0));                 //无法识别的乱码,因为以BMP的方式去获取字符,超出范围获取到的只能是�
    console.log(str.charAt(1));                 //还是�
    console.log(str.charCodeAt(0));             //55362,不能获取到真实字符的码位,只能获取到码位的一半
    console.log(str.charCodeAt(1));             //57271,不能获取到真实字符的码位,只能获取到码位的一半
    console.log(String.fromCharCode(55362));    //�
    console.log(String.fromCharCode(57271));    //�
    console.log(str.codePointAt(0));            //134071,这才是非BMP的辅助平面的方式所匹配的32位码位的真实码位值
    console.log(str.codePointAt(1));            //57271,不能获取到真实字符的码位,只能获取到码位的一半
    console.log(String.fromCodePoint(134071));  //𠮷,直接使用非BMP的辅助平面的方式可以匹配到真实字符
  ```

### u描述符

  ```js
    let str = '𠮷',
        str_double = '𠮷𠮷';
    console.log(/\u{20bb7}/.test(str));         //因为\u{20bb7}超过了BMP16位编码的限制,所以是false
    console.log(/\u{20bb7}/u.test(str));        //使用u描述符来表述辅助平面的范围,所以是true
    console.log(/𠮷/.test(str));                //这里并没有转化成\u{20bb7}BMP16位编码,而是直接用字符去进行匹配,所以返回true
    console.log(/𠮷{2}/.test(str_double));      //这里使用了{2}表示将前面的字符乘以2,但这时候就会转化成\u{20bb7}BMP16位编码,超过了BMP16位编码的限制,所以是false
    console.log(/𠮷{2}/u.test(str_double));     //使用u描述符来表述辅助平面的范围,所以是true
  ```

  如果u描述符要兼容老版本浏览器,需要使用try {} catch(err) {},并且使用构造调用,这样是最安全的
  
  ```js
    try {
        let str = '𠮷',
            reg = new RegExp('\u{20bb7}', 'u');
        console.log(reg.test(str));
    } catch(err) {
    
    }
  ```

### 各种新增的处理字符串的方法

  > includes,字符串中是否含有某字符或者某字符串

  ```js
    let str = 'hello,world';
    console.log(str.includes('o'));             //表示此字符串中是否含有o字符,这里返回true
    console.log(str.includes('o', 7));          //表示此字符串中从下标为7位置开始直到字符串最后,是否含有o字符,这里返回true
    console.log(str.includes('o', 8));          //表示此字符串中从下标为8位置开始直到字符串最后,是否含有o字符,这里返回false
  ```

  > startsWith,字符串中是否以某字符或者某字符串开头

  ```js
    let str = 'hello,world';
    console.log(str.startsWith('hello'));       //表示此字符串中是否以hello字符串开头,这里返回true
    console.log(str.startsWith(',', 5));        //表示此字符串中从下标为5位置开始直到字符串最后是否以,字符开头,这里返回true
  ```

  > endsWith,字符串中是否以某字符或者某字符串结尾
  
  ```js
    let str = 'hello,world';
    console.log(str.endsWith('ld'));            //表示此字符串中是否以ld字符串结尾,这里返回true
    console.log(str.endsWith('o', 7));          //表示此字符串中从下标为7位置开始直到字符串开头是否以o字符结尾,这里返回false
    console.log(str.endsWith('o', 8));          //表示此字符串中从下标为8位置开始直到字符串开头是否以o字符结尾,这里返回true
    console.log(str.endsWith('o', 5));          //表示此字符串中从下标为5位置开始直到字符串开头是否以o字符结尾,这里返回true
  ```

  > repeat,将某字符或者字符串重复n次

  ```js
    let str = 'pet';
    console.log(str.repeat(2));                 //表示此字符串重复2次输出,这里返回petpet
    console.log(str.repeat(5));                 //表示此字符串重复5此输出,这里返回petpetpetpetpet
  ```

### y描述符,粘滞描述符

  y粘滞描述符,是区别于g全局描述符,与正则表达式匹配的lastIndex有直接关系,其匹配必须从字符串的开头0下标开始,如果匹配,则从匹配结束的位置开始,再开始匹配,如果再次匹配不到,则回到字符串的开头0下标开始,多次匹配的规则在字符串中必须是连续的.
  
  ```js
    let str = 'hello.hello.hello.hello.hello.',
        reg_y = /hello./y,
        reg_g = /hello./g;
    console.log(reg_g.exec(str));               //这时全局描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_y.exec(str));               //这时粘滞描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_g.lastIndex);               //带有全局描述符正则表达式的lastIndex为6
    console.log(reg_y.lastIndex);               //带有粘滞描述符正则表达式的lastIndex为6
    //这时候设置带有全局和粘滞描述符的正则表达式的lastIndex为1
    reg_g.lastIndex = 1;
    reg_y.lastIndex = 1;
    //再去匹配整个字符串
    console.log(reg_g.exec(str));               //这时全局描述符匹配到["hello.", index: 6, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_y.exec(str));               //这时粘滞描述符匹配到的值为null
    //可以看出y粘滞描述符与正则表达式匹配的lastIndex有直接关系,且必须是从lastIndex位置为起点字符串的开头开始能匹配到,才会有匹配值,否则为null,lastIndex会回到源字符串的头部也就是下标为0处,为下次匹配做准备.
  ```

  ```js
    let str = 'hello.hello.hello.hello.hello.',
        reg_ny = /hello/y,
        reg_y = /hello./y,
        reg_g = /hello./g;
    console.log(reg_g.exec(str));               //这时全局描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_y.exec(str));               //这时粘滞描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_ny.exec(str));              //这时粘滞描述符匹配到["hello", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_g.lastIndex);               //带有全局描述符正则表达式的lastIndex为6
    console.log(reg_y.lastIndex);               //带有粘滞描述符正则表达式的lastIndex为6
    console.log(reg_ny.lastIndex);              //带有粘滞描述符正则表达式的lastIndex为5
    //再去匹配整个字符串
    console.log(reg_g.exec(str));               //这时全局描述符匹配到["hello.", index: 6, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_y.exec(str));               //这时粘滞描述符匹配到["hello.", index: 6, input: "hello.hello.hello.hello.hello.", groups: undefined]
    console.log(reg_ny.exec(str));              //这时粘滞描述符匹配到的值为null
    
    //可以看出y粘滞描述符多次匹配的规则在字符串中必须是连续的,且必须是从lastIndex位置为起点字符串的开头开始能匹配到,才会有匹配值,否则为null,lastIndex会回到源字符串的头部也就是下标为0处,为下次匹配做准备.
  ```

  如果y粘滞描述符要兼容老版本浏览器,需要使用try {} catch(err) {},并且使用构造调用,这样是最安全的
    
  ```js
    try {
        let str = 'hello.hello.hello.hello.hello.',
            reg = new RegExp('hello.', 'y');
        console.log(reg.test(str));
    } catch(err) {
  
    }
  ```

### source、flags与sticky

  source用于获取正则表达式的除了描述符以外的内容,flags则用于获取正则表达式的描述符,而sticky则是用于获取此正则表达式是否存在y粘滞描述符
  
  ```js
    let reg_g = /hello./g,
        reg_y = /hello./y,
        reg_yi = /hello./yi;
    console.log(reg_g.source, reg_g.flags, reg_g.sticky);       //这里打印: hello. g false 
    console.log(reg_y.source, reg_y.flags, reg_y.sticky);       //这里打印: hello. y true
    console.log(reg_yi.source, reg_yi.flags, reg_yi.sticky);    //这里打印: hello. yi true
  ```

  顺便说一下在没有flags来获取正则表达式的描述符时,一般会是这么去封装一个获取正则表达式描述符的方法
  
  ```js
    function flags(reg) {
        let _reg = String(reg),
            flagsPosition = _reg.lastIndexOf('/');
        return flagsPosition !== -1 ? _reg.slice(flagsPosition + 1) : '';
    }
    console.log(flags(/hello./yi));                            //在这里打印: yi
  ```

### 模板标签

  模板标签处理模板字符串的数据参数顺序以及源字符串的操作很便利,你只要写一个函数,并直接放在模板字符串前方,这样就可以直接模板字符串进行处理了,函数的第一个参数是一个数组,表示的是所有除了引入变量以外的字符片段的集合,而后面的参数则是按照引入变量的顺序从左至右的排开,你可以使用不定参数将其转化为数组,不论你怎么引入变量,字符片段的集合数组总是比不定参数转化的数组的长度多一,所以我们可以自己去写一个模板标签,用交织的形式去组合字符串的原顺序或是自定义顺序.
  
  ```js
    let name = 'Gary',
        age = 27,
        hobby = 'basketball';
    function tags(iterators, ...params) {
        let tags_str = '',
            iterators_length = iterators.length;
        for(let [key, value] of params.entries()) {
            tags_str += iterators[key];
            tags_str += value;
        }
        tags_str += iterators[iterators_length - 1];
        return tags_str;
    }
    console.log(tags`我是${name}, 我今年${age}岁了, 我的爱好是${hobby}`);   
    //在这里打印: 我是Gary, 我今年27岁了, 我的爱好是basketball
  ```

  还有一种处理源字符串操作的模板标签,可以使源字符串不做转义.那就是String.raw
  
  ```js
    let name = 'Gary';
    console.log(`啊哈,\n${name},原来是你`);
    console.log(String.raw`啊哈,\n${name},原来是你`);
    //在这里打印: 啊哈,
    //Gary,原来是你
    //在这里打印: 啊哈,\nGary,原来是你
  ```

  它可以使换行、制表这些转义符不做转义,我们可以自己写一个和它一致的模板标签,每一个源字符片段都有一个raw的特有属性,其可以将其本身变为不可转义.
  
  ```js
    let name = 'Gary';
    function raw(iterators, ...params) {
        let raw_str = '',
            iterators_length = iterators.length;
        for(let [key, value] of params.entries()) {
            raw_str += iterators.raw[key];
            raw_str += value;
        }
        raw_str += iterators.raw[iterators_length - 1];
        return raw_str;
    }
    console.log(`啊哈,\n${name},原来是你`);
    console.log(raw`啊哈,\n${name},原来是你`);
    //在这里打印: 啊哈,
    //Gary,原来是你
    //在这里打印: 啊哈,\nGary,原来是你
  ```

## 函数

### 默认参数
  
  默认参数使得传参更加简化、方便,只有传递的参数为undefined,就给予默认值,如果不为undefined,则进行赋值,类似于for循环let、const每次创建一个声明一样,默认参数也会在函数词法作用域的顶部使用let、const创建一个声明.
  
  ```js
    function getPerson(name, age = 25, hobby = 'basketball') {
        console.log(`I'm ${name}, ${age} year's old, I love ${hobby}`);
    }
    getPerson('Gary');
    //在这里打印: I'm Gary, 25 year's old, I love basketball
    //类似于
    //function getPerson(name, _age, _hobby) {
    //    let age = typeof _age === 'undefined' ? _age : 25;
    //    let hobby = typeof _hobby === 'undefined' ? _hobby : 'basketball';
    //    console.log(`I'm ${name}, ${age} year's old, I love ${hobby}`);
    //}
  ```
  
  甚至可以在非第一个默认参数上面去承接之前定义好的传参或者默认参数.
  
  ```js
    function getNumber(first = 1, second = first) {
        console.log(`first: ${first}, second: ${second}`);
    }
    getNumber();
    //在这里打印： first: 1, second: 1
    getNumber(10, 2);
    //在这里打印: first: 10, second: 2
    getNumber(100);
    //在这里打印: first: 100, second: 100
    //类似于
    //function getNumber(_first, _second) {
    //  let first = _first || 1;
    //  let second = _second || first;
    //  console.log(`first: ${first}, second: ${second}`);
    //}
  ```

  但是默认参数也存在临时死区的,在没有把临时死区当中的变量释放出来之前,直接使用,会引起语法错误.
  
  ```js
      function getNumber(first = second, second = 1) {
          console.log(`first: ${first}, second: ${second}`);
      }
      getNumber();
      //在这里会报语法错误,因为在first不传参赋值的情况下,second变量还处于临时死区当中,并未释放,不可以赋值给first
      getNumber(10, 2);
      //在这里打印: first: 10, second: 2
      getNumber(100);
      //在这里打印: first: 100, second: 1
      //类似于
      //function getNumber(_first, _second) {
      //  let first = _first || _second;
      //  let second = _second || 1;
      //  console.log(`first: ${first}, second: ${second}`);
      //}
   ```

  也可使用函数返回值的形式作为默认参数.
  
  ```js
      function getNumberOne() {
        return 1;
      }
      function getNumber(first = getNumberOne(), second = first) {
            console.log(`first: ${first}, second: ${second}`);
      }
      getNumber();
      //在这里打印: first: 1, second: 1
      getNumber(10, 2);
      //在这里打印: first: 10, second: 2
      getNumber(100);
      //在这里打印: first: 100, second: 100
      //类似于
      //function getNumber(_first, _second) {
      //  let first = _first || getNumberOne();
      //  let second = _second || first;
      //  console.log(`first: ${first}, second: ${second}`);
      //}
  ```

### 不定参数