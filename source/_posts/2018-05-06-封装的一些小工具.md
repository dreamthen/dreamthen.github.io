---
title: 2018-05-06 封装的一些小工具
date: 2018-05-06 17:01:43
tags: [封装, 小工具]
categories: 封装的一些小工具
---
# debounce函数节流

> 函数节流通常被用于输入下拉框、滚动懒加载等场景,目的只有一个,在短时间内,限制多次调用后台接口,浪费大量资源,防止接口响应数据时间上的误差造成的页面显示数据的错误。
    
    //设置一个timer变量,用来承接setTimeout返回的延时对象
    const timer = null;
    //函数节流方法
    function debounce(fuc, delay) {
        //每一次进行输入或者拉动滚动条的时候,都会对延时对象进行判断,假如存在延时对象,就停止延时对象,并把延时对象置为空,释放内存,使得垃圾回收机制能更快的对延时对象进行回收
        if(timer) {
            clearTimeout(timer);
            timer = null;
        }
        //给延时对象赋予一个延时方法,fuc就是请求后台接口的函数,delay就是延时时间
        timer = setTimeout(fuc, delay);
    }
    //函数节流方法,只要在delay时间内,再次触发此方法,延时对象就会被停止且置空,后台的接口函数就不会被调用。
    //做到了在短时间内输入或者滚动限制了多次调用后台接口,防止了接口响应数据时间上的误差造成页面数据显示的错误。
    
# getElementsByClassName封装

> getElementsByClassName是HTML5 DOM引入的一个获取class样式节点的方法,有一些不支持HTML5 DOM的浏览器可能不存在这个方法,所以需要对这个方法进行封装

    //html code
    <!Doctype html>
    <html lang="zh-cn">
        <head>
            <meta charset="utf-8">
            <title>getElemetnsByClassName封装</title>
        </head>
        <body>
            <div id="home">
                <p class="number">first</p>
                <p class="number second">second</p>
                <p class="number">third</p>
            </div>
        </body>
        <script type="text/javascript" src="boxesByClassName.js"></script>
    </html>
    
    //boxesByClassName.js
    function getElementsByClassName(node, className) {
        //判断DOM是否有getElementsByClassName方法,假如有,就返回node节点下的所有className子节点
        if(node.getElementsByClassName) {
            return node.getElementsByClassName(className);
        } else {
        //假如没有,就先去获取node节点下的所有子节点元素,然后根据子节点元素的className属性进行匹配外部传入的className,假如包含此className,就传入返回的数组中,最后返回数组
            let _get_className_arr = [],
                _tag_arr = node.getElementsByTagName("*"),
                _tag_arr_length = _tag_arr.length;
            for(let i = 0; i < _tag_arr_length; i++) {
                if(_tag_arr[i].className.includes(className)){
                    _get_className_arr[_get_className_arr.length] = _tag_arr[i];
                }
            }
            return _get_className_arr;
        }
    }
    
# addEvent加载完成事件封装

> 对于window.onload事件,再熟悉不过了,用于在页面DOM全部加载完毕之后执行Javascript,防止在页面DOM渲染过程中对DOM进行操作,使得页面卡顿,降低用户体验。window.onload的挂载一个或者多个的方式于实际情况而定,所以需要对window.onlaod加载完成事件进行封装

    function addEvent(eventLoad) {
        //将window.onload事件函数赋值给一个变量
        let load = window.onload;
        //判断window.onload加载完成事件上面,是否挂载了事件函数
        //假如挂载了事件函数,就将新的事件函数添加到window.onload加载完成事件队列中
        //假如没有挂载事件函数,就直接将新的事件函数挂载上去
        if (typeof load !== "function") {
            window.onload = eventLoad;
        } else {
            window.onload = function() {
                load();
                eventLoad();           
            }
        }
    }
    
# insertAfter插入到某个元素节点之后封装

> parentNode.insertBefore(newElement, targetElement),insertBefore方法是在某一个元素节点之前插入新的元素节点,而DOM-Core并没有提供insertAfter方法,旨在在某一个元素节点之后插入新的元素节点,于是进行insertAfter封装

    function insertAfter(newElement, targetElement) {
        //获取目标节点的父节点
        let parent = targetElement.parentNode;
        //判断父节点的最后一个子节点是否是目标节点,假如是,就直接将新的元素节点,添加到父节点下
        //假如不是,就将新的元素节点插入到目标节点兄弟节点之前
        if(parent.lastChild == targetElement) {
            parent.appendChild(newElement);
        } else {
            parent.insertBefore(newElement, targetElement.nextSibling);
        }
    }
    
# isEmpty判断对象是否为空的封装

> Javascript的对象判断是否为空,并没有原生的方法,所以需要封装一下,成为自己的库

    function isEmpty(obj) {
        //判断对象是否为空的标识符,默认为true,判断对象为空
        let flag = true;
        //使用ES6遍历对象,假如对象中有遍历的对象属性,就说明对象不为空,设置flag为false,判断对象不为空
        for(let [key, value] of Object.entries(obj)) {
            if(obj.hasOwnProperty(key)) {
                flag = false;
                break;
            }
        }
        return flag;
    }
    
# getNextElementSibling获取元素节点的下一个兄弟元素节点

> node.nextSibling是获取某一个元素节点的下一个兄弟节点,但是节点类型可能是元素、属性以及文本,是不确定的,而通常,我们希望获取下一个兄弟节点的时候为元素节点,所以需要对获取元素节点的下一个兄弟元素节点进行封装

    function getNextElementSibling(node) {
        //判断元素节点是否有下一个兄弟节点,如果没有返回false
        if(!node.nextSibling) return false;
        //获取元素节点的下一个兄弟节点
        let nextSibling = node.nextSibling;
        //假如元素节点的下一个兄弟节点的节点类型为1,也就是元素节点,就返回元素节点的下一个兄弟节点
        if(nextSibling.nodeType === 1) {
            return nextSibling;
        }
        //假如元素节点的下一个兄弟节点的节点类型为除了1以外的其他数字,就再次递归元素节点的下一个兄弟节点,直到找到下一个兄弟元素节点位置
        return getNextElementSibling(nextSibling);   
    }
    
# moveElement动态的元素节点

> 通过原生的Javascript来生成动画,是解决CSS3不兼容低版本浏览器的最好的平稳退化方案,利用setTimeout生成的通用动画效果的函数方法在此
    
    //设置一个承接时间对象的变量
    let timer = null;
    //函数传递四个参数,要产生移动的元素节点,将要移动到的x轴位置,将要移动到的y轴位置,以及移动元素节点的时间(单位: 毫秒)
    function moveElement(node, x, y, speed) {
        //首先校验是否存在移动元素的节点,假如不存在,直接返回false,退出函数
        if(!document.getElementById(node)) return false;
        let elem = document.getElementById(node);
        //然后判断是否有时间对象,假如有的话,直接清理掉,并把时间对象置为空,以便浏览器垃圾回收机制更快的回收内存中的不需要的数据
        if(timer) {
            clearTimeout(timer);
            timer = null;
        }
        //判断移动元素节点样式的top和left属性是否存在,如果不存在,初始化top和left的属性为0px
        if(!elem.style.top) {
            elem.style.top = "0px";
        }
        if(!elem.style.left) {
            elem.style.left = "0px";
        }
        //获取移动元素节点样式的top和left属性值,并转化为绝对值的数值类型
        let xpo = Math.abs(parseInt(elem.style.left)),
            ypo = Math.abs(parseInt(elem.style.top));
        //假如移动元素节点样式的left的绝对值与要移动到的x轴位置相等,且移动元素节点样式的top的绝对值与要移动到的y轴位置相等,则返回true,退出递归函数
        if(xpo === x && ypo === y) {
            return true
        }
        let dist;
        //假如移动元素节点样式的left的绝对值小于要移动到的x轴位置,就将移动元素节点样式的left的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果
        if(xpo < x) {
            dist = Math.ceil((x - xpo) / 10);
            xpo += dist;
        }
        //假如移动元素节点样式的left的绝对值大于要移动到的x轴位置...
        if(xpo > x) {
            dist = Math.ceil((xpo - x) / 10);
            xpo -= dist;
        }
        //假如移动元素节点样式的top的绝对值小于要移动到的y轴位置,就将移动元素节点样式的top的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果
        if(ypo < y) {
            dist = Math.ceil((y - ypo) / 10);
            ypo += dist;
        }
        //假如移动元素节点样式的top的绝对值大于要移动到的y轴位置...
        if(ypo > y) {
            dist = Math.ceil((ypo - y) / 10);
            ypo -= dist;
        }
        //将移动元素节点样式的top和left的绝对值取反,赋值重新赋值给移动元素节点样式
        elem.style.left = `${-xpo}px`;
        elem.style.top = `${-ypo}px`;
        //未到目标位置,设置时间处理函数继续递归动态的元素节点函数,并把时间对象赋值给timer变量
        timer = setTimeout(function timer() {
            moveElement(node, x, y, speed);
        }, speed);
    }

        
    

    
        
    