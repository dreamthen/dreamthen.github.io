---
title: 日常开发难点
date: 2022-06-12 02:55:11
tags: [难点,日常开发]
categories: 难点
---

# 列表项上下键选中使用 scrollIntoView behavior: 'smooth' 抖动问题

> 思路

  放弃计算DOM getBoundingClientRect的方式，采用底层 API <a href='https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API'>Intersection Observer API</a> 来计算列表项(list-item)是否存在于可视的列表范围(list-container)之内，底层 API 性能、效率都比通过自己的方式高的多。

  Intersection Observer 从用法上还是蛮简单的，那理解上来说呢，简单来讲：是一个观察者模式，目标元素与视口会产生一个是否可见交叉区，通过观察视口与目标元素的交叉关系，可以在 callback 回调中获取目标元素与视口的交叉关系信息，产生"交叉观察器"的效果。
  
  特性: callback 一般只会触发两次，一次是目标元素开始可见，另一次是开始不可见。

  那在个人的项目例子中呢，所有的 list-item 都是目标元素，通过捕获完全超出视口范围的第一个 list-item 开始可见的时间点来引起 scrollIntoView 平滑动画过渡的 'smooth' 滚动，在滚动之后在视口有新的一批 list-item 的情况下，重建 IntersectionObserver，重置 IntersectionObserve 实例，以此来循环。可以这么想，"交叉观察器"观察的永远是视口内新的一批 list-item 与视口的交叉关系，而老一批 list-item 在 scrollIntoView 滚动之后，因"交叉观察器"特性也应当重建"交叉观察器"重新观察。

  在这时候可能想问，有没有可能存在一种情况，引起 scrollIntoView 平滑动画过渡的 'smooth' 滚动的时间会慢于按键的速度，导致完全超出视口范围的第二个、第三个 list-item 开始可见的时间点再次引起滚动，从而再次产生抖动的问题呢？答案是理论上存在这种可能性，而在实际操作上，按键按住不发的情况下存在，而在比较快按键的节奏下，是不存在这种可能性的。

  * 首先，在第一次捕获完全超出视口范围的第一个 list-item 开始可见的时间点来引起 scrollIntoView 平滑动画过渡的 'smooth' 滚动之后，第一时间就对 IntersectionObserver 实行重建，将源实例置为null并停止观察其所有目标元素的可见性变化，防止这时候是不会存在的。
  * 其次，即使按键按住不放极速实行选中，也可以通过节流来解决，因为按键按住不放这种操作，本身就是一种非常规且触及极端边界的操作，不必实时且完全满足这种极端操作。

  PS: 这种重建 IntersectionObserver，重置 IntersectionObserve 实例的方式是有一些不是很优雅，但官方并没有提供动态修改的方法，不可能把希望寄托在官方修改api上，了解ECMA的提案流程的同学肯定知道，那将是个十分漫长的过程，所以眼下就只能找到这种比较切实的办法来解决这个问题。

> 示例

  ```tsx
    import {StrictMode, useState, useEffect, useCallback, useRef} from 'react';
    import * as ReactDOM from 'react-dom/client';
    import cns from 'classnames';
    import throttle from 'lodash.throttle';
    
    import './index.less';
    
    
    interface SelectedOprProps {
        id?: string;
        idx?: number;
    }
    
    enum SELECT_MODE {
        SHORTCUT = 'SHORTCUT',
        MOUSE = 'MOUSE',
    }
    
    enum KeyCode {
        Tab = 9,
        Enter = 13,
        Escape = 27,
        Left = 37,
        Up = 38,
        Right = 39,
        Down = 40,
        R = 82,
        O = 79,
        W = 87,
        F = 70,
        Plus = 187,
        Minus = 189,
    }
    
    const list = Array.from(Array.apply(null, {length: 100}), (item, index) => {
        return {
            id: `item${index}`,
            idx: index,
            value: `item${index}`
        }
    });
    
    const ListItem = ({config, selectedOprId, setSelected, selectMode, canMouseEnter, setCanMouseEnter, observer}) => {
        const oprRef = useRef<HTMLDivElement>(null);
    
        /**
         * 鼠标移入
         */
        const mouseEnter = throttle(() => {
            if (canMouseEnter) {
                setSelected({...config});
            }
        }, 900);
    
        /**
         * 鼠标移出
         */
        const mouseLeave = throttle(() => {
            if (canMouseEnter) {
                setSelected({});
            }
        }, 900);
    
        /**
         * 鼠标滑动
         */
        const mouseMove = throttle(() => {
            if (!canMouseEnter) {
                setCanMouseEnter(true);
                setSelected({...config});
            }
        }, 900);
    
        useEffect(() => {
            if (!selectedOprId || selectMode === SELECT_MODE.MOUSE) return;
            if (config?.id === selectedOprId) {
                observer.observe(oprRef.current);
            }
        }, [selectedOprId, config?.id, selectMode]);
    
        return <div
            ref={oprRef}
            key={config.id}
            data-selected={selectedOprId === config?.id}
            className={cns(
                `list-item-${config?.idx}`,
                {
                    'list-item-selected': selectedOprId === config?.id
                }
            )}
            onMouseEnter={mouseEnter}
            onMouseLeave={mouseLeave}
            onMouseMove={mouseMove}
        >{config.value}</div>;
    };

    // use hooks~
    const App = (props) => {
        //设置选中的list列表项
        const [selectedOpr, setSelectedOpr] = useState<{ [propsName: string]: any }>({});
        //选中list列表项时的触发类型
        const [selectMode, setSelectMode] = useState<any>();
        //是否可以移入移出
        const [canMouseEnter, setCanMouseEnter] = useState(true);
        //选中的列表项
        const selectedOprIdx = useRef<SelectedOprProps>({});
        //observer观察实例
        const observer = useRef<IntersectionObserver>(null);
    
        let options = {
            root: document.querySelector('.container'),
            rootMargin: '0px',
            threshold: 1.0
        }
    
        /**
         * 选中选项
         */
        const setSelected = useCallback((config) => {
            selectedOprIdx.current = {
                id: config.id,
                idx: config.idx
            };
            setSelectMode(SELECT_MODE.MOUSE);
            setSelectedOpr(config);
        }, []);
    
        /** 向下选择 */
        const selectOprDownDir = useCallback(() => {
            let newIdx = (selectedOprIdx.current?.idx ?? -1) + 1;
            if (newIdx > list.length - 1) {
                newIdx = 0;
            }
            const selected = list[newIdx];
            selectedOprIdx.current = {
                id: selected.id,
                idx: newIdx
            };
            setSelectedOpr(selected);
            setCanMouseEnter(false);
        }, []);
    
        /** 向上选择 */
        const selectOprUpDir = useCallback(() => {
            let newIdx = (selectedOprIdx.current?.idx ?? 0) - 1;
    
            if (newIdx < 0) {
                newIdx = list.length - 1;
            }
            const selected = list[newIdx];
            selectedOprIdx.current = {
                id: selected.id,
                idx: newIdx
            };
            setSelectedOpr(selected);
            setCanMouseEnter(false);
        }, []);
    
        //监听上下按键
        useEffect(() => {
            const keydownHandler = (e: KeyboardEvent) => {
                setSelectMode(SELECT_MODE.SHORTCUT);
                if (e.keyCode === KeyCode.Down) {
                    selectOprDownDir();
                    e.preventDefault();
                } else if (e.keyCode === KeyCode.Up) {
                    selectOprUpDir();
                    e.preventDefault();
                }
    
                if ((e.keyCode === KeyCode.Down || e.keyCode === KeyCode.Up) && (observer.current === null)) {
                    observer.current = new IntersectionObserver((changes) => {
                        if (changes.length > 0) {
                            if (changes[0]?.intersectionRatio <= 0) {
                                const target = changes[0]?.target as HTMLElement,
                                    selected = JSON.parse(target?.dataset?.selected);
                                if (selected) {
                                    changes[0]?.target.scrollIntoView({block: 'center', behavior: 'smooth'});
                                    observer.current.disconnect();
                                    observer.current = null;
                                }
                            }
                        }
                    }, options);
                }
            };
    
            window.addEventListener('keydown', keydownHandler);
    
            return () => {
                window.removeEventListener('keydown', keydownHandler);
                observer.current.disconnect();
                observer.current = null;
            };
        }, [selectOprDownDir, selectOprUpDir,]);
    
        return <div className='container'>
            {
                list && list.length > 0 && list.map(item => {
                    return <ListItem
                        key={item.id}
                        observer={observer.current}
                        config={item}
                        selectedOprId={selectedOpr?.id}
                        setSelected={setSelected}
                        selectMode={selectMode}
                        canMouseEnter={canMouseEnter}
                        setCanMouseEnter={setCanMouseEnter}
                    />
                })
            }
        </div>
    };
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    
    root.render(<StrictMode>
        <App/>
    </StrictMode>);
  ```
