<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018-04-24 react原理</title>
    <url>/2018/04/24/react%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="React原理"><a href="#React原理" class="headerlink" title="React原理"></a>React原理</h1><blockquote>
<p>React的主体思想:数据驱动。React根据数据的变化,使得View视图rerender,也就是重新渲染。React使用的是jsx(js + xml)语法和虚拟DOM,React引入虚拟DOM,是一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,使得View进行渲染,当虚拟DOM节点发生修改时,React使用diff算法进行比对,一旦发现不同,React虚拟DOM就会从根节点进行rerender,而浏览器实际的DOM操作仅仅是diff部分,尽管每次的虚拟DOM都是从根节点进行刷新,但由于是内存数据,性能很高,而浏览器实际的DOM操作仅仅是diff部分,从而很大程度上提高了web网站的性能。</p>
</blockquote>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-26 Javascript 0.1 + 0.2 !== 0.3</title>
    <url>/2018/04/26/javascript-0-1-0-2-0-3/</url>
    <content><![CDATA[<h1 id="为什么0-1-0-2-0-3"><a href="#为什么0-1-0-2-0-3" class="headerlink" title="为什么0.1 + 0.2 !== 0.3"></a>为什么0.1 + 0.2 !== 0.3</h1><blockquote>
<p>Javascript的浮点数类型不够精确,双精度浮点数类型的二进制位数加上符号位为53位,也就是说0.1的二进制树加上0.2的二进制数,转化为十进制数为0.30000000000000004,所以0.1 + 0.2 !== 0.3</p>
</blockquote>
<h1 id="怎么解决0-1-0-2-0-3的问题"><a href="#怎么解决0-1-0-2-0-3的问题" class="headerlink" title="怎么解决0.1 + 0.2 !== 0.3的问题"></a>怎么解决0.1 + 0.2 !== 0.3的问题</h1><blockquote>
<p>最好的方法是设置一个误差”机器精度”的范围值,与0.1 + 0.2 - 0.3的值进行比较,假如不超过这个范围就返回true,如果超过这个范围就返回false,可以利用ES6给开发者提供的一个新属性EPSILON,这个属性正好等于2^-52,无限接近于0,但不等于0</p>
</blockquote>
<pre><code>0.1 + 0.2 - 0.3 &lt; Number.EPSILON
</code></pre><blockquote>
<p>也可以利用保留小数的方式进行解决,比如toFixed和toPrecision</p>
</blockquote>
<pre><code>parseFloat((0.1 + 0.2).toFixed(1)) === 0.3
</code></pre>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-24 hexo搭建自己的博客</title>
    <url>/2018/04/24/hexo%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="git建库"><a href="#git建库" class="headerlink" title="git建库"></a>git建库</h1><blockquote>
<p>首先要先建立一个以dreamthen(我的用户名).github.io结尾的repository,作为hexo托管代码的库,github默认.github.io结尾作为用户的网站二级域名。所以github用户搭建自己的个人网站很容易。</p>
</blockquote>
<h1 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h1><blockquote>
<p>首先要用npm外部依赖包管理工具安装全局命令hexo-cli</p>
</blockquote>
<pre><code>npm install hexo-cli -g
</code></pre><blockquote>
<p>然后使用hexo初始化博客文件夹,比如blog文件夹</p>
</blockquote>
<pre><code>hexo init blog
</code></pre><blockquote>
<p>之后,进入生成的blog文件夹,下载外部依赖包</p>
</blockquote>
<pre><code>npm i/npm install
</code></pre><blockquote>
<p>最后启动hexo自身搭建的服务,生成本地的博客网站,默认端口在本地ip地址下的4000端口,假如你不想启动在4000端口,也可使用-p 其他端口号进行配置,比如-p 9977   </p>
</blockquote>
<pre><code>hexo server
hexo server -p 9977
</code></pre><blockquote>
<p>默认的主题风格theme是landscape,假如你想更换,可以通过<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a>进行筛选,筛选之后进行配置,主题配置见下文</p>
</blockquote>
<h1 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h1><ul>
<li><h4 id="hexo-git配置"><a href="#hexo-git配置" class="headerlink" title="hexo git配置"></a>hexo git配置</h4></li>
</ul>
<blockquote>
<p>要想部署到自己搭建的个人网站github库里面,首先要下载hexo-git插件</p>
</blockquote>
<pre><code>npm install hexo-deployer-git --save
</code></pre><blockquote>
<p>然后就要在你自己的本地hexo博客的项目里面,更改根目录底下的_config.yml文件,全局搜索git,更改deploy配置</p>
</blockquote>
<pre><code>deploy:
    type: git
    repo: git@github.com:dreamthen/dreamthen.github.io.git(你的个人网站github库的链接地址,最好使用git:开头的,https:开头的会报错)
    branch: master(分支名)
</code></pre><ul>
<li><h4 id="hexo-theme主题配置"><a href="#hexo-theme主题配置" class="headerlink" title="hexo theme主题配置"></a>hexo theme主题配置</h4></li>
</ul>
<blockquote>
<p>筛选好自己选中的主题之后,就需要在项目里面进行配置更换。首先需要下载远程github库里面的主题项目到项目根目录里面的themes文件夹底下,比如本人用的是next主题的hexo</p>
</blockquote>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next
</code></pre><blockquote>
<p>随后更改根目录里面的_config.yml文件,全局搜索theme,更改theme配置</p>
</blockquote>
<pre><code>theme: next
</code></pre><blockquote>
<p>接着选择主题展示的方式,需要在主题的项目目录下,更改_config.yml文件,全局搜索Scheme,更改Scheme配置,比如next主题底下的Scheme配置</p>
</blockquote>
<pre><code>scheme:
    #scheme: Muse
    scheme: Mist
    #scheme: Pisces
    #scheme: Gemini
</code></pre><ul>
<li><h4 id="hexo-language语言配置"><a href="#hexo-language语言配置" class="headerlink" title="hexo language语言配置"></a>hexo language语言配置</h4></li>
</ul>
<blockquote>
<p>每个主题的语言都是根据作者的母语来配置的,要想配置开发者自己国家的语言,还是更改项目根目录底下的_config.yml文件,全局搜索language,更改language配置</p>
</blockquote>
<pre><code>language: zh-CN
</code></pre><blockquote>
<p>再更改主题项目目录底下的language文件夹底下的zh-Hans.yml文件,将其重命名为zh-CN.yml,再更改其目录底下的_config.yml文件,全局搜索language,更改language配置</p>
</blockquote>
<pre><code>language: zh-CN    
</code></pre><ul>
<li><h4 id="hexo-page-页面配置"><a href="#hexo-page-页面配置" class="headerlink" title="hexo page 页面配置"></a>hexo page 页面配置</h4></li>
</ul>
<blockquote>
<p>hexo提供了几个可供筛选的页面,常用的有这么几个：home(首页)、tags(标签)、about(关于我)、archives(档案)和categories(分类),首先要创建页面</p>
</blockquote>
<pre><code>hexo new page tags
hexo new page about
hexo new page archives
hexo new page categories
</code></pre><blockquote>
<p>接着在主题项目目录下,更改_config.yml文件,全局搜索menu,更改menu配置,当然每个主题的配置不尽相同</p>
</blockquote>
<pre><code>menu:
    home: / || home
    about: /about/ || user
    tags: /tags/ || tags
    categories: /categories/ || th
    archives: /archives/ || archive
</code></pre><blockquote>
<p>随后更改source目录底下创建的页面,以tags为例</p>
</blockquote>
<pre><code>----------------------------
    title: about
    date: 2018-04-24 17:57:26
    type: &quot;tags&quot;
    comments: false
----------------------------
</code></pre><ul>
<li><h4 id="hexo-avatar-头像配置"><a href="#hexo-avatar-头像配置" class="headerlink" title="hexo avatar 头像配置"></a>hexo avatar 头像配置</h4></li>
</ul>
<blockquote>
<p>配置自己个人博客网站的头像,需要更改hexo博客项目底下的_config.yml文件,添加avatar配置</p>
</blockquote>
<pre><code>avatar: https://avatars1.githubusercontent.com/u/13704681?s=400&amp;u=bfc4636397a7c4384f63d4836a33d1797cd2c660&amp;v=4(头像url链接)
</code></pre><ul>
<li><h4 id="hexo-search-全站搜索配置"><a href="#hexo-search-全站搜索配置" class="headerlink" title="hexo search 全站搜索配置"></a>hexo search 全站搜索配置</h4></li>
</ul>
<blockquote>
<p>假如想要配置自己hexo个人博客网站的全站搜索配置,首先要下载hexo search外部依赖包</p>
</blockquote>
<pre><code>npm install hexo-generator-search --save
npm install hexo-generator-searchdb --save
</code></pre><blockquote>
<p>更改hexo博客项目根目录底下的_config.yml文件,添加search配置</p>
</blockquote>
<pre><code>search:
    path: search.xml
    field: post
    format: html
    limit: 10000
</code></pre><blockquote>
<p>开启主题项目目录底下的_config.yml文件中的local_search配置</p>
</blockquote>
<pre><code>local_search:
    enable: true        
</code></pre><ul>
<li><h4 id="hexo-new-post-name配置"><a href="#hexo-new-post-name配置" class="headerlink" title="hexo new_post_name配置"></a>hexo new_post_name配置</h4></li>
</ul>
<blockquote>
<p>假如想要更改每一篇博客的文件名称,不再是默认的:title.md的文件名,需要更改hexo博客项目根目录底下的_config.yml文件,更改new_post_name配置</p>
</blockquote>
<pre><code>new_post_name: :year-:month-:day-:title.md
</code></pre><ul>
<li><h4 id="hexo-auto-excerpt阅读全文配置"><a href="#hexo-auto-excerpt阅读全文配置" class="headerlink" title="hexo auto_excerpt阅读全文配置"></a>hexo auto_excerpt阅读全文配置</h4></li>
</ul>
<blockquote>
<p>博客文章一般都会很长的,所以在首页要对博客进行超长截断,要想看所有的内容,点击阅读全文或者文章标题进入全文查看,需要更改主题项目目录底下的_config.yml文件,全局搜索auto_excerpt,更改auto_excerpt配置</p>
</blockquote>
<pre><code>auto_excerpt:
    enable: true
    length: 200
</code></pre><ul>
<li><h4 id="hexo-其他配置"><a href="#hexo-其他配置" class="headerlink" title="hexo 其他配置"></a>hexo 其他配置</h4></li>
</ul>
<blockquote>
<p>更改hexo博客项目根目录底下的_config.yml文件,更改网站title(标题)、author(作者)、keywords(关键字)、description(描述)配置,比如本人的配置</p>
</blockquote>
<pre><code>title: yinwk_Gary Blog
author: yinwk_Gary
keywords: hexo,hexo-cli,hexo博客,hexo博客个人网站
description: Gary&apos;s blog,记录_从今天开始
</code></pre><blockquote>
<p>设置个人的github(github托管代码网址)、google(google个人资料网址)、gmail(gmail邮箱网址)、twitter(twitter个人微博网址)等等,比如本人的配置</p>
</blockquote>
<pre><code>social:
  GitHub: https://github.com/dreamthen || github
  E-Mail: https://dreamthen.00@gmail.com || envelope
  Google: https://plus.google.com/u/0/103833130011211353424 || google       
</code></pre><p>#hexo命令</p>
<blockquote>
<p>首先建立一篇名为hexo配置的博客</p>
</blockquote>
<pre><code>hexo new hexo配置
</code></pre><blockquote>
<p>在hexo博客项目source目录底下的_post目录下找到名为hexo配置的博客文件,在里面用markdown进行记录自己的博客,当然可以在hexo server自带的服务器运行监听的情况下,进行添加和修改自己的博客。之后，进行生成静态文件</p>
</blockquote>
<pre><code>hexo generate
</code></pre><blockquote>
<p>生成静态文件之后,进行部署</p>
</blockquote>
<pre><code>hexo deploy
</code></pre><blockquote>
<p>生成静态文件和部署可以使用一句命令执行</p>
</blockquote>
<pre><code>hexo generate -deploy
hexo deploy -generate
</code></pre><blockquote>
<p>为了防止存在静态文件和缓存,造成没有重新渲染页面的问题,在每一次部署之前,要运行一下清理静态文件和缓存的命令</p>
</blockquote>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><blockquote>
<p>hexo deploy部署之后,根据hexo博客项目根目录底下_config.yml配置文件的deploy git配置,会提交到远程github repository库                     </p>
</blockquote>
]]></content>
      <categories>
        <category>hexo博客搭建工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-25 react优化</title>
    <url>/2018/04/25/react%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h1><blockquote>
<p>由于React使用的虚拟DOM在其节点发生变化时,React会使用Diff算法对前后的虚拟DOM树进行对比,一旦发现不同,虚拟DOM树就会从根结点进行重新刷新,而浏览器进行实际操作DOM的仅仅是diff的部分,尽管每次虚拟DOM都会从根结点进行重新刷新,但是由于javascript是存储在内存中,所以性能很高,但是每一次都会从虚拟DOM的根结点进行重新刷新,会造成一些无谓的虚拟DOM树的重新刷新,比如父组件的虚拟DOM节点修改发生了变化,虚拟DOM节点根据diff算法进行对比之后,就会从虚拟DOM根结点进行重新刷新,但是其子组件并没有发生虚拟DOM的修改,这是子组件也会跟着父组件一起进行虚拟DOM树的diff算法对比和虚拟DOM节点的重新刷新,也耗费了比较多的时间。为了避免无谓的虚拟DOM树diff算法对比和虚拟DOM根结点的重新刷新,React给开发者提供了shouldComponentUpdate进行判断,shouldComponentUpdate是运行在虚拟DOM树diff算法对比和虚拟DOM树根结点重新渲染之前的,假如返回true就说明,数据发生了变化,需要进行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新,否则就返回false,不执行虚拟DOM树diff算法对比以及虚拟DOM根结点的重新刷新。</p>
</blockquote>
<h1 id="避免无谓的虚拟DOM树重新刷新"><a href="#避免无谓的虚拟DOM树重新刷新" class="headerlink" title="避免无谓的虚拟DOM树重新刷新"></a>避免无谓的虚拟DOM树重新刷新</h1><blockquote>
<p>假如有一个组件仅仅渲染一个字符串,利用shouldComponentUpdate进行判断,避免无谓的虚拟DOM树重新刷新</p>
</blockquote>
<pre><code>class TextView extends React.Component{
    static propTypes = {
        value: PropTypes.string.isRequired
    };

    constructor(props){
        super(props);
        this.state = {
        };
    }

    shouldComponentUpdate(nextProps, nextState){
        return this.props.value !== nextProps.value;
    }

    render(){
        let {value} = this.props;
        return (
            &lt;h1&gt;
                {value}
            &lt;/h1&gt;
        )
    }
}
</code></pre>]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react思想</title>
    <url>/2018/04/26/react%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="React主体思想"><a href="#React主体思想" class="headerlink" title="React主体思想"></a>React主体思想</h1><blockquote>
<p>React的主体思想:数据驱动。就是利用数据的变化,来引起View视图的变化。React使用的是jsx(js + xml)语法和虚拟DOM,虚拟DOM是React做的一件很革新的事情,在React之前,DOM操作十分昂贵,大量的DOM操作耗费了web网站大量的时间,性能比较低。React使用Javascript模拟DOM,来进行View视图的渲染,虚拟DOM节点发生变化时,React首先会利用diff算法对前后的虚拟DOM树进行对比,一旦发现有所不同,就会引起虚拟DOM从根结点进行重新刷新,而浏览器实际操作DOM的仅仅是diff部分,尽管每一次虚拟DOM都会从根结点进行重新刷新,但是由于是内存数据,所以性能很高,而浏览器实际操作DOM的仅仅是diff的部分,所以很大程度上提高了web网站的性能。</p>
</blockquote>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-27 关于webpack</title>
    <url>/2018/04/27/%E5%85%B3%E4%BA%8Ewebpack/</url>
    <content><![CDATA[<h1 id="关于webpack"><a href="#关于webpack" class="headerlink" title="关于webpack"></a>关于webpack</h1><blockquote>
<p>使用webpack已有大半年,从webpack 1.0直到4.0,都有尝试过,每次升级都比较痛苦,今天梳理一下不同点</p>
</blockquote>
<h2 id="webpack-1-0"><a href="#webpack-1-0" class="headerlink" title="webpack 1.0"></a>webpack 1.0</h2><blockquote>
<p>webpack是现如今非常流行、易用语义化很明显的打包压缩工具,废话不多说,直接上代码(会有明确的注释)。<br>PS：react使用的是CommonJS模块化语法</p>
</blockquote>
<pre><code>const webpack = require(&quot;webpack&quot;),
    //对于路径管理的外部依赖包
    path = require(&quot;path&quot;),
    //自动添加css扩展头以兼容低版本浏览器的外部依赖包
    autoprefixer = require(&quot;autoprefixer&quot;),
    //处理打包css的webpack plugin插件
    ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;),
    //处理打包html的webpack plugin插件
    HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

const PUBLIC_DIR = &quot;/&quot;,
    //路径巡航,先进入webpack文件所在的路径,然后再进入根路径,我这里是把webpack配置文件放在了根路径底下的一个文件夹里面
    ROOT_DIR = path.resolve(__dirname, &quot;../&quot;)
</code></pre>]]></content>
      <categories>
        <category>webpack or webpack-dev-server</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>webpack-dev-server</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-25 react-router 3.0 browserHistory配置</title>
    <url>/2018/04/25/react-router-3-0-browserHistory%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="为什么推荐使用browserHistory-舍弃hashHistory"><a href="#为什么推荐使用browserHistory-舍弃hashHistory" class="headerlink" title="为什么推荐使用browserHistory,舍弃hashHistory"></a>为什么推荐使用browserHistory,舍弃hashHistory</h1><blockquote>
<ol>
<li>首先browserHistory从表现来看,比较舒服和语义化,更易读。</li>
<li>browserHistory使用的是HTML5的History API,根据路由路径的变化引起浏览器历史记录的变化;hashHistory则是依靠hash的改变,来使得浏览器的历史记录发生改变。hashHistory的hash部分不会请求到服务端,服务端获取不到URL的细节部分,而browserHistory使用的History API需要服务端的支持,服务端可以完全的掌握URL中的细节部分。</li>
<li>有一些浏览器会把hashHistory URL当中的hash部分删除掉,记起之前进行分享的时候,URL传到微信中,hash部分遭到丢失。</li>
</ol>
</blockquote>
<h1 id="browserHistory配置"><a href="#browserHistory配置" class="headerlink" title="browserHistory配置"></a>browserHistory配置</h1><blockquote>
<p>路由上面除了引入不同,基本上和hashHistory配置相同</p>
</blockquote>
<pre><code>import {Router, browserHistory} from &quot;react-router&quot;;
&lt;Router history={browserHistory}&gt;
&lt;/Router&gt;
</code></pre><blockquote>
<p>配置路径为空时,callback的处理,使用webpack-dev-server时,在配置文件内部添加</p>
</blockquote>
<pre><code>historyApiFallback: true
</code></pre><blockquote>
<p>使用nginx时,在配置文件内部添加</p>
</blockquote>
<pre><code>location / {
    root ...
    index index.html index.htm
    try_files $uri /index.html
}
</code></pre>]]></content>
      <categories>
        <category>react-router</category>
      </categories>
      <tags>
        <tag>react-router</tag>
        <tag>browserHistory</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-27 关于webstorm</title>
    <url>/2018/04/27/%E5%85%B3%E4%BA%8Ewebstorm/</url>
    <content><![CDATA[<h1 id="webstorm-license-server"><a href="#webstorm-license-server" class="headerlink" title="webstorm license server"></a>webstorm license server</h1><blockquote>
<p>从毕业就开始使用webstorm,从webstorm 11到webstorm 2017,再到现在的webstorm 2018,webstorm IDE功能越来越强大,但是我从来不使用正版,而今天就给大家介绍一下,在使用盗版过程中最大的困难——license server。在最初的时候,我也是百度的一些Activation code,后来发现这些Activation code极不稳定,可能是一个Activation code只能在一个终端使用吧,我放弃了使用Activation code的方式。</p>
</blockquote>
<blockquote>
<p>后来,在<b>Webstorm吧</b>找到了一种可以设置试用期到2099年的方法:改变本地的日期时间至2099年11月30日,然后安装webstorm,选择试用,试用期一个月,这时候你的试用期就到了2099年的12月31日。假如你已经安装了webstorm,直接找到WINDOWS系统,C:/Users(用户)/你的WINDOWS电脑用户名/.Webstorm2017.2/config/eval,直接将eval文件删掉,重新打开webstorm,更改本地日期,后面的操作就同上了。直到2017.3版本之前,使用的很舒服,到了2017.3版本,JetBrains发现了这个漏洞,进行了修补,由此也放弃了使用这种方式。</p>
</blockquote>
<blockquote>
<p>再之后,就开始使用license server,使用的license server如下:</p>
</blockquote>
<pre><code>http://idea.imsxm.com (2017.3.3版本极其之前版本可用)
http://idea.iteblog.com/key.php (2017.1可用)
http://www.aku.vn/idea (2017.1可用)
http://idea.ibdyr.com (2017.3.3版本极其之前版本可用)
</code></pre><blockquote>
<p>再后来,就开始使用本地nginx反向代理<a href="http://idea.imsxm.com,将下面的配置放进server中" target="_blank" rel="noopener">http://idea.imsxm.com,将下面的配置放进server中</a>:</p>
</blockquote>
<pre><code>location /rpc {
        proxy_pass   http://idea.imsxm.com/rpc;
        proxy_redirect             off;
        proxy_set_header           Host $host;
        proxy_set_header           X-Real-IP $remote_addr;
        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
}
</code></pre><blockquote>
<p>现在连本地nginx反向代理都失效了,jetbrains在2017.3.4版本使用了ip地址动态封禁,经过我很长时间的寻找,找到了现在在2018版本之后都可使用的license server:</p>
</blockquote>
<pre><code>http://www.activejetbrains.ml
</code></pre><blockquote>
<p>最新的license server转自网上的一篇文章,来源于<a href="https://www.imsxm.com/jetbrains-license-server.html" target="_blank" rel="noopener">https://www.imsxm.com/jetbrains-license-server.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-27 关于异步</title>
    <url>/2018/04/27/%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h1><blockquote>
<p>异步在JS中的表现分为三类:</p>
<ol>
<li>时间延迟,比如setTimeout,setInterval这种时间处理函数</li>
<li>事件处理,比如onClick(点击事件),onChange(输入框内容改变回调),onMouseover(鼠标移入事件),onMouseout(鼠标移出事件),onMouseEnter(鼠标移入事件),onMouseLeave(鼠标移出事件)等等</li>
<li>xhr、fetch请求等等</li>
</ol>
</blockquote>
<h1 id="为什么会出现异步"><a href="#为什么会出现异步" class="headerlink" title="为什么会出现异步"></a>为什么会出现异步</h1><blockquote>
<p>由于JS是单线程(同一时间,只能做一件事情)的语言,为了实现时间延迟、事件处理和xhr、fetch请求处理这些必须是异步的操作,JS必须处理单线程怎样异步的问题。</p>
</blockquote>
<h1 id="为什么JS要使用单线程"><a href="#为什么JS要使用单线程" class="headerlink" title="为什么JS要使用单线程"></a>为什么JS要使用单线程</h1><blockquote>
<p>JS使用单线程,是由于JS中不仅仅有ECMAScript,还有DOM(Document Object Modal),html渲染DOM,JS也可以动态改变DOM,假如JS不是单线程,同一时间可以处理多件事情,html渲染DOM和JS动态改变DOM就会混乱,浏览器会不知道是先渲染html DOM,还是先执行JS动态改变DOM,即使是实现了多线程的WebWorker,也没有触及DOM部分。</p>
</blockquote>
<h1 id="关于异步"><a href="#关于异步" class="headerlink" title="关于异步"></a>关于异步</h1><blockquote>
<p>JS使用单线程,运行时,先会运行同步代码,如果遇到异步代码,就会先将异步代码放进内存的异步队列中,待到同步代码运行完毕,就会去轮询异步队列中的异步代码。</p>
</blockquote>
<blockquote>
<p>假如异步闭包中还存在异步闭包,在异步队列中,就会将里层的异步闭包push到外层的异步闭包后面,待到外层的异步闭包执行完毕之后,再执行里层的异步闭包。</p>
</blockquote>
<h1 id="使用异步出现的问题"><a href="#使用异步出现的问题" class="headerlink" title="使用异步出现的问题"></a>使用异步出现的问题</h1><blockquote>
<p>JS使用异步解决了JS单线程的问题,但是异步却又引起了另外一个问题,就是异步情况下的同步执行,尤其是xhr、fetch的请求,由于响应时间不确定,很容易引起异步执行混乱的问题。</p>
</blockquote>
<h1 id="异步的演变过程"><a href="#异步的演变过程" class="headerlink" title="异步的演变过程"></a>异步的演变过程</h1><h4 id="setTimeout-callback"><a href="#setTimeout-callback" class="headerlink" title="setTimeout callback"></a>setTimeout callback</h4><blockquote>
<p>之前还没有使用nodejs的时候,解决异步问题基本上使用的是setTimeout使用异步闭包去解决异步的方式,比如在react中,setState就是异步执行的,假如name的初始值为Gary</p>
</blockquote>
<pre><code>componentWillMount() {
    this.setState({
        name: &quot;Yinwk&quot;
    });
    this.setState({
        name: &quot;CLAY&quot;
    });
    //这时候由于setState是异步的,所以会先执行同步代码,也就是说这时候this.state.name的值依然为Gary
    console.log(this.state.name);
}


componentWillMount() {
    setTimeout(function timer(){
        this.setState({
            name: &quot;Yinwk&quot;
        });
        //这时候this.state.name的值就变为了Yinwk
        console.log(this.state.name);
        setTimeout(function timer(){
            this.setState({
                name: &quot;CLAY&quot;
            });
            //这时候this.state.name的值就变为了CLAY
            console.log(this.state.name);
        }.bind(this), 0);
    }.bind(this), 0)
}
</code></pre><h4 id="EventEmitter-并不是异步问题的解决方案"><a href="#EventEmitter-并不是异步问题的解决方案" class="headerlink" title="EventEmitter(并不是异步问题的解决方案)"></a>EventEmitter(并不是异步问题的解决方案)</h4><blockquote>
<p>nodejs出现之后,event模块有一个类——EventEmitter,一直以为它是一个消息管理模块,跟Event Loop异步队列有着千丝万缕的关系,后来看了源码,发现它并不是一个消息管理模块,跟消息队列没有任何关系,on/emit只是一个监听的观察者模式,on时添加/删除listener,emit时运行回调函数。还是拿上一个例子进行举例,假如name的初始值为Gary</p>
</blockquote>
<pre><code>import {EventEmitter} from &quot;events&quot;;

const eventEmitter = new EventEmitter();

componentWillMount(){
    eventEmitter.on(&quot;gary&quot;, () =&gt; {
        this.setState({
            name: &quot;Yinwk&quot;
        });
        console.log(this.state.name);
    });
    //这里打印出的this.state.name还是Gary,由于EventEmitter跟消息队列没有任何关系,所以并不是异步,只是一个监听的观察者模式,所以是同步的
    eventEmitter.emit(&quot;gary&quot;);
}
</code></pre><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><blockquote>
<p>ES6语法发布之后,Promise成为了新的解决异步问题的方案,实质的也是利用异步闭包来解决异步问题。还是拿最初的例子进行举例,假如name的初始值为Gary</p>
</blockquote>
<pre><code>ComponentWillMount() {
    (function iifeSetName() {
        return new Promise(function promise(resolve, reject) {
            this.setState({
                name: &quot;Yinwk&quot;
            });
            resolve();
        }.bind(this));
    }.bind(this))().then(function resolve() {
        //这里打印出的this.state.name就是Yinwk
        console.log(this.state.name);
    }.bind(this), function reject() {

    }.bind(this));   
}
</code></pre><h4 id="yield-and"><a href="#yield-and" class="headerlink" title="yield and *"></a>yield and *</h4><blockquote>
<p>再到后来最新的解决异步的方案:yield *配合Promise,也就是Generator控制迭代器,执行时每执行到yield时,就会停止执行并返回一个Iterator迭代器,且会保留上下文,直到下次运行,社区tj大神的co函数同步读取文件就是使用了yield *配合Promise</p>
</blockquote>
<pre><code>const fs = require(&quot;fs&quot;);

function readFile(file){
    return new Promise((resolve, reject) =&gt; {
        fs.readFile((err, data) =&gt; {
            if(err) reject(err);
            resolve(data);
        });       
    });
}

function *gc() {
    let a = yield readFile(&quot;../data/file_first.txt&quot;);
    console.log(a);
    let b = yield readFile(&quot;../data/file_second.txt&quot;);
    console.log(b);
    return b;
}

co(gc).then(function resolve(data){
    console.log(data);
}.bind(this), function reject(){

}.bind(this));

//co函数利用yield * + Promise同步读取文件
function co(gc_co){
    let gc = gc_co();
    return new Promise((resolve, reject) =&gt; {
        //这里实现一个Generator控制迭代器的迭代循环
        (function readData(data){
            let gcNext = gc.next(data),
                value = gcNext.value,
                done = gcNext.done;
            if(done) {
                resolve(value);
            } else {
                value.then(readData, reject);
            }
        })();
    });
}
</code></pre><h4 id="async-and-await"><a href="#async-and-await" class="headerlink" title="async and await"></a>async and await</h4><blockquote>
<p>现如今的推出的解决异步问题的最终解决方案:async和await,很好的解决了异步的问题,且当await Promise时,返回的是fulfilled和rejected返回的结果。还是拿最初的例子进行举例,假如name的初始值为Gary</p>
</blockquote>
<pre><code>ComponentWillMount() {
    (async function iifeSetName() {
        await this.setState({
            name: &quot;Yinwk&quot;
        });
        //这里打印出的this.state.name就是Yinwk
        await console.log(this.state.name);
    }.bind(this))();
}
</code></pre><blockquote>
<p>还可以这样</p>
</blockquote>
<pre><code>ComponentWillMount() {
    (async function iifeSetName() {
        let name = await new Promise((resolve, reject) =&gt; {
            this.setState({
                name: &quot;Yinwk&quot;
            });
            resolve();
        }).then(()=&gt;{
            return this.state.name;
        }, ()=&gt;{

        });
        //这里打印出的this.state.name就是Yinwk
        await console.log(name);
        //这里打印出的this.state.name还是Yinwk
        await console.log(this.state.name);
    }.bind(this))();
}    
</code></pre>]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-30 关于闭包</title>
    <url>/2018/04/30/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h1><blockquote>
<p>A函数作为B函数的参数,并在B函数中执行,A函数就是回调函数。</p>
</blockquote>
<pre><code>function setTimer(fn, timer) {
    fn(timer);
}

//function timer就是function setTimer的回调函数
setTimer(function timer(time) {
    console.log(time);
}, 1000);
</code></pre><blockquote>
<p>回调函数也分同步和异步,上例就是同步,而像setTimeout,setInterval中这种牵扯到消息队列(异步队列),Event Loop的回调函数来说,就是异步。</p>
</blockquote>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><blockquote>
<p>“A函数中包含B函数,并返回B函数,调用B函数可以使用A函数作用域中定义的变量”,B函数就是闭包,示例如下:</p>
</blockquote>
<pre><code>function foo() {
    let _name = &quot;Gary&quot;;
    function bar() {
        console.log(`name: ${_name}`);
    }
    return bar;
}
//foo函数执行之后,作用域会被销毁,随之而然的作用域中定义的变量应该会被销毁,并被引擎垃圾回收机制回收,
//但是在这里神奇的事情发生了,foo函数作用域并没有被销毁之后回收,而是还存在于内存中,并被bar使用,这里就形成了闭包。
let bar = foo();
bar();
</code></pre><blockquote>
<p>还有一种形式是这样</p>
</blockquote>
<pre><code>function foo() {
    let _name = &quot;Gary&quot;;
    function bar() {
        console.log(`name: ${_name}`);
    }
    baz(bar);
}

//这里在foo函数执行之后,按理来说,foo函数中作用域,以及其中_name变量,都会被销毁,并随后被引擎垃圾回收机制回收。
//但是神奇的是,这里的作用域并没有被销毁,而其中的_name变量也没有被销毁,当然也没有被引擎垃圾回收机制回收,而还是存储于内存中,并被bar使用,这里就形成了闭包。
function baz(fn) {
    fn();
}

foo();
</code></pre>]]></content>
      <categories>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-04-30 webpack打包如何防止第三方依赖包体积过大造成打包速度慢的问题</title>
    <url>/2018/04/30/webpack%E6%89%93%E5%8C%85%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BF%87%E5%A4%A7%E9%80%A0%E6%88%90%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="为何第三方依赖包会引起打包的体积过大"><a href="#为何第三方依赖包会引起打包的体积过大" class="headerlink" title="为何第三方依赖包会引起打包的体积过大"></a>为何第三方依赖包会引起打包的体积过大</h1><blockquote>
<p>ES6的模块化机制,当引入外部第三方依赖包时,无论是否已经引入,都会再次将其引入进来,这时候就会存在重复引入导致打包体积过大、打包速度过慢的问题。</p>
</blockquote>
<h1 id="如何解决重复引入第三方依赖包-引起的打包体积过大以及打包速度过慢的问题"><a href="#如何解决重复引入第三方依赖包-引起的打包体积过大以及打包速度过慢的问题" class="headerlink" title="如何解决重复引入第三方依赖包,引起的打包体积过大以及打包速度过慢的问题"></a>如何解决重复引入第三方依赖包,引起的打包体积过大以及打包速度过慢的问题</h1><blockquote>
<ol>
<li>使用CommonsChunkPlugin提取公共模块,理想状态下是将第三方外部依赖包、业务代码、业务代码中的重复引入的公共部分和webpack的引导程序以及manifest 加载运行外部依赖包都分别打成一个包,减小打包体积,提高打包的速度。</li>
</ol>
</blockquote>
<pre><code>const webpack = require(&quot;webpack&quot;),
      HtmlWebpackIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;),
      HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

const PUBLIC_DIR = &quot;/&quot;;

module.exports = {
    entry: {
        //login入口有引入testConfig.js以及reactConfig.js
        login: `${APP_DIR}/login.js`,
        //index入口也有引入testConfig.js以及reactConfig.js
        index: `${APP_DIR}/index.js`,
        //app入口没有引入testConfig.js,也没有引入reactConfig.js
        app: `${APP_DIR}/app.js`,
        //mobile入口有引入testConfig.js,却没有引入reactConfig.js
        mobile: `${APP_DIR}/mobule.js`
    },
    plugins: [
        //...
        //首先我想把四个入口中的公共模块,包括引入的第三方外部依赖包都提取出来
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;common&apos;,
            filename: &apos;js/common.[hash].js&apos;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;login.html&quot;,
            template: `${ROOT_DIR}/login.html`,
            chunks: [&quot;common&quot;, &quot;login&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;index.html&quot;,
            template: `${ROOT_DIR}/index.html`,
            chunks: [&quot;common&quot;, &quot;index&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;app.html&quot;,
            template: `${ROOT_DIR}/app.html`,
            chunks: [&quot;common&quot;, &quot;app&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;mobile.html&quot;,
            template: `${ROOT_DIR}/mobile.html`,
            chunks: [&quot;common&quot;, &quot;mobile&quot;],
            inject: &quot;body&quot;
        })
        //发现这样行不通,打包之后,common.[hash].js中只有webpack引导程序以及manifest 加载运行模块的代码,公共部分并没有办法提取出来。
        //后来查找原因,原来是CommonsChunkPlugin中的minChunks属性默认设置为公共模块部分最小在全部入口全部引入,才会被提取合成公共代码。
        //知道了原因,那就简单了,直接设置minChunks: 2,也就是说只要公共模块最小在两个入口引入,就可以被提取出来作为公共模块部分。
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;common&apos;,
            filename: &apos;js/common.[hash].js&apos;,
            minChunks: 2
        }),
        ...
        //这样设置之后发现是可以的,将公共的第三方的外部依赖包、testConfig.js、reactConfig.js、webpack引导程序以及manifest 加载运行模块部分都提取出来,打包至common.[hash].js中,减小了打包的体积,加快了打包速度。
        //试想假如我只想提取testConfig.js模块
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;common&apos;,
            filename: &apos;js/common.[hash].js&apos;,
            //minChunks还可以是一个函数,接收两个参数,module是指入口所引入的每一个模块,count则是指module被几个入口所调用
            //module有两个属性: context和resource
            //context: 模块所存储的目录位置
            //resource: 模块所执行的文件名称
            //这里就是使用resource模块所执行的文件名称去匹配testConfig,且模块至少被两个入口所引入,这样就可以单独提取testConfig.js文件了
            minChunks: function(module, count) {
                return module.resource &amp;&amp; /testConfig/.test(module.resource) &amp;&amp; count &gt;= 2;
            }
        }),
        ...
    ],
    //将第三方公共依赖包与testConfig.js、reactConfig.js这种业务开发所使用的公共模块分离开,使得第三方公共依赖包分离在另一个包下
    entry: {
        //login入口有引入testConfig.js以及reactConfig.js
        login: `${APP_DIR}/login.js`,
        //index入口也有引入testConfig.js以及reactConfig.js
        index: `${APP_DIR}/index.js`,
        //app入口没有引入testConfig.js,也没有引入reactConfig.js
        app: `${APP_DIR}/app.js`,
        //mobile入口有引入testConfig.js,却没有引入reactConfig.js
        mobile: `${APP_DIR}/mobule.js`,
        //设置一个第三方外部依赖包的入口
        vendor: [&apos;react&apos;, &apos;react-redux&apos;, &apos;redux&apos;, &apos;react-router&apos;, &apos;redux-thunk&apos;, &apos;redux-logger&apos;, &apos;react-dom&apos;, &apos;react-addons&apos;, &apos;prop-types&apos;, &apos;moment&apos;, &apos;antd&apos;, &apos;babel-polyfill&apos;]
    },
    plugins: [
        ...
        //这里无论入口是否引入了vendor入口数组里面的第三方依赖包,它都会对数组里面的第三方外部依赖包进行提取,当然这里的第三方外部依赖包是有限制的,module.context在这里起到了作用,只有模块所存储的路径含有&quot;node_modules&quot;的情况下,也就是说只有是在npm下载的第三方外部依赖包,才会被提取出来。
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;vendor&apos;,
            filename: &apos;js/vendor.[hash].js&apos;,
            minChunks: function(module, count) {
                return module.context &amp;&amp; module.context.includes(&quot;nodule_modules&quot;);
            }
        }),
        //这样提取第三方外部依赖包是可以的,直接提取到js文件夹里面的vendor.[hash].js
        //上面以及所有的提取的公共模块文件加hash的原因,是为了防止浏览器的永久缓存机制,使得文件更新过后,使用的还是原来文件的内容。
        //提取出了第三方外部依赖包之后,由于想到它们不是业务代码,很少进行修改,尽量的多利用浏览器永久缓存机制,所以为了防止每一次构建都会引起它们hash值的改变,不能利用浏览器永久缓存机制,要把webpack引导程序以及manifest 加载运行文件提取到另一个模块包中。
        //这里manifest就是隐藏的webpack引导程序以及manifest 加载和运行模块文件的入口
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;manifest&apos;,
            filename: &apos;js/manifest.[hash].js&apos;,
            minChunks: Infinity
        }),
        //这样提取webpack引导程序以及manifest 加载和运行文件是可以的,直接提取到js文件夹里面的manifest.[hash].js
        //再提取出业务使用的像testConfig.js、reactConfig.js公共模块,想着应该可以满足需求,业务代码的公共部分一个模块包,第三方外部依赖包一个模块包,以及webpack引导程序和manfiest 加载运行模块文件一个模块包
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;common&apos;,
            filename: &apos;js/common.[hash].js&apos;,
            minChunks: 2
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;login.html&quot;,
            template: `${ROOT_DIR}/login.html`,
            chunks: [&quot;manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;login&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;index.html&quot;,
            template: `${ROOT_DIR}/index.html`,
            chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;index&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;app.html&quot;,
            template: `${ROOT_DIR}/app.html`,
            chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;app&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;mobile.html&quot;,
            template: `${ROOT_DIR}/mobile.html`,
            chunks: [manifest&quot;, &quot;vendor&quot;, &quot;common&quot;, &quot;mobile&quot;],
            inject: &quot;body&quot;
        })
        //发现这样实现是不可以的,第三方外部依赖包的模块包,webpack引导程序以及manifest 加载和运行模块文件的模块包被打出来了。
        //但是common.[hash].js中却没有至少两个入口共同引入业务代码公共模块的部分,还是被分别打进了业务代码模块包中。
        //且common.[hash].js中的代码实际上是webpack运行文件以及manfiest 加载和运行模块的文件部分,manfiest.[hash].js也不见了,好像common.[hash].js替换掉了。
        //原因到现在还没有找到...
        //CommonsChunkPlugin的缺点就在于:即使我使用了vendor的方式去提取公共的第三方外部依赖包模块,还是在每一次构建的时候,都会去进行打包,像我前面说的,第三方外部依赖包模块不像业务代码,很少进行修改。
        //所以每一次都去进行打包,还是不妥当的,花费了很多时间在打包第三方外部依赖包上面。
    ]
};
</code></pre><blockquote>
<ol start="2">
<li>使用DllPlugin、DllReferencePlugin、CommonsChunkPlugin以及HtmlWebpackIncludeAssetsPlugin实现对第三方外部依赖包模块、业务代码公共模块以及webpack引导程序和manifest 加载和运行模块文件都分别打成一个包,减小打包体积,提高打包的速度。</li>
</ol>
</blockquote>
<pre><code>//使用DllPlugin和DllReferencePlugin,就不需要像CommonsChunkPlugin那样,对于第三方外部依赖包模块,每次都要去构建打包了,只需要另外配置一个webpack配置文件,就可以实现一劳永逸的体验。
//只要没有下载新的第三方外部依赖包模块,就不需要利用webpack.dll.config配置文件去打dll包,总体上减少了每次都构建第三方外部依赖包模块的时间。
//webpack.dll.config配置
const webpack = require(&quot;webpack&quot;),
    path = require(&quot;path&quot;);

const PUBLIC_DIR = &quot;/&quot;,
    DLL_DIR = path.resolve(__dirname, &quot;../dll&quot;),
    ROOT_DIR = path.resolve(__dirname, &quot;../..&quot;);

const webpackDllConfig = {
    devtool: &quot;source-map&quot;,
    entry: {
        vendor: [&quot;react&quot;, &quot;react-router&quot;, &quot;redux&quot;, &quot;react-redux&quot;, &quot;redux-thunk&quot;, &quot;redux-logger&quot;, &quot;react-dom&quot;, &quot;react-addons&quot;, &quot;prop-types&quot;, &quot;antd&quot;, &quot;babel-polyfill&quot;]
    },
    output: {
        publicPath: PUBLIC_DIR,
        path: DLL_DIR,
        filename: &quot;[name].dll.js&quot;,
        library: &quot;[name]_[chunkhash]&quot;
    },
    plugins: [
        //防止打包过程中出现错误,中断打包
        new webpack.NoEmitOnErrorsPlugin(),
        //谈一下DllPlugin,DllPlugin的机制是根据webpack制定的id映射到vendor入口中的第三方外部依赖包模块的路径上,生成映射关系,打包后,生成vendor.dll.js文件和vendor_manifest.dll.json文件,这个文件的内容是webpack制定的id与vendor入口中的第三方外部依赖包模块的映射数据,之后再使用DllReferencePlugin将vendor_manifest.dll.json文件引入到业务代码打包的配置文件的manfiest 加载和运行模块文件中,最后只要将vendor.dll.js引入到你所选择的业务代码入口就可以了。
        //vendor.dll.js的作用是,根据vendor_manifest.dll.json中webpack制定的id与vendor入口中第三方外部依赖包模块路径的映射关系,业务代码入口所引入的第三方外部依赖包模块,都会通过vendor.dll.js全局函数进行处理,并根据所引入的第三方外部依赖包模块的id进行使用,且这样并不会把库文件中的代码也打包进去
        new webpack.DllPlugin({
            path: path.join(DLL_DIR, &quot;[name]_manifest.dll.json&quot;),
            //name必须和output的library属性保持一致
            name: &quot;[name]_[chunkhash]&quot;,
            context: ROOT_DIR
        }),
        //对打包代码进行压缩
        new webpack.optimize.UglifyJsPlugin({
            uglifyOptions: {
                sourceMap: true,
                compress: {
                    unused: false,
                    dead_code: false,
                    warnings: true
                },
                output: {
                    comments: true
                }
            }
        })
    ]
};

export default webpackDllConfig;

//业务代码webpack打包配置文件
const webpack = require(&quot;webpack&quot;),
    path = require(&quot;path&quot;),
    //用来复制目录或者目录下的文件的插件
    CopyWebpackPlugin = require(&quot;copy-webpack-config&quot;),
    //用来将vendor.dll.js插入到业务代码入口的插件,但不可选择插入的入口业务代码文件,默认会将所有的入口业务代码都插入vendor.dll.js
    AddAssetHtmlPlugin = require(&quot;add-asset-html-webpack-plugin&quot;),
    //用来将vendor.dll.js插入到业务代码入口的插件,可选择插入的入口业务代码文件
    HtmlWebpackIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;),
    HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

const PUBLIC_DIR = &quot;/&quot;,
    ROOT_DIR = path.resolve(__dirname, &quot;../&quot;),
    BUILD_DIR = path.resolve(__dirname, &quot;../build&quot;),
    DLL_DIR = path.resolve(__dirname, &quot;../dll&quot;),
    IMAGE_DIR = path.resolve(__dirname, &quot;../images&quot;),
    MANIFEST_DIR = require(path.resolve(__dirname, `${DLL_DIR}/vendor_manifest.dll.json`));

const webpackProdConfig = {
    entry: {
        //login入口有引入testConfig.js以及reactConfig.js
        login: `${APP_DIR}/login.js`,
        //index入口也有引入testConfig.js以及reactConfig.js
        index: `${APP_DIR}/index.js`,
        //app入口没有引入testConfig.js,也没有引入reactConfig.js
        app: `${APP_DIR}/app.js`,
        //mobile入口有引入testConfig.js,却没有引入reactConfig.js
        mobile: `${APP_DIR}/mobule.js`
    },
    ...
    plugins: [
        ...
        //这里就是将vendor_manfiest.dll.json第三方外部依赖包模块引入到业务代码的打包配置文件的manifest 加载和运行模块文件中
        new webpack.DllReferencePlugin({
            manifest: MANIFEST_DIR,
            context: ROOT_DIR
        }),
        new CopyWebpackPlugin([{
            context: ROOT_DIR,
            from: IMAGE_DIR,
            to: `${BUILD_DIR}/images`
        },{
            context: ROOT_DIR,
            from: DLL_DIR,
            to: `${BUILD_DIR}/dll`
        }, {
            context: ROOT_DIR,
            from: &quot;./dll/vendor.dll.js&quot;,
            to: &quot;js/&quot;
        }]),
        //这里的AddAssetHtmlPlugin会将所有的业务代码入口都引入vendor.dll.js文件
        //new AddAssetHtmlPlugin({
        //    filepath: &quot;js/vendor.dll.js&quot;,
        //    hash: true
        //}),
        //这里的HtmlWebpackIncludeAssetsPlugin会有选择的将login、index、app入口文件引入vendor.dll.js,可实现按需加载
        //append属性设置为false,是确保vendor.dll.js文件在业务代码包模块之前引入
        new HtmlWebpackIncludeAssetsPlugin({
            assets: [&quot;js/vendor.dll.js&quot;],
            files: [&quot;login.html&quot;, &quot;index.html&quot;, &quot;app.html&quot;],
            append: false,
            hash: true
        }),
        //这样第三方外部依赖包模块就生成了,当每次没有新的第三方外部依赖包模块下载时,就可以直接利用vendor.dll.js全局函数处理对引入的webpack制定的id与vendor_manfiest.dll.json中的第三方外部依赖包模块路径的映射进行调用
        new webpack.optimize.CommonsChunkPlugin({
            name: &quot;common&quot;,
            filename: &quot;js/common.[hash].js&quot;,
            minChunks: 2
        }),
        //这里上面在CommonsChunkPlugin部分有介绍过,直接对业务代码中的公共模块部分进行提取,且至少在两个入口中有公共模块的引入
        new webpack.optimize.CommonsChunkPlugin({
            name: &quot;manifest&quot;,
            filename: &quot;js/manifest.[hash].js&quot;,
            minChunks: Infinity
        }),
        //再将webpack引导程序以及manfiest 加载运行模块文件从common.[hash].js文件中提取出来,这样就完成配置了
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;login.html&quot;,
            template: `${ROOT_DIR}/login.html`,
            chunks: [&quot;manifest&quot;, &quot;common&quot;, &quot;login&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;index.html&quot;,
            template: `${ROOT_DIR}/index.html`,
            chunks: [manifest&quot;, &quot;common&quot;, &quot;index&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;app.html&quot;,
            template: `${ROOT_DIR}/app.html`,
            chunks: [manifest&quot;, &quot;common&quot;, &quot;app&quot;],
            inject: &quot;body&quot;
        }),
        new HtmlWebpackPlugin({
            publicPath: PUBLIC_DIR,
            filename: &quot;mobile.html&quot;,
            template: `${ROOT_DIR}/mobile.html`,
            chunks: [manifest&quot;, &quot;common&quot;, &quot;mobile&quot;],
            inject: &quot;body&quot;
        })
    ]
};
</code></pre><blockquote>
<p>这种由DllPlugin、DllReferencePlugin和HtmlWebpackIncludAssetsPlugin(可实现<b>按需加载</b>)打包第三方外部依赖包模块,由CommonsChunkPlugin提取业务代码公共模块部分和webpack引导程序以及manifest 加载运行模块文件的方式,很好的实现了对第三方外部依赖包模块、业务代码公共模块以及webpack引导程序和manifest 加载和运行模块文件的打包,减小了打包体积,提高了打包的速度。</p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-05-07 查漏补缺</title>
    <url>/2018/05/07/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h1 id="赋值操作的返回"><a href="#赋值操作的返回" class="headerlink" title="赋值操作的返回"></a>赋值操作的返回</h1><blockquote>
<p>最近在读一本《JavaScript DOM 编程艺术》的书,其中有一句话引起了我的好奇,假如if判断语句中存在赋值语句,则赋值语句的返回总是true。我对此结果进行了检验</p>
</blockquote>
<pre><code>var a;
//这种情况下,if判断语句中返回&quot;good&quot;,为true
//打印&quot;good result&quot;
if(a = &quot;good&quot;) {
    console.log(&quot;good result&quot;);
}

//这种情况下,if判断语句中返回false,为false
//什么都不打印
if(a = false) {
    console.log(&quot;good result&quot;);
}

//这种情况下,if判断语句中返回undefined,为false
//什么都不打印
if(a = undefined) {
    console.log(&quot;good result&quot;);
}

//这种情况下,if判断语句中返回0,为false
//什么都不打印
if(a = 0) {
    console.log(&quot;good result&quot;);
}

//这种情况下,if判断语句中返回null,为false
//什么都不打印
if(a = null) {
    console.log(&quot;good result&quot;);
}

//这种情况下,if判断语句中返回{},为true
//打印&quot;good result&quot;
if(a = {}) {
    console.log(&quot;good result&quot;);
}

//这种情况下,if判断语句中返回[],为true
//打印&quot;good result&quot;
if(a = []) {
    console.log(&quot;good result&quot;);
}
</code></pre><blockquote>
<p>实践是检验真理的唯一标准,由此检验到赋值操作的返回就是其本身,本身类型转换后为true,则为true;转换后为false,则为false,并不总是返回true,书中的那句话实践出是不妥当的。</p>
</blockquote>
<h1 id="模板字符串的换行功能"><a href="#模板字符串的换行功能" class="headerlink" title="模板字符串的换行功能"></a>模板字符串的换行功能</h1><blockquote>
<p>学模板字符串时,本来只是以为模板字符串所带来的只不过是一个外部变量引入的功能,这几天发现换行不直接写\n,直接换行编写,就可以实现换行功能</p>
</blockquote>
<pre><code>let name = &quot;Gary&quot;,
    sentence = `Hi, ${name} is my name, 
    I&apos;m 25 year&apos;s old~`;
//这里打印
//Hi, Gary is my name,
//I&apos;m 25 year&apos;s old~    
console.log(sentence);
</code></pre><h1 id="ES6类的存取函数"><a href="#ES6类的存取函数" class="headerlink" title="ES6类的存取函数"></a>ES6类的存取函数</h1><blockquote>
<p>在ES6中实现了类的表象,虽然还是基于原型链来实现的,但是大致的功能正在向着C、Java类的方式逐渐靠近,比如类的存取函数</p>
</blockquote>
<pre><code>class Book {
    constructor(name = &quot;Gary&quot;) {
        this._name = name;
    }
    //类的取值函数
    get getBook() {
        return this._name;
    }
    //类的存储函数
    set setBook(value) {
        this._name = `Hi, ${value}`;
    }
}
//获取到&quot;书&quot;这个类的实例
let book = new Book(&quot;Yinwk&quot;);
//调用实例的取值函数
//这里打印:
//Yinwk
console.log(book.getBook);
//调用实例的存储函数
book.setBook = &quot;yinwenkai&quot;;
//再次调用实例的取值函数
//这里打印:
//yinwenkai
console.log(book.getBook);
</code></pre><h1 id="各类型比较运算符时的转化"><a href="#各类型比较运算符时的转化" class="headerlink" title="各类型比较运算符时的转化"></a>各类型比较运算符时的转化</h1><blockquote>
<p>if(“package” == true) console.log(“package == true”);是会打印”package == true”呢,还是不会打印呢,很多人的答案肯定是会打印,理由是:因为”package”返回true啊,所以true == true啊。请看这里判断语句中是一个比较表达式,并不是if(“package”),是需要在比较语句两边进行转化的,普通类型进行toNumber,引用类型进行valueOf或者toString之后的原始值比较</p>
</blockquote>
<pre><code>if(null == undefeind) {...}    //返回true
if(undefined == null) {...}    //返回true
if(&quot;package&quot; == true) {...}    //将string和boolean类型进行number转化,
                               //&quot;package&quot;转化为NaN,true转化为1,
                               //NaN == 1吗?答案当然是false,返回false

if(&quot;0&quot; == false){...}          //将string和boolean类型进行number转化,
                               //&quot;0&quot;转化为0,false转化为0,
                               //0 == 0吗?答案当然是true,返回true

if(&quot;package&quot; == 1){...}        //将string和number类型进行number转化,
                               //将&quot;package&quot;转化为NaN,1还是转化为1,
                               //NaN == 1吗?答案当然是false,返回false

let _obj = {name: &apos;Gary&apos;},
    _objAno = {name: &apos;Gary&apos;};
if(_obj == _objAno){...}       //将两个object类型进行valueOf方法或者toString方法的转化,哪个方法转化为原始值,就用转化为的原始值进行比较
                               //{name: &apos;Gary&apos;}在valueOf方法转化为{name: &apos;Gary&apos;},在toString方法转化为&quot;[object Object]&quot;
                               //原始值当然是valueOf方法转化的值
                               //{name: &apos;Gary&apos;} == {name: &apos;Gary&apos;}吗？答案当然是false,返回false
</code></pre><h1 id="ES6新增Array-prototype-include"><a href="#ES6新增Array-prototype-include" class="headerlink" title="ES6新增Array.prototype.include"></a>ES6新增Array.prototype.include</h1><blockquote>
<p>ES6数组新增了一个判断是否包含数组元素的方法,用来检索数组中是否存在某个数组元素,基本有两种方式进行检索</p>
</blockquote>
<pre><code>let number_arr = [26, 18, 10, 55, 88, 100, 38, 44];
//数组中的确包含 88 这个元素
//在这里打印:
//true
console.log(number_arr.includes(88));
//从数组下标为 5 的元素后面去寻找 88 这个元素
//在这里打印:
//false
console.log(number_arr.includes(88, 5));                    
</code></pre><h1 id="ES6类型数组"><a href="#ES6类型数组" class="headerlink" title="ES6类型数组"></a>ES6类型数组</h1><blockquote>
<p>在ES6中引入了一些类型数组,他们的属性以及方法和普通的数组并无二致,只是对类型做了一些限制,比如Int8Array(8位二进制补码整数)、Uint8Array(8位无符号整数)、Int16Array(16位二进制补码整数)、Uint16Array(16位无符号整数)、Int32Array(32位二进制补码整数)、Uint32Array(32位无符号整数)等等</p>
</blockquote>
<h1 id="对具有着重符的字符串数组进行排序"><a href="#对具有着重符的字符串数组进行排序" class="headerlink" title="对具有着重符的字符串数组进行排序"></a>对具有着重符的字符串数组进行排序</h1><blockquote>
<p>假如需要对具有着重符号的字符串数组进行排序,需要用localCompare</p>
</blockquote>
<pre><code>let string_arr = [&quot;Maève&quot;, &quot;Maeve&quot;];
string_arr.sort(function sort_arr(a, b){
    return a.localCompare(b);
});
//没有着重符号的数组元素会比有着重符号的数组元素小
//这里打印:
//[&quot;Maeve&quot;, &quot;Maève&quot;]
console.log(string_arr);
</code></pre><h1 id="apply、call硬绑定小经验"><a href="#apply、call硬绑定小经验" class="headerlink" title="apply、call硬绑定小经验"></a>apply、call硬绑定小经验</h1><pre><code>function Person() {
    this.name = &quot;Gary&quot;;
    this.age = 26;
    console.log(this.name);
    console.log(this.age);
}
let clay = {
    name: &quot;Clay&quot;,
    age: 27
};
//这里充分证明了new绑定实现构造函数对象的优先级大于call或者apply硬绑定
//Person函数的this指向并没有指向clay,还保持着初始值
//而对象clay的属性name和age的值都改变为Person函数this指向的值
//在这里打印:
//Gary
//26
//Gary
//26
Person.call(clay);
console.log(clay.name);
console.log(clay.age);

function Person() {
    console.log(this.name);
    console.log(this.age);
}
let clay = {
    name: &quot;Clay&quot;,
    age: 27
};
//这里Person函数的this指向clay
//而对象clay的属性name和age的值还是保持着初始值
//在这里打印:
//Clay
//27
//Clay
//27
Person.call(clay);
console.log(clay.name);
console.log(clay.age);
</code></pre><blockquote>
<p>从上面的例子,我们可以得出this的绑定优先级: new绑定 &gt; apply、call和bind硬绑定 &gt; 普通对象软绑定 &gt; 默认绑定,当this对象上面的属性进行定义声明,再使用apply、call或者bind硬绑定时,new绑定this对象上面的属性的优先级就大于apply、call或者bind硬绑定对象上面的属性的优先级,这时候显示的就是this对象上面的属性值,当this对象上面的属性没有进行定义声明,这时候apply、call或者bind硬绑定对象上面的属性的优先级就是最大的,这时候显示的就是硬绑定对象上面的属性的属性值</p>
</blockquote>
]]></content>
      <categories>
        <category>Html or Css Or Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Html</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-05-06 封装的一些小工具</title>
    <url>/2018/05/06/%E5%B0%81%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="debounce函数节流"><a href="#debounce函数节流" class="headerlink" title="debounce函数节流"></a>debounce函数节流</h1><blockquote>
<p>函数节流通常被用于输入下拉框、滚动懒加载等场景,目的只有一个,在短时间内,限制多次调用后台接口,浪费大量资源,防止接口响应数据时间上的误差造成的页面显示数据的错误。</p>
</blockquote>
<pre><code>//设置一个timer变量,用来承接setTimeout返回的延时对象
const timer = null;
//函数节流方法
function debounce(fuc, delay) {
    //每一次进行输入或者拉动滚动条的时候,都会对延时对象进行判断,假如存在延时对象,就停止延时对象,并把延时对象置为空,释放内存,使得垃圾回收机制能更快的对延时对象进行回收
    if(timer) {
        clearTimeout(timer);
        timer = null;
    }
    //给延时对象赋予一个延时方法,fuc就是请求后台接口的函数,delay就是延时时间
    timer = setTimeout(fuc, delay);
}
//函数节流方法,只要在delay时间内,再次触发此方法,延时对象就会被停止且置空,后台的接口函数就不会被调用。
//做到了在短时间内输入或者滚动限制了多次调用后台接口,防止了接口响应数据时间上的误差造成页面数据显示的错误。
</code></pre><h1 id="bind函数绑定"><a href="#bind函数绑定" class="headerlink" title="bind函数绑定"></a>bind函数绑定</h1><blockquote>
<p>bind绑定是一种硬绑定,和apply函数、call函数一样的作用,且更加简便,其作用也是为了改变函数或者”类”函数this的指向,大多数浏览器都是已经实现了内置bind方法,我们今天来模拟一下bind方法的实现</p>
</blockquote>
<pre><code>if(Function.prototype.bind === undefined) {
    Function.prototype.bind = function(context) {
        //首先判断调用bind方法的是否是函数类型
        //假如不是函数类型,直接抛出错误异常
        if(typeof this !== &quot;function&quot;) {
            throw new Error(&quot;bind函数必须应用在函数上面&quot;);
        }
        //获取arguments参数,除了要绑定的对象第一个参数之外的所有的参数,并生成数组
        let args = Array.prototype.slice.call(arguments, 1),
            self = this,
            fBind;
        function F() {}
        //在闭包中进行硬绑定,假如闭包不作为new绑定的函数对象使用,则其中的this指向window,假如作为new绑定的函数对象使用,则其中的this指向闭包函数对象
        fBind = function () {
            let args_fBind = Array.prototype.slice.call(arguments);
            return self.apply(this instanceof fBind ? this : context, args.concat(args_fBind));
        }
        //假如闭包作为new绑定的函数对象使用,就要继承bind绑定函数对象的显式原型
        //即闭包函数对象的隐式原型指向其bind绑定函数对象的显式原型
        F.prototype = self.prototype;
        fBind.prototype = new F();
        fBind.constructor = fBind;
        return fBind;
    }
}

window.name = &quot;Gary&quot;;
function Person(age) {
    console.log(this.name);
    this.age = age;
    console.log(this.age);
}
//此时this默认绑定在window上面
//在这里打印:
//Gary
//24
Person(24);
let clay = {
    name: &quot;Clay&quot;
};
//此时进行硬绑定,this指向clay对象
//而闭包函数对象中的this则指向window
//在这里打印:
//Clay
//25
let me = Person.bind(clay);
me(25);
Person.prototype.introduce = function () {
    console.log(`name: ${this.name}, age: ${this.age}`);
};
//此时进行硬绑定,this本指向clay对象
//但是闭包函数对象却进行了new绑定构造函数操作,使得this指向闭包函数本身
//闭包函数本身并不存在name对象,所以打印this.name为undefined,无定义的
//在这里打印:
//undefined
//26
//undefined
//26
//name: undefined, age: 26
let me_bind = Person.bind(clay);
let Clay = new me_bind(26);
console.log(Clay.name);
console.log(Clay.age);
Clay.introduce();
</code></pre><h1 id="new绑定实现构造函数对象"><a href="#new绑定实现构造函数对象" class="headerlink" title="new绑定实现构造函数对象"></a>new绑定实现构造函数对象</h1><blockquote>
<p>Javascript中存在一种特定的设计模式:原型设计模式,每一个对象都具有一个隐式原型,每一个函数对象都具有一个显式原型,通过new绑定实现构造函数对象返回的引用对象进行串联,也就是说每一个引用对象的隐式原型指向其构造函数的显式原型,所有的对象都是通过一个空对象复制出来的,也就是Object.prototype,现在我们模拟模拟一下new绑定实现构造函数对象</p>
</blockquote>
<pre><code>function ObjectNew() {
    let obj_prototype = {},
        Constructor = Array.prototype.slice.call(arguments, 0, 1)[0];
    obj_prototype.__proto__ = Constructor.prototype;
    let res = Constructor.apply(obj_prototype, Array.prototype.slice.call(arguments, 1));
    return typeof res === &quot;object&quot; ? res : obj_prototype;  
}

function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function () {
    console.log(`name: ${this.name}, age: ${this.age}`);
};
//这里和new绑定实现构造函数对象的效果一模一样
//在这里打印:
//Gary
//26
//name: Gary, age: 26
let gary = ObjectNew(Person, &apos;Gary&apos;, 26);
console.log(gary.name);
console.log(gary.age);
gary.introduce();
</code></pre><h1 id="getElementsByClassName封装"><a href="#getElementsByClassName封装" class="headerlink" title="getElementsByClassName封装"></a>getElementsByClassName封装</h1><blockquote>
<p>getElementsByClassName是HTML5 DOM引入的一个获取class样式节点的方法,有一些不支持HTML5 DOM的浏览器可能不存在这个方法,所以需要对这个方法进行封装</p>
</blockquote>
<pre><code>//html code
&lt;!Doctype html&gt;
&lt;html lang=&quot;zh-cn&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;getElemetnsByClassName封装&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;home&quot;&gt;
            &lt;p class=&quot;number&quot;&gt;first&lt;/p&gt;
            &lt;p class=&quot;number second&quot;&gt;second&lt;/p&gt;
            &lt;p class=&quot;number&quot;&gt;third&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;boxesByClassName.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;

//boxesByClassName.js
function getElementsByClassName(node, className) {
    //判断DOM是否有getElementsByClassName方法,假如有,就返回node节点下的所有className子节点
    if(node.getElementsByClassName) {
        return node.getElementsByClassName(className);
    } else {
    //假如没有,就先去获取node节点下的所有子节点元素,然后根据子节点元素的className属性进行匹配外部传入的className,假如包含此className,就传入返回的数组中,最后返回数组
        let _get_className_arr = [],
            _tag_arr = node.getElementsByTagName(&quot;*&quot;),
            _tag_arr_length = _tag_arr.length;
        for(let i = 0; i &lt; _tag_arr_length; i++) {
            if(_tag_arr[i].className.includes(className)){
                _get_className_arr[_get_className_arr.length] = _tag_arr[i];
            }
        }
        return _get_className_arr;
    }
}
</code></pre><h1 id="addEvent加载完成事件封装"><a href="#addEvent加载完成事件封装" class="headerlink" title="addEvent加载完成事件封装"></a>addEvent加载完成事件封装</h1><blockquote>
<p>对于window.onload事件,再熟悉不过了,用于在页面DOM全部加载完毕之后执行Javascript,防止在页面DOM渲染过程中对DOM进行操作,使得页面卡顿,降低用户体验。window.onload的挂载一个或者多个的方式于实际情况而定,所以需要对window.onlaod加载完成事件进行封装</p>
</blockquote>
<pre><code>function addEvent(eventLoad) {
    //将window.onload事件函数赋值给一个变量
    let load = window.onload;
    //判断window.onload加载完成事件上面,是否挂载了事件函数
    //假如挂载了事件函数,就将新的事件函数添加到window.onload加载完成事件队列中
    //假如没有挂载事件函数,就直接将新的事件函数挂载上去
    if (typeof load !== &quot;function&quot;) {
        window.onload = eventLoad;
    } else {
        window.onload = function() {
            load();
            eventLoad();           
        }
    }
}
</code></pre><h1 id="insertAfter插入到某个元素节点之后封装"><a href="#insertAfter插入到某个元素节点之后封装" class="headerlink" title="insertAfter插入到某个元素节点之后封装"></a>insertAfter插入到某个元素节点之后封装</h1><blockquote>
<p>parentNode.insertBefore(newElement, targetElement),insertBefore方法是在某一个元素节点之前插入新的元素节点,而DOM-Core并没有提供insertAfter方法,旨在在某一个元素节点之后插入新的元素节点,于是进行insertAfter封装</p>
</blockquote>
<pre><code>function insertAfter(newElement, targetElement) {
    //获取目标节点的父节点
    let parent = targetElement.parentNode;
    //判断父节点的最后一个子节点是否是目标节点,假如是,就直接将新的元素节点,添加到父节点下
    //假如不是,就将新的元素节点插入到目标节点兄弟节点之前
    if(parent.lastChild == targetElement) {
        parent.appendChild(newElement);
    } else {
        parent.insertBefore(newElement, targetElement.nextSibling);
    }
}
</code></pre><h1 id="isEmpty判断对象是否为空的封装"><a href="#isEmpty判断对象是否为空的封装" class="headerlink" title="isEmpty判断对象是否为空的封装"></a>isEmpty判断对象是否为空的封装</h1><blockquote>
<p>Javascript的对象判断是否为空,并没有原生的方法,所以需要封装一下,成为自己的库</p>
</blockquote>
<pre><code>function isEmpty(obj) {
    //判断对象是否为空的标识符,默认为true,判断对象为空
    let flag = true;
    //使用ES6遍历对象,假如对象中有遍历的对象属性,就说明对象不为空,设置flag为false,判断对象不为空
    for(let [key, value] of Object.entries(obj)) {
        if(obj.hasOwnProperty(key)) {
            flag = false;
            break;
        }
    }
    return flag;
}
</code></pre><h1 id="getNextElementSibling获取元素节点的下一个兄弟元素节点"><a href="#getNextElementSibling获取元素节点的下一个兄弟元素节点" class="headerlink" title="getNextElementSibling获取元素节点的下一个兄弟元素节点"></a>getNextElementSibling获取元素节点的下一个兄弟元素节点</h1><blockquote>
<p>node.nextSibling是获取某一个元素节点的下一个兄弟节点,但是节点类型可能是元素、属性以及文本,是不确定的,而通常,我们希望获取下一个兄弟节点的时候为元素节点,所以需要对获取元素节点的下一个兄弟元素节点进行封装</p>
</blockquote>
<pre><code>function getNextElementSibling(node) {
    //判断元素节点是否有下一个兄弟节点,如果没有返回false
    if(!node.nextSibling) return false;
    //获取元素节点的下一个兄弟节点
    let nextSibling = node.nextSibling;
    //假如元素节点的下一个兄弟节点的节点类型为1,也就是元素节点,就返回元素节点的下一个兄弟节点
    if(nextSibling.nodeType === 1) {
        return nextSibling;
    }
    //假如元素节点的下一个兄弟节点的节点类型为除了1以外的其他数字,就再次递归元素节点的下一个兄弟节点,直到找到下一个兄弟元素节点位置
    return getNextElementSibling(nextSibling);   
}
</code></pre><h1 id="moveElement动态的元素节点"><a href="#moveElement动态的元素节点" class="headerlink" title="moveElement动态的元素节点"></a>moveElement动态的元素节点</h1><blockquote>
<p>通过原生的Javascript来生成动画,是解决CSS3不兼容低版本浏览器的最好的平稳退化方案,利用setTimeout生成的通用动画效果的函数方法在此</p>
</blockquote>
<pre><code>//设置一个承接时间对象的变量
let timer = null;
//函数传递四个参数,要产生移动的元素节点,将要移动到的x轴位置,将要移动到的y轴位置,以及移动元素节点的时间(单位: 毫秒)
function moveElement(node, x, y, speed) {
    //首先校验是否存在移动元素的节点,假如不存在,直接返回false,退出函数
    if(!document.getElementById(node)) return false;
    let elem = document.getElementById(node);
    //然后判断是否有时间对象,假如有的话,直接清理掉,并把时间对象置为空,以便浏览器垃圾回收机制更快的回收内存中的不需要的数据
    if(timer) {
        clearTimeout(timer);
        timer = null;
    }
    //判断移动元素节点样式的top和left属性是否存在,如果不存在,初始化top和left的属性为0px
    if(!elem.style.top) {
        elem.style.top = &quot;0px&quot;;
    }
    if(!elem.style.left) {
        elem.style.left = &quot;0px&quot;;
    }
    //获取移动元素节点样式的top和left属性值,并转化为绝对值的数值类型
    let xpo = Math.abs(parseInt(elem.style.left)),
        ypo = Math.abs(parseInt(elem.style.top));
    //假如移动元素节点样式的left的绝对值与要移动到的x轴位置相等,且移动元素节点样式的top的绝对值与要移动到的y轴位置相等,则返回true,退出递归函数
    if(xpo === x &amp;&amp; ypo === y) {
        return true
    }
    let dist;
    //假如移动元素节点样式的left的绝对值小于要移动到的x轴位置,就将移动元素节点样式的left的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果
    if(xpo &lt; x) {
        dist = Math.ceil((x - xpo) / 10);
        xpo += dist;
    }
    //假如移动元素节点样式的left的绝对值大于要移动到的x轴位置...
    if(xpo &gt; x) {
        dist = Math.ceil((xpo - x) / 10);
        xpo -= dist;
    }
    //假如移动元素节点样式的top的绝对值小于要移动到的y轴位置,就将移动元素节点样式的top的绝对值赋值为它俩的差的十分之一的向上取整数值,这样的目的是为了实现越接近目标位置速度越慢的动态效果
    if(ypo &lt; y) {
        dist = Math.ceil((y - ypo) / 10);
        ypo += dist;
    }
    //假如移动元素节点样式的top的绝对值大于要移动到的y轴位置...
    if(ypo &gt; y) {
        dist = Math.ceil((ypo - y) / 10);
        ypo -= dist;
    }
    //将移动元素节点样式的top和left的绝对值取反,赋值重新赋值给移动元素节点样式
    elem.style.left = `${-xpo}px`;
    elem.style.top = `${-ypo}px`;
    //未到目标位置,设置时间处理函数继续递归动态的元素节点函数,并把时间对象赋值给timer变量
    timer = setTimeout(function timer() {
        moveElement(node, x, y, speed);
    }, speed);
}
</code></pre><h1 id="getGreyGeneral根据图片利用canvas制作灰度图"><a href="#getGreyGeneral根据图片利用canvas制作灰度图" class="headerlink" title="getGreyGeneral根据图片利用canvas制作灰度图"></a>getGreyGeneral根据图片利用canvas制作灰度图</h1><blockquote>
<p>利用canvas画布可以制作各种各样的图片以及动画效果,包括二维、三维等图片和动画,灰度图就是二维图片中一个比较难处理的例子,由此对其进行封装</p>
</blockquote>
<pre><code>function getGreyGeneral(img) {
    //假如Modernizr检测兼容的全局对象中查找不到canvas属性,就返回false,退出函数
    if(!Modernizr.canvas) return false;
    //假如document对象中不存在createElement方法,也返回false,退出函数
    if(!document.createElement) return false;
    //创建一个canvas元素节点对象
    let canvas = document.createElement(&quot;canvas&quot;);
    //设置canvas元素节点对象的宽和高为图片的宽和高
    canvas.width = img.width;
    canvas.height = img.height;
    //获取canvas二维画布绘图环境
    let ctx = canvas.getContext(&quot;2d&quot;);
    //在二维画布绘图环境上面,根据图片DOM对象进行绘制,从图片DOM对象坐标的(0, 0)位置开始绘制
    ctx.drawImage(img, 0, 0);
    //获取到二维绘图环境的图片数据,从坐标(0, 0)位置开始,到图片的(img.width, img.height)宽度和高度位置截止
    let c = ctx.getImageData(0, 0, img.width, img.height);
    //对图片数据进行灰度处理,获取到每个像素的rgb值,每四个像素(最后一个像素永远是255)数据一组,求rgb的平均值,并重新赋值给rgb 
    for(let i = 0;i &lt; c.height;i ++) {
        for(let j = 0;j &lt; c.width;j ++) {
            let x = i * 4 * c.height + j * 4,
                data = c.data,
                r = data[x],
                g = data[x + 1],
                b = data[x + 2];
            data[x] = data[x + 1] = data[x + 2] = (r + g + b) / 3;
        }
    }
    //将灰度处理好的二维绘图环境图片数据,重新赋予到原来的二维绘图环境上面,且设置二维绘图环境的偏移位置(0, 0),以及绘图处理渲染的偏移位置(0, 0),最后设置二维绘图环境图片数据的宽度和高度
    ctx.putImageData(c, 0, 0, 0, 0, img.width, img.height);
    //返回canvas生成的图片数据URL
    return canvas.toDataURL();
}
</code></pre><h1 id="setVideoControl配置video视频播放器的默认播放和暂停按键"><a href="#setVideoControl配置video视频播放器的默认播放和暂停按键" class="headerlink" title="setVideoControl配置video视频播放器的默认播放和暂停按键"></a>setVideoControl配置video视频播放器的默认播放和暂停按键</h1><blockquote>
<p>HTML5中新加了video和audio标签,以前都是使用object和embed标签来插入视频和音频插件,有好多繁琐的配置,现在有了video和audio标签使得我们在编写视频和音频代码时,方便快捷了很多,下面是对video播放和暂停键重置的封装</p>
</blockquote>
<pre><code>function setVideoControl(video) {
    //首先先将video视频元素节点的controls属性删掉,这样controls一系列默认的播放、暂停键以及滑动条等配置就被剔除掉了
    video.removeAttribute(&quot;controls&quot;);
    //设置video视频元素节点的宽度和高度,分别为视频的实际宽度和高度
    video.width = video.videoWidth;
    video.height = video.videoHeight;
    //设置video视频元素节点的宽度和高度,分别也为视频的实际宽度和高度
    video.parentNode.width = video.videoWidth;
    video.parentNode.height = video.videoHeight;
    //创建一个承接播放/暂停按钮的div容器,再创建一个播放/暂停按钮
    let play = document.createElement(&quot;div&quot;),
        button = document.createElement(&quot;button&quot;);
    //设置div容器的title标题属性默认为&quot;Play&quot;
    play.setAttribute(&quot;title&quot;, &quot;Play&quot;);
    //设置播放/暂停按钮默认的文本节点为&amp;#x25BA;(播放按钮)
    button.innerHTML = &quot;&amp;#x25BA;&quot;;
    //将播放/暂停按钮放入到div容器中
    play.appendChild(button);
    //并将承接播放/暂停按钮的div容器插入到video视频元素节点之前
    video.parentNode.insertBefore(play, video);
    //设置承接播放/暂停按钮的div容器点击事件: 
    //假如video视频元素节点的暂停属性为true,则执行video视频元素节点的play播放方法
    //否则执行vedio视频元素节点的pause暂停方法
    play.onclick = function (e){
        if(video.paused) {
            video.play();
        } else {
            video.pause();
        }
    };
    //设置video视频元素节点的play播放方法,将承载播放/暂停按钮的div容器title标题属性设置为Pause,并设置播放/暂停按钮的文本节点设置为&amp;#x2590;&amp;#x2590;(暂停按钮)
    video.addEventListener(&quot;play&quot;, function (e) {
        button.innerHTML = &quot;&amp;#x2590;&amp;#x2590;&quot;;
        play.setAttribute(&quot;title&quot;, &quot;Pause&quot;);
    });
    //设置video视频元素节点的pause暂停方法,将承载播放/暂停按钮的div容器title标题属性设置为Play,并设置播放/暂停按钮的文本节点设置为&amp;#x25BA;;(播放按钮)
    video.addEventListener(&quot;pause&quot;, function (e) {
        button.innerHTML = &quot;&amp;#x25BA&quot;;
        play.setAttribute(&quot;title&quot;, &quot;Play&quot;);
    });
    //设置video视频元素节点的ended视频结束方法,将video视频元素节点的currentTime属性(当前滑动条进度)设置为:起始位置,并执行video视频元素节点pause暂停方法
    video.addEventListener(&quot;ended&quot;, function (e) {
        video.currentTime = 0;
        video.pause();
    });
}
</code></pre><h1 id="Symbol-iterator迭代对象"><a href="#Symbol-iterator迭代对象" class="headerlink" title="Symbol.iterator迭代对象"></a>Symbol.iterator迭代对象</h1><blockquote>
<p>说起Symbol.iterator,就会想到ES6新引进的迭代器,像Array.keys(),Array.values(),Array.entries(),都是Symbol.iterator迭代对象实现的,每一次迭代(.next())都会返回一个对象: {value: 迭代的值, done: 迭代的状态},当迭代结束,就会返回{value: undefined, done: true},但是这个迭代对象只存在于数组、Object对象以及Generator等迭代器里,要想迭代对象,需要手动去添加它的Symbol.iterator方法</p>
</blockquote>
<pre><code>let yinwk = {
    name: &quot;Gary&quot;,
    age: 25,
    hobby: [&quot;basketball&quot;, &quot;tennis&quot;],
    [Symbol.iterator]() {
        //首先将this对象赋值给一个变量
        let that = this,
            //然后获取this对象指向的本对象的属性数组
            that_key = Object.keys(that),
            //接着获取本对象的属性数组的长度
            len = that_key.length,
            //最后定义一个递增变量,用来遍历本对象的属性值
            index = 0;
        //返回一个对象,对象中有一个next函数方法,在其中判断递增变量index是否大于属性数组的长度,
        //假如不大于,说明没有迭代完成,则返回{value: 属性值(that[that_key[index++]]), done: false}
        //假如大于,说明迭代完成,则返回{value: 属性值(that[that_key[index++]]), done: true}     
        return {
            next() {
                if(index &gt; len){
                    return {
                        value: that[that_key[index++]],
                        done: true
                    }
                } else {
                    return {
                        value: that[that_key[index++]],
                        done: false
                    }
                }
            }
        }
    }
};
//对添加好迭代对象的对象进行遍历
//这里打印:
// &quot;Gary&quot;
// 25
// [&quot;basketball&quot;, &quot;tennis&quot;]
for(let value of yinwk) {
    console.log(value);
}
</code></pre><h1 id="闭包实现缓存机制"><a href="#闭包实现缓存机制" class="headerlink" title="闭包实现缓存机制"></a>闭包实现缓存机制</h1><blockquote>
<p>有时一些函数内的重复循环、判断甚至是普通的同步定义赋值,对于浏览器来说或大或小都是损耗,现在我们使用闭包对重复的操作缓存起来,减少重复的操作和损耗,提高浏览器的性能</p>
</blockquote>
<pre><code>function cache() {
    //进行存储的对象
    let res_obj = {};

    //进行运算的操作函数
    function operation() {
        let a = 1;
        for(let i = 0; i &lt; arguments.length; i++) {
            a *= arguments[i];
        }
        return a;
    }

    return function() {
        let args = Array.prototype.join.call(arguments, &quot;_&quot;);
        if(res_obj[args]) {
            return res_obj[args];
        }
        console.log(&quot;first cache~&quot;);
        return res_obj[args] = operation.apply(this, arguments);
    }
}

let cache_control = cache();
//在这里打印:
//first cache~
let cache_result = cache_control(3, 4, 5);
//在这里打印:
//60
console.log(cache_result);
//在这里打印:
//60
console.log(cache_control(3, 4, 5));
</code></pre><h1 id="使用命令模式实现模拟的开关Tv的功能"><a href="#使用命令模式实现模拟的开关Tv的功能" class="headerlink" title="使用命令模式实现模拟的开关Tv的功能"></a>使用命令模式实现模拟的开关Tv的功能</h1><blockquote>
<p>将开关Tv对象封装至函数内部,以构造函数的引用对象或者闭包函数的方式导出,调用新的函数方法控制模拟开关Tv,首先以构造函数的引用对象方式导出</p>
</blockquote>
<pre><code>let Tv = {
    open() {
        console.log(&quot;open the Tv&quot;);
    },
    close() {
        console.log(&quot;close the Tv&quot;);
    }
};

//以构造函数的引用对象方式导出
function CommandInOrder(command) {
   this.command = command;
}

//原型链函数方法: 打开Tv
CommandInOrder.prototype.openTheTv = function() {
    this.command.open();
};

//原型链函数方法: 关闭Tv
CommandInOrder.prototype.closeTheTv = function() {
    this.command.close();
};

function CommandInOrderOutput(command) {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        command.openTheTv();
        //取消冒泡
        e.stopImmediatePropagation();
    };

    document.getElementById(&quot;close&quot;).onclick = function(e) {
        command.closeTheTv();
        //取消冒泡
        e.stopImmediatePropagation();
    }
}

//点击id为open的元素
//在这里打印:
//open the Tv
//点击id为close的元素
//在这里打印:
//close the Tv
CommandInOrderOutput(new CommandInOrder(Tv));
</code></pre><blockquote>
<p>接着是以闭包的方式导出   </p>
</blockquote>
<pre><code>let Tv = {
    open() {
        console.log(&quot;open the Tv&quot;);
    },
    close() {
        console.log(&quot;close the Tv&quot;);
    }
};

//以闭包的方式导出
function CommandInOrder(command) {
    function openTheTv() {
        command.open();
    }
    function closeTheTv() {
        command.close();
    }
    return {
        openTheTv,
        closeTheTv
    }
}

function CommandInOrderOutput(command) {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        command.openTheTv();
        //取消冒泡
        e.stopImmediatePropagation();
    };
    document.getElementById(&quot;close&quot;).onclick = function(e) {
        command.closeTheTv();
        //取消冒泡
        e.stopImmediatePropagation();
    };
}

//点击id为open的元素
//在这里打印:
//open the Tv
//点击id为close的元素
//在这里打印:
//close the Tv
CommandInOrderOutput(CommandInOrder(Tv));
</code></pre><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><blockquote>
<p>回调高阶函数事例: xhr请求回调高阶函数</p>
</blockquote>
<pre><code>//xhr请求回调高阶函数
function xhr_request(callback) {
    let xhr = new XMLHttpRequest();
    xhr.open(&quot;GET&quot;, &quot;../data/code.json&quot;);
    xhr.onreadystatechange = function () {
        callback.apply(xhr, arguments);
    };
    xhr.send(null);
}

//在这里打印:
//{code: &quot;000000&quot;}
xhr_request(function (e) {
    if(this.readyState === 4) {
        if(this.status === 200) {
            console.log(JSON.parse(this.responseText));
        }
    }
    //取消冒泡
    e.stopImmediatePropagation();
});
</code></pre><blockquote>
<p>回调函数高阶函数事例: 创建DOM节点回调高阶函数</p>
</blockquote>
<pre><code>//创建DOM节点回调高阶函数
function createDOMNode(callback) {
    for(let i = 0; i &lt; 10; i++) {
        let div = document.createElement(&quot;div&quot;);
        callback.call(div, i);
        document.body.appendChild(div);
    }
}

createDOMNode(function (number) {
    let text = document.createTextNode(number);
    this.appendChild(text);
});
</code></pre><blockquote>
<p>闭包高阶函数: 单例模式</p>
</blockquote>
<pre><code>//单例函数
function getSingle(func) {
    let res;
    return function() {
        return res || (res = func.apply(this, arguments));
    }
}

let Single = getSingle(function () {
    return document.createElement(&quot;script&quot;);
});

let single_one = Single();
let single_two = Single();
//在这里打印:
//true
console.log(single_one === single_two);
</code></pre><blockquote>
<p>闭包高阶函数: AOP装饰者模式</p>
</blockquote>
<pre><code>/**
 * 在某个函数之前执行
 */
Function.prototype.before = function(before) {
    let self = this;
    return function() {
        before.apply(this, arguments);
        return self.apply(this, arguments);
    }
};

/**
 * 在某个函数之后执行
 */
Function.prototype.after = function(after) {
    let self = this;
    return function() {
        let res_func = self.apply(this, arguments);
        after.apply(this, arguments);
        return res_func;
    }  
};

function mid() {
    console.log(&quot;this is middle~&quot;);
}

//AOP装饰者模式完成并执行
let res = mid.before(function() {
    console.log(&quot;this is before~&quot;);
}).after(function() {
    console.log(&quot;this is after~&quot;);
});

//在这里打印:
//this is before~
//this is middle~
//this is after~
res();
</code></pre><h1 id="高阶函数实用"><a href="#高阶函数实用" class="headerlink" title="高阶函数实用"></a>高阶函数实用</h1><blockquote>
<p>curry化,柯里化高阶函数</p>
</blockquote>
<pre><code>/**
 * 柯里化高阶函数
 */
function Currying() {
    let res_arr = [];
    function curry_result() {
        let m = 0;
        for(let i = 0; i &lt; arguments.length; i++) {
            m += arguments[i];
        }
        return m;
    }
    return function() {
        if(arguments.length &gt; 0) {
            let args = Array.prototype.slice.call(arguments, 0);
            res_arr = [...res_arr, ...args];
        } else {
            return curry_result.apply(this, ...res_arr);
        }
    }
}

let currying_res = Currying();
currying_res(300);
currying_res(255);
currying_res(244);
currying_res(344);
currying_res(88);
//在这里打印:
//1231
console.log(currying_res());
</code></pre><blockquote>
<p>uncurry化,非柯里化高阶函数,直接将原型函数方法外用</p>
</blockquote>
<pre><code>/**
 * 非柯里化高阶函数
 */
Function.prototype.uncurrying = function() {
    let self = this;
    return function() {
        let obj = Array.prototype.slice.call(arguments, 0, 1)[0],
            args = Array.prototype.slice.call(arguments, 1);
        return self.apply(obj, args);    
    }
};

let push = Array.prototype.push.uncurrying();
//在这里打印:
//[1, 2, 3, 4]
(function() {
    push(arguments, 4);
    console.log(arguments);
})(1, 2, 3);

let obj = {
    length: 3,
    0: 1,
    1: 2,
    2: 3
};
push(obj, &quot;4&quot;);
//在这里打印:
//{0: 1, 1: 2, 2: 3, 3: &quot;4&quot;}
console.log(obj);
</code></pre><blockquote>
<p>uncurry化拓展,非柯里化高阶函数</p>
</blockquote>
<pre><code>/**
 * 非柯里化高阶函数
 */
Function.prototype.uncurrying = function() {
    let self = this;
    return function() {
        let obj = Array.prototype.slice.call(arguments, 0, 1)[0],
            args = Array.prototype.slice.call(arguments, 1);
        return self.apply(obj, args);    
    }
};

let method_arr = [&quot;push&quot;, &quot;shift&quot;, &quot;forEach&quot;];
for(let i = 0; i &lt; method_arr.length; i ++) {
    Array[method_arr[i]] = Array.prototype[method_arr[i]].uncurrying();
}
let obj = {
    length: 3,
    0: 1,
    1: 2,
    2: 3
};
Array.push(obj, &quot;44&quot;);
//在这里打印:
//{0: 1, 1: 2, 2: 3, 3: &quot;44&quot;, length: 4}
console.log(obj);
Array.shift(obj);
//在这里打印:
//{0: 2, 1: 3, 2: &quot;44&quot;, length: 3}
console.log(obj);
//在这里打印:
//2
//3
//&quot;44&quot;
Array.forEach(obj, function(item, index){
    console.log(item);
});
</code></pre><blockquote>
<p>uncurry化拓展call与apply,非柯里化高阶函数</p>
</blockquote>
<pre><code>/**
 * 非柯里化高阶函数
 */
Function.prototype.uncurrying = function() {
    let self = this;
    return function() {
        let obj = Array.prototype.slice.call(arguments, 0, 1)[0],
            args = Array.prototype.slice.call(arguments, 1);
        return self.apply(obj, args);    
    }
};

let call = Function.prototype.call.uncurrying();
let name = &quot;Gary&quot;;
window.name = &quot;Clay&quot;;
function introduce() {
    console.log(name);
    console.log(this.name);
}
//在这里打印:
//&quot;Gary&quot;
//&quot;Clay&quot;
call(introduce, window);

let apply = Function.prototype.apply.uncurrying();
function Gary_myself() {
    console.log(arguments);
    console.log(this.name);
}
//在这里打印:
//[&quot;simon&quot;]
//&quot;wenkai yin&quot;
apply(Gary_myself, {name: &quot;wenkai yin&quot;}, [&quot;simon&quot;]);
</code></pre><blockquote>
<p>函数节流高阶函数,我们在前面整理过函数节流,只是这次的函数节流与上次不同,这次在延时的时间内不能再执行调用方法的操作,只有等到延时处理器执行完才停止延时处理器,而上次无论是是否是在延时的时间内,只要再次执行调用方法的操作,就直接停止延时处理器</p>
</blockquote>
<pre><code>/**
 * 函数节流
 */
function throttle(func, speed) {
    let first_time = true,
        timer;
    return function() {
        let self = this,
            args = arguments;
        if(first_time) {
            func.apply(self, args);
            first_time = false;
        }

        if(timer) {
            return false;
        }

        timer = setTimeout(function time() {
            clearTimeout(timer);
            timer = null;
            func.apply(self, args);   
        }, speed);
    }
}

//在这里打印:
//Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}
//Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …}
//800
window.onresize = throttle(function(e) {
    console.log(this);
    console.log(e);
    console.log(800);
}, 800);
</code></pre><blockquote>
<p>分时高阶函数,有时为了防止大量的DOM操作,比如一次性创建几万个DOM节点,一起添加到页面上,使得浏览器卡顿甚至是卡down,分时函数就是解决这个问题的比较不错的方法,将这几万个DOM节点,分为很多份,在一定的时间内,只去处理一份内的节点数据,添加到页面上,这样比较大的优化了浏览器的性能</p>
</blockquote>
<pre><code>/**
 * 分时函数
 */
function timeShare(share_arr, func, count) {
    let timer,
        inner_arr = share_arr;
    function resolve_res() {
        for(let i = 1; i &lt;= Math.min(count || 1, inner_arr.length); i ++) {
            let inner_shift = inner_arr.shift();
            func.call(this, inner_shift);
        }
    }
    return function() {
        let self = this,
            args = arguments;
        timer = setInterval(function time() {
            if(inner_arr.length &lt;= 0) {
                clearInterval(timer);
                timer = null;
            }
            resolve_res.apply(self, args);
        }, 100);
    }
}

let share_arr = Array.from(Array.apply(null, {length: 1000}), function map(item, index) {
    return index + 1;
});
timeShare(share_arr, function(i) {
    let div = document.createElement(&quot;div&quot;),
        text = document.createTextNode(i);
    div.appendChild(text);
    document.body.appendChild(div);    
}, 8);
</code></pre><blockquote>
<p>惰性加载高阶函数</p>
</blockquote>
<pre><code>/**
 * 普通惰性加载函数,调用时,每一次都要去判断哪种事件方式浏览器可用,这样虽对于性能没有什么大影响,但是还是很不优雅的
 */
function addEvent(elem, type, func) {
    if(window.addEventListener) {
        elem.addEventListener(type, function() {
            func.apply(this, arguments);
        });
    }
    if(window.attachEvent) {
        elem.attachEvent(`on${type}`, function() {
            func.apply(this, arguments);
        });
    }
}
addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) {
    console.log(e.target);
});

/**
 * 这样省去了在调用时的判断哪种事件方式浏览器可用,换成了在浏览器加载时判断,只判断一次,这样在调用时就可以直接使用判断后的事件方式了,但是假如页面没有使用到事件,还是进行了判断哪种事件方式浏览器可用,这样浪费了浏览器的性能,还是不能这样做的
 */
let addEvent = (function (){
    if(window.addEventListener) {
        return function(elem, type, func) {
            elem.addEventListener(type, function() {
                func.apply(this, arguments);
            });
        }
    }
    if(window.attachEvent) {
        return function(elem, type, func) {
            elem.attachEvent(`on${type}`, function() {
                func.apply(this, arguments);
            });
        }
    }
})();
addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) {
    console.log(e.target);
});

/**
 * 这样只有在第一次调用addEvent函数方法的时候,才回去判断哪种事件方式浏览器可用,在第一次调用之后,就直接将判断后的那种事件方式以另外一种函数方法的方式赋值给addEvent变量,然后再继续执行调用addEvent函数方法,再一次调用时,就不需要判断哪种方式浏览器可用了,直接调用第一次判断过后赋值给addEvent变量的函数方法即可,这就是惰性加载函数
 */
let addEvent = function(elem, type, func) {
    let args = Array.prototype.slice.call(arguments);
    if(window.addEventListener) {
        addEvent = function(elem, type, func) {
            elem.addEventListener(type, function() {
                func.apply(this, arguments);
            });
        }
    }
    if(window.attachEvent) {
        addEvent = function(elem, type, func) {
            elem.attachEvent(`on${type}`, function() {
                func.apply(this, arguments);
            });
        }
    }
    addEvent(elem, type, func);
};
addEvent(document.getElementById(&quot;open&quot;), &quot;click&quot;, function(e) {
    console.log(e.target);
});
</code></pre>]]></content>
      <categories>
        <category>封装的一些小工具</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-05-07 浅谈使用jQuery和react的区别</title>
    <url>/2018/05/07/%E6%B5%85%E8%B0%88%E4%BD%BF%E7%94%A8jQuery%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-05-21 使用Canvas绘制圆角按钮</title>
    <url>/2018/05/21/%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E6%8C%89%E9%92%AE/</url>
    <content><![CDATA[<h1 id="使用Canvas可视化工具绘制圆角按钮"><a href="#使用Canvas可视化工具绘制圆角按钮" class="headerlink" title="使用Canvas可视化工具绘制圆角按钮"></a>使用Canvas可视化工具绘制圆角按钮</h1><blockquote>
<p>最近刚接触了Canvas可视化工具,下面通过一个使用Canvas绘制的圆角按钮的例子,来实践学到的Canvas经验</p>
</blockquote>
<pre><code>//对加载完成事件的封装,在本人写的日志2018-05-06-封装的一些小工具中有详细描述,在这里不再做更多的赘述
let addEvent = (eventLoad) =&gt; {
    let load = window.onload;
    if(typeof load !== &quot;function&quot;) {
        window.onload = eventLoad;
    } else {
        window.onload = function() {
            load();
            eventLoad();
        };
    }
};

//Canvas绘制圆角按钮的函数
let canvasRadiusButton = () =&gt; {
    //假如DOM-Core中不存在getElementById方法,则返回false,退出函数
    if(!document.getElementById) return false;
    //假如DOM-Core中不存在createElement方法,则返回false,退出函数
    if(!document.createElement) return false;
    //假如DOM中不存在id名为home的元素节点,则返回false,退出函数
    if(!document.getElementById(&quot;home&quot;)) return false;
    //获取id名为home的元素节点
    let home = document.getElementById(&quot;home&quot;),
        //创造出canvas元素节点标签
        canvas = document.createElement(&quot;canvas&quot;);
    //设置canvas元素节点标签的宽度和高度都为200px    
    canvas.width = 200;
    canvas.height = 200;
    //设置canvas绘制画布的类型为: 2d(平面画布)
    let ctx = canvas.getContext(&quot;2d&quot;);
    //绘制画布开始绘制路径
    ctx.beginPath();
    //设置绘制画布的起点坐标为: (12, 20)
    ctx.moveTo(12, 20);
    //使用贝塞尔曲线去绘制圆角
    //bezierCurveTo方法有三组坐标参数,前面两组为两个控制点位置,利用这两个控制点可以完美的画出半圆、椭圆甚至是圆角,最后一组为曲线终点的位置
    ctx.bezierCurveTo(12, 16, 15, 14, 19, 14);
    //绘制直线至画布的(129, 14)坐标
    ctx.lineTo(129, 14);
    //继续使用贝塞尔曲线绘制圆角
    ctx.bezierCurveTo(133, 14, 136, 16, 136, 20);
    //绘制直线至画布的(136, 45)坐标
    ctx.lineTo(136, 45);
    //继续使用贝塞尔曲线绘制圆角
    ctx.bezierCurveTo(136, 49, 133, 51, 129, 51);
    //绘制直线至画布的(19, 51)坐标
    ctx.lineTo(19, 51);
    //继续使用贝塞尔曲线绘制圆角
    ctx.bezierCurveTo(15, 51, 12, 49, 12, 45);
    //绘制直线至画布的(12, 20)坐标
    ctx.lineTo(12, 20);
    //绘制画布结束绘制路径
    ctx.closePath();
    //设置画布路径的填充样式为: rgba(255, 255, 0, 0.8)
    ctx.fillStyle = &quot;rgba(255, 255, 0, 0.8)&quot;;
    //进行画布填充
    ctx.fill();
    //设置画布路径的color样式为: rgba(255, 0, 0, 0.5) 
    ctx.strokeStyle = &quot;rgba(255, 0, 0, 0.5)&quot;;
    //画布路径绘制完毕,实现绘制模型
    ctx.stroke();
    //将canvas元素节点添加到home元素节点里面,作为home元素节点的子节点    
    home.appendChild(canvas);
};

addEvent(canvasRadiusButton);
</code></pre>]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-02-03 关于该不该让女伴侣在自己房本上加名字的理解</title>
    <url>/2019/02/03/%E5%85%B3%E4%BA%8E%E8%AF%A5%E4%B8%8D%E8%AF%A5%E8%AE%A9%E4%BC%B4%E4%BE%A3%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%88%BF%E6%9C%AC%E4%B8%8A%E5%8A%A0%E5%90%8D%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="关于该不该让女伴侣在自己房本上加名字的理解"><a href="#关于该不该让女伴侣在自己房本上加名字的理解" class="headerlink" title="关于该不该让女伴侣在自己房本上加名字的理解"></a>关于该不该让女伴侣在自己房本上加名字的理解</h1><p>关于这个问题,我认为男女双方结婚,就是在开一家公司,经营一家公司的业务,开公司,为了公司可以按照双方一致的目标前行,就要有保障弱势、先付出一方的制度在。很明显,在一段婚姻中,是女方先付出,男方后付出,包括女方的青春、生孩子、照顾家庭。而在现有的社会大体制度下,还远远没有形成男女平等的形势,女性还是处于劣势的,所以在婚姻中,女方也自然而然的是劣势的,所以既然男女双方要共同经营一个家庭、一个共同体,需要首先保障劣势和先付出的一方。所以我认为是该让女伴侣在自己房本上加名字的。</p>
]]></content>
      <categories>
        <category>经济学改变世界观</category>
      </categories>
      <tags>
        <tag>经济学</tag>
        <tag>世界观</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-02-03 名言名句</title>
    <url>/2019/02/03/%E5%90%8D%E8%A8%80%E5%90%8D%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>不懂得改变主意的人,什么都改变不了。  —— 温斯顿 丘吉尔</p><br><p>上帝要毁灭一个人,必先使其发狂。  —— 西方谚语</p><br><p>如果你问丘吉尔,为什么要做议员,他一定会说,”因为我要做大臣”;如果你再问丘吉尔,为什么要做大臣,他会斩钉截铁的说,”因为我要做首相”。  ——英国媒体,大概是《泰晤士报》</p>

<h1 id="人生"><a href="#人生" class="headerlink" title="人生"></a>人生</h1><p>人们总是容易记得自己是在一条船上,人们总是容易忘记自己是在一条河上。  ——马东</p><br><p>苟利国家生死以, 岂因祸福避趋之。  ——林则徐</p><br><p>有时候谈理想,在社会上普遍认知是冒傻气,所以我们不要谈理想,而心中有理想,我们需要不谈理想的理想。  ——许子东</p>

<h1 id="文学"><a href="#文学" class="headerlink" title="文学"></a>文学</h1><p>我们正在培养一批绝对的、精致的利己主义者。  ——钱理群</p><br><p>我怕不再有人相信规则能战胜潜规则,我怕不再有人相信学场有别于官场,我怕不再有人相信学术不等于权术,我怕不再有人相信风骨远胜于媚骨。  ——卢新宁</p> 

<h1 id="军事与管理"><a href="#军事与管理" class="headerlink" title="军事与管理"></a>军事与管理</h1><p>孙子兵法要旨: 五事七计</p><br><p>五事: 道天地将法</p><br><p>将: 智信仁勇严</p><br><p>七计: 主孰有道?将孰有能?天地孰得?法令孰行?兵众孰强?士卒孰练?奖罚孰明?</p><br><p>讲究先胜于庙算,后胜于实战,庙算多算胜则胜,多算败则败。而后战,兵者诡道也。</p>
]]></content>
      <categories>
        <category>世界观</category>
      </categories>
      <tags>
        <tag>世界观</tag>
        <tag>历史</tag>
        <tag>军事</tag>
        <tag>经济</tag>
        <tag>文学</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-08-25 Javascript设计模式</title>
    <url>/2018/08/25/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote>
<p>单例模式有两个特点: 全局性和唯一性.全局唯一性是指在全局环境中,只创建对象一次且保证对象在创建过后不被再次创建.下面我们就来演示一下Javascript语言的普通类单例模式和透明单例模式</p>
</blockquote>
<h2 id="普通类单例模式"><a href="#普通类单例模式" class="headerlink" title="普通类单例模式"></a>普通类单例模式</h2><pre><code>function GetSingleton(name) {
    this.name = name;
    this.instance = null;
}

GetSingleton.prototype.getName = function() {
    return this.name;
};

GetSingleton.prototype.Singleton = function(name) {
    return this.instance || (this.instance = new GetSingleton(name));  
};

let gary_one = GetSingleton.prototype.Singleton(&quot;gary_one&quot;);
let gary_two = GetSingleton.prototype.Singleton(&quot;gary_two&quot;);
//在这里打印:
//true
console.log(gary_one === gary_two);
</code></pre><h2 id="普通类单例模式-闭包版本"><a href="#普通类单例模式-闭包版本" class="headerlink" title="普通类单例模式(闭包版本)"></a>普通类单例模式(闭包版本)</h2><pre><code>function GetSingleton(name) {
    this.name = name;
}

GetSingleton.prototype.getName = function() {
    return this.name;
};

let Singleton = (function() {
    let instance;
    return function(name) {
        return instance || (instance = new GetSingleton(name));
    }
})();

let gary_one = Singleton(&quot;gary_one&quot;);
let gary_two = Singleton(&quot;gary_two&quot;);
//在这里打印:
//true
console.log(gary_one === gary_two);
</code></pre><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><pre><code>let GetSingleton = (function() {
    let instance;
    return function(html) {
        if(instance) {
            return instance;
        }
        this.html = html;
        this.init();
        return instance = this;
    }
})();

GetSingleton.prototype.init = function() {
    let div = document.createElement(&quot;div&quot;);
    div.innerHTML = this.html;
    document.body.appendChild(div);
    return div;
};

let gary_one = new GetSingleton(&quot;gary_one&quot;);
let gary_two = new GetSingleton(&quot;gary_two&quot;);
//页面上只有创造了一个DIV DOM节点,内容是&quot;gary_one&quot;
//在这里打印:
//true
console.log(gary_one === gary_two);
</code></pre><h2 id="透明单例模式-代理模式版本"><a href="#透明单例模式-代理模式版本" class="headerlink" title="透明单例模式(代理模式版本)"></a>透明单例模式(代理模式版本)</h2><pre><code>function GetSingleton(html) {
    this.html = html;
    this.init();
}

GetSingleton.prototype.init = function() {
    let div = document.createElement(&quot;div&quot;);
    div.innerHTML = this.html;
    document.body.appendChild(div);
}

let Singleton = (function() {
    let instance;
    return function(html) {
        return instance || (instance = new GetSingleton(html));
    }
})();

let gary_one = new Singleton(&quot;gary_one&quot;);
let gary_two = new Singleton(&quot;gary_two&quot;);
//页面上只有创造了一个DIV DOM节点,内容是&quot;gary_one&quot;
//在这里打印:
//true
console.log(gary_one === gary_two);
</code></pre><h2 id="Javascript单例模式-———-单一对象"><a href="#Javascript单例模式-———-单一对象" class="headerlink" title="Javascript单例模式 ——— 单一对象"></a>Javascript单例模式 ——— 单一对象</h2><pre><code>let obj_only = {
    a() {
        console.log(&quot;a&quot;);
    },
    b() {
        console.log(&quot;b&quot;);
    }
};
//在这里打印:
//a
obj_only.a();
//在这里打印:
//b
obj_only.b();

//动态空间对象
let MyApp = {};
MyApp.namespace = function(model) {
    let parts = model.split(&quot;.&quot;),
        prototype = MyApp;
    for(let [key, value] of parts.entries()) {
        if(!prototype[value]) {
            prototype[value] = {};
        }
        prototype = prototype[value];
    }    
};
MyApp.namespace(&quot;model&quot;);
MyApp.namespace(&quot;div.style&quot;);
//在这里打印:
//{model: {}, div: {style: {}}}
console.log(MyApp);

//闭包
function Person() {
    let _name = &quot;Gary&quot;,
        _age = 26;
     return function() {
        return `name: ${_name}, age: ${_age}`;
     }   
}
let Gary = Person();
//在这里打印:
//name: Gary, age: 26
console.log(Gary());
</code></pre><h2 id="惰性单例模式"><a href="#惰性单例模式" class="headerlink" title="惰性单例模式"></a>惰性单例模式</h2><pre><code>//首先演示的不是惰性单例模式,而是对于创造单个对象有哪几种方式
let GetSingleton = (function (){
    let div = document.createElement(&quot;div&quot;);
    div.innerHTML = &quot;Gary&quot;;
    div.style.display = &quot;none&quot;;
    document.body.appendChild(div);
    return div;
})();

function Singleton() {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        let singletonDiv = GetSingleton;
        singletonDiv.style.display = &quot;block&quot;;
        //取消冒泡事件
        e.stopImmediatePropagation();
    };
}

//这种情况下,无论调不调用Singleton方法,界面在最开始加载时,就已经进行了DOM操作,添加了一个DIV DOM节点,并把这个节点的内容设置为Gary,显示方式设置为none,这种方式的确时创造了单个对象且不可再次创造,但是缺点还是比较明显的,创造不创造单个对象跟绑定事件并没有关系,假如我在页面上并没有触发绑定的事件,页面上在一开始还是具有已经创造好的DIV DOM节点的
Singleton();


function GetSingleton() {
    let div = document.createElement(&quot;div&quot;);
    div.innerHTML = &quot;Gary&quot;;
    div.style.display = &quot;none&quot;;
    document.body.appendChild(div);
    return div;
}

function Singleton() {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        let singletonDiv = GetSingleton();
        singletonDiv.style.display = &quot;block&quot;;
        //取消冒泡
        e.stopImmediatePropagation();
    };
}

//这种情况下,满足了调用时再创造单个对象的条件,但是并不满足创造了单个对象并不可再次创造的条件,在这种情况下,每点击一次id为open的按钮一次,就会创造一个对象,这显然是不符合单例模式的特点的
Singleton();

let GetSingleton = (function() {
    let res;
    return function() {
        if(!res) {
            res = document.createElement(&quot;div&quot;);
            res.innerHTML = &quot;Gary&quot;;
            res.style.display = &quot;none&quot;;
            document.body.appendChild(res);
        }
        return res;
    }
})();

function Singleton() {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        let singletonDiv = GetSingleton();
        singletonDiv.style.display = &quot;block&quot;;
        //取消冒泡
        e.stopImmediatePropagation();
    };
}

//这种才是真正的惰性单例模式,在调用绑定事件时才创造单个对象,且也满足创造了单个对象并不可再次创造的条件,但是还是有优化的空间的
Singleton();
</code></pre><h2 id="惰性单例模式-优化版本"><a href="#惰性单例模式-优化版本" class="headerlink" title="惰性单例模式(优化版本)"></a>惰性单例模式(优化版本)</h2><pre><code>function GetSingleton(func) {
    let res;
    return function() {
        return res || (res = func.apply(this, arguments));
    }
}

let singleton = GetSingleton(function() {
    let div = document.createElement(&quot;div&quot;);
    div.innerHTML = &quot;Gary&quot;;
    div.style.display = &quot;none&quot;;
    document.body.appendChild(div);
    return div;
});

function Singleton() {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        let singletonDiv = singleton();
        singletonDiv.style.display = &quot;block&quot;;
        //取消冒泡事件
        e.stopImmediatePropagation();
    };
}

//这是惰性单例模式的最终优化版本,最显著的特点时它的复用性,无论是创造任何的DOM节点,只用GetSingleton函数方法,外部传入一个func函数即可,立即满足创造单一对象之后不可再次创建的特点
Singleton();
</code></pre><h2 id="惰性单例模式的应用"><a href="#惰性单例模式的应用" class="headerlink" title="惰性单例模式的应用"></a>惰性单例模式的应用</h2><blockquote>
<p>还记得jQuery工具库的.one函数方法嘛,它就是最经典的单例模式例子,我们今天来模拟一下</p>
</blockquote>
<pre><code>function GetSingleton(func) {
    let res;
    return function() {
        return res || (res = func.apply(this, arguments));
    }
}

let bindEvent = GetSingleton(function () {
    document.getElementById(&quot;open&quot;).onclick = function(e) {
        alert(&quot;Gary&quot;);
        //取消冒泡
        e.stopImmediatePropagation();
    };
    console.log(&quot;bind~&quot;);
    return true;
});

function render() {
    console.log(&quot;开始渲染~&quot;);
    bindEvent();
}

//切实的实现了单例模式&quot;一朝绑定,终生收益&quot;的特性
//在这里打印:
//开始渲染~
//bind~
//开始渲染~
//开始渲染~
render();
render();
render();
</code></pre><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote>
<p>策略模式的主要条件有三个: 可扩展、可复用和可替换,就让我们先演示一个非策略模式下的例子,我们要计算年终奖,首先要知晓月薪基数,然后再知道奖励倍数,就可以计算出最后的年终奖,一般我们会这么写</p>
</blockquote>
<pre><code>function getPerformance(performance, salary) {
    if(performance === &quot;S&quot;) {
        return salary * 4;
    }
    if(performance === &quot;A&quot;) {
        return salary * 3;
    }
    if(performance === &quot;B&quot;) {
        return salary * 2;
    }
}

//在这里打印:
//80000
console.log(getPerformance(&quot;S&quot;, 20000));
//在这里打印:
//120000
console.log(getPerformance(&quot;A&quot;, 40000));
</code></pre><blockquote>
<p>非策略模式的例子,存在很多缺点,首先,策略对象不可复用,策略对象逻辑全都写在一个函数对象里面,并不能拿出进行复用,其次,扩展很不方便,每一次扩展都必须去改变策略对象所处的逻辑函数对象,最后新的策略对象不可替换新的策略对象,接下来我们用传统的策略模式进行解决,首先将策略对象抽取到外面,形成一个抽象的对象</p>
</blockquote>
<pre><code>function PerformanceS() {

}

PerformanceS.prototype.getSalary = function(salary) {
    return salary * 4;
};

function PerformanceA() {

}

PerformanceA.prototype.getSalary = function(salary) {
    return salary * 3;
};

function PerformanceB() {

}

PerformanceB.prototype.getSalary = function(salary) {
    return salary * 2;
};

function GetPerformanceSalary() {
    this.performance = null;
    this.salary = null;
}

GetPerformanceSalary.prototype.setPerformance = function(performance) {
    this.performance = performance;
};

GetPerformanceSalary.prototype.setSalary = function(salary) {
    this.salary = salary;
};

GetPerformanceSalary.prototype.getBonus = function() {
    return this.performance.getSalary(this.salary);  
};

let getPerformanceSalary = new GetPerformanceSalary();
getPerformanceSalary.setSalary(20000);
getPerformanceSalary.setPerformance(new PerformanceS());
//在这里打印:
//80000
console.log(getPerformanceSalary.getBonus());
getPerformanceSalary.setSalary(40000);
getPerformanceSalary.setPerformance(new PerformanceA());
//在这里打印:
//120000
console.log(getPerformanceSalary.getBonus());
</code></pre><blockquote>
<p>策略模式下的策略对象,复用性、扩展性和替换性都很强,策略对象现在是以抽象函数的形式进行的定义,可以直接拿原有的抽象函数对象进行复用,也可以定义新的抽象函数对象进行扩展,在替换性方面,薪酬基数和策略对象模式都可根据set…方法的方式进行替换,并且得到不同的结果</p>
</blockquote>
<h2 id="Javascript策略模式"><a href="#Javascript策略模式" class="headerlink" title="Javascript策略模式"></a>Javascript策略模式</h2><pre><code>let categories = {
    S(salary) {
        return salary * 4;
    },
    A(salary) {
        return salary * 3;
    },
    B(salary) {
        return salary * 2;
    }
};

function getPerformance(performance, salary) {
    return categories[performance](salary);
}

//在这里打印:
//80000
console.log(getPerformance(&quot;S&quot;, 20000));
//在这里打印:
//120000
console.log(getPerformance(&quot;A&quot;, 40000));
</code></pre><h2 id="策略模式-——-表单验证"><a href="#策略模式-——-表单验证" class="headerlink" title="策略模式 —— 表单验证"></a>策略模式 —— 表单验证</h2><blockquote>
<p>使用策略模式来进行表单验证,也是一种很好的做法,首先我们先不使用策略模式来编写表单验证</p>
</blockquote>
<pre><code>function validate() {
    let userAgent = document.getElementById(&quot;user-agent&quot;);
    if(userAgent.username.value === &quot;&quot;) {
        return &quot;用户名不可为空&quot;;
    }
    if(userAgent.password.value.length !== 6) {
        return &quot;密码长度必须为6位&quot;;
    }
    if(!/^1(3|5|8)[\d]{9}$/.test(userAgent.phone.value)) {
        return &quot;手机号码不符合规范&quot;;
    }
}

let userAgent = document.getElementById(&quot;user-agent&quot;);
userAgent.onsubmit = function(e) {
    let errMsg = validate();
    if(errMsg) {
        console.log(errMsg);
    }
    //取消冒泡事件
    e.stopImmediatePropagation();
    //取消默认事件
    e.preventDefault();
};
</code></pre><blockquote>
<p>策略对象不可复用,全都处在validate函数作用域下,且不可扩展,扩展必须去更改validate源代码,不符合开放封闭原则,更不能替换在任何的表单校验上面,只能针对特定的表单(name为username,password,phone的表单)进行校验,所以不使用策略模式,效果极差,下面我们就使用策略模式来进行表单校验</p>
</blockquote>
<pre><code>let categories = {
    isNonUsername(value, errMsg) {
        if(value === &quot;&quot;) {
            return errMsg;
        }
    },
    minLength(value, length, errMsg) {
        if(value.length !== parseInt(length)) {
            return errMsg;
        }
    },
    isMobile(value, errMsg) {
        if(!/^1(3|5|8)[\d]{9}$/.test(value)) {
            return errMsg;
        }
    }
};

function Validate() {
    this.cache = [];
}

Validate.prototype.add = function(dom, condition, errMsg) {
    this.cache.push(function() {
        let parts = condition.split(&quot;:&quot;);
        let categories_condition = parts.shift();
        parts.unshift(dom.value);
        parts = [...parts, errMsg];
        return categories[categories_condition].apply(dom, parts);
    });
};

Validate.prototype.start = function() {
    for(let [key, value] of this.cache.entries()) {
        let validateFunc = value;
        let errMsg = validateFunc();
        if(errMsg) {
            return errMsg;
        }
    }  
};

function validate() {
    let userAgent = document.getElementById(&quot;user-agent&quot;),
        new_validate = new Validate();
    new_validate.add(userAgent.username, &quot;isNonUsername&quot;, &quot;用户名不可为空&quot;);
    new_validate.add(userAgent.password, &quot;minLength:6&quot;, &quot;密码长度必须为6位&quot;);
    new_validate.add(userAgent.phone, &quot;isMobile&quot;, &quot;手机号码不符合规范&quot;);
    let errMsg = new_validate.start();
    if(errMsg) {
        return errMsg;
    }    
}

let userAgent = document.getElementById(&quot;user-agent&quot;);
userAgent.onsubmit = function(e) {
    let errMsg = validate();
    if(errMsg) {
        console.log(errMsg);
    }
    //取消冒泡事件
    e.stopImmediatePropagation();
    //取消默认事件
    e.preventDefault();
};
</code></pre><blockquote>
<p>这样就利用策略模式的复用性、扩展性以及替换性完美的解决了表单验证,你这时可能会有疑问,假如表单里面一个表单项有多个验证条件怎么办,这套策略模式的方式不就不好使了嘛,别急,只要修改一下Validate.prototype.add函数方法,就可以既兼容一个还兼容多个验证条件</p>
</blockquote>
<pre><code>let categories = {
    isNonUsername(value, errMsg) {
        if(value === &quot;&quot;) {
            return errMsg;
        }
    },
    minLength(value, length, errMsg) {
        if(value.length !== parseInt(length)) {
            return errMsg;
        }
    },
    isMobile(value, errMsg) {
        if(!/^1(3|5|8)[\d]{9}$/.test(value)) {
            return errMsg;
        }
    }
};

function Validate() {
    this.cache = [];
}

Validate.prototype.add = function(dom, rules) {
    for(let [key, value] of rules.entries()) {
        this.cache.push((function() {
            let condition = value[&quot;condition&quot;],
                errMsg = value[&quot;errMsg&quot;];
            return function() {
                let parts = condition.split(&quot;:&quot;);
                let categories_condition = parts.shift();
                parts.unshift(dom.value);
                parts = [...parts, errMsg];
                return categories[categories_condition].apply(dom, parts);
            }    
        })());
    }
};

Validate.prototype.start = function() {
    for(let [key, value] of this.cache.entries()) {
        let validateFunc = value;
        let errMsg = validateFunc();
        if(errMsg) {
            return errMsg;
        }
    }
};

function validate() {
    let userAgent = document.getElementById(&quot;user-agent&quot;),
        new_validate = new Validate();
     new_validate.add(userAgent.username, [{
        condition: &quot;isNonUsername&quot;,
        errMsg: &quot;用户名不可为空&quot;
     }, {
        condition: &quot;minLength:10&quot;,
        errMsg: &quot;用户名长度必须为10位&quot;
     }]);
     new_validate.add(userAgent.password, [{
        condition: &quot;minLength:6&quot;,
        errMsg: &quot;密码长度必须为6位&quot;
     }]);
     new_validate.add(userAgent.phone, [{
        condition: &quot;isMobile&quot;,
        errMsg: &quot;手机号码不和规范&quot;
     }]);

     let errMsg = new_validate.start();
     if(errMsg) {
        return errMsg;
     }
}

let userAgent = document.getElementById(&quot;user-agent&quot;);
userAgent.onsubmit = function(e) {
    let errMsg = validate();
    if(errMsg) {
        console.log(errMsg);
    }
    //取消冒泡事件
    e.stopImmediatePropagation();
    //取消默认事件
    e.preventDefault();
};
</code></pre><blockquote>
<p>这样就完美解决了多个验证条件的问题,这种策略模式可复用,可扩展,可替换,十分完美</p>
</blockquote>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>下面我们要介绍的是代理模式,顾名思义,代理模式就是通过代理层去替代实体对象处理一些信息,其实就是在保护实体对象,减少实体对象的职责,在过滤、处理、整合信息之后再交给实体对象,这样会使得实体对象很轻便,对于实体对象的扩展性、维护性以及替换性有很大的帮助</p>
</blockquote>
<pre><code>function Flower() {
}

let xiaoming = {
    sendFlower(target) {
        let flower = new Flower();
        target.receiveFlower(flower);
    }
};

let A = {
    receiveFlower(flower) {
        console.log(&quot;已收到花朵: &quot; + flower);
    }
};

let B = {
    receiveFlower(flower) {
        A.receiveFlower(flower);
    }
};

//在这里打印:
//已收到花朵: [object Object]
xiaoming.sendFlower(B);
</code></pre><blockquote>
<p>这样就形成了一个小明送给女神A花朵表达想和她恋爱的心意,又不太好意思亲自送,只好让他跟A共同的好友B来进行代理送,这就是一个典型的代理模式的例子,你可能会问,这样做有什么意义呢,只不过多了一层罢了,的确这样只是多添加了一层而已,但是假如我们再改编一下剧情,你就会感觉很有意义</p>
</blockquote>
<pre><code>function Flower() {
}

let xiaoming = {
    sendFlower(target) {
        let flower = new Flower();
        target.receiveFlower(flower);
    }
};

let A = {
    receiveFlower(flower) {
        console.log(&quot;已收到花朵: &quot; + flower);
    },
    listenerBeHappy(func) {
        let self = this;
        setTimeout(function() {
            func.apply(self);
        }, 1000);
    }
};

let B = {
    receiveFlower(flower) {
        A.listenerBeHappy(function () {
            this.receiveFlower(flower);
        });
    }
};

//在这里打印:
//已收到花朵: [object Object]
xiaoming.sendFlower(B);
</code></pre><blockquote>
<p>故事的剧情转变成了这样,小明送给女神A花朵表达想和她恋爱的心意,又不太好意思亲自送,只好让他跟A共同的好友B来进行代理送,B清楚A什么时间心情最好,什么时间可以接受别人对她的表白,所以B在A心情很好的时候将小明的花朵转交给女神A,虽然也不见得小明的追求会成功,但是B的代理工作充分表明了代理模式</p>
</blockquote>
<h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><blockquote>
<p>我们使用虚拟代理来写一个懒加载图片的例子,通常我们使用Js写加载图片时,一般会这么做</p>
</blockquote>
<pre><code>let loadImage = (function () {
    let Image = document.createElement(&quot;img&quot;);
    document.body.appendChild(Image);
    return {
        setSrc(src) {
            Image.src = src;
        }
    }
})();

loadImage.setSrc(&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;);
</code></pre><blockquote>
<p>但是这样做有一个用户体验的交互问题,图片还没有完全渲染的时候,图片区域是空白的,这时候我们需要使用代理来虚拟在图片还没有完全渲染完毕的时候,先在所在区域展示loading加载图,当图片完全渲染完毕之后,再将所在区域替换成图片</p>
</blockquote>
<pre><code>let loadImage = (function () {
    let Image = document.createElement(&quot;img&quot;);
    document.body.appendChild(Image);
    return {
        setSrc(src) {
            Image.src = src;
        }
    }
})();

let proxyLoadImage = (function () {
    let img = new Image();
    img.onload = function() {
        loadImage.setSrc(this.src);
    };

    return {
        setSrc(src) {
            loadImage.setSrc(&quot;../img/zy.jpeg&quot;);
            img.src = src;
        }
    }
})();

proxyLoadImage.setSrc(&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;);
</code></pre><blockquote>
<p>虚拟代理模式对于用户是无感的,用户不会知道你使用的是实体对象接口还是虚拟代理对象接口,且虚拟代理对象的复用性、扩展性以及可替换性都是很完美的,完全不会破坏原有的实体对象的代码结构,下面我们来写一个使用虚拟代理模式实现批量提交文件,节省浏览器和后台服务器资源的例子</p>
</blockquote>
<pre><code>function syncReadFile(id) {
    console.log(&quot;开始上传文件: &quot; + id);
}

let checkbox = document.getElementsByName(&quot;checkbox&quot;);
for(let i = 0; i &lt; checkbox.length; i ++) {
    checkbox[i].onclick = function(e) {
        if(this.checked) {
            syncReadFile(this.id);
        }
        //取消冒泡事件
        e.stopImmediatePropagation();
    };
}
</code></pre><blockquote>
<p>这个例子,我每点一次复选框,且复选框选中,就会上传文件,在短时间内选中多个复选框,会造成大量的上传请求发出,频繁的调用上传接口,会大量浪费浏览器和后台服务器资源,所以我们设置一个函数节流函数来模拟syncReadFile函数,相当于是一个虚拟代理模式的函数,节省浏览器和后台服务器资源</p>
</blockquote>
<pre><code>function syncReadFile(id) {
    console.log(&quot;开始上传文件: &quot; + id);
}

let proxySyncReadFile = (function() {
    let cache = [],
        timer = null;
    return function (id) {
        let self = this;
        cache = [...cache, id];
        if(timer) {
            return false;
        }
        timer = setTimeout(function () {
            let id_transform = cache.join(&quot;,&quot;);
            syncReadFile.call(self, id_transform);
            clearTimeout(timer);
            timer = null;
            cache.length = 0;
        }, 2000);
    }    
})();

let checkbox = document.getElementsByName(&quot;checkbox&quot;);
for(let i = 0; i &lt; checkbox.length; i ++) {
    checkbox[i].onclick = function (e) {
        if(this.checked) {
            proxySyncReadFile(this.id);
        }
        //取消冒泡事件
        e.stopImmediatePropagation();
    };
}
</code></pre><h2 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h2><blockquote>
<p>我们先来写一个缓存代理计算乘积的例子,当传入的参数与上一次传入的参数相同时,就使用缓存中的乘积结果,不需要再次进行计算</p>
</blockquote>
<pre><code>function getMultiple() {
    let cache = {};
    function multiple() {
        let a = 1;
        for(let i = 0; i &lt; arguments.length; i ++) {
            a *= arguments[i];
        }
        return a;
    }
    return function() {
        let cache_prototype = Array.prototype.join.call(arguments, &quot;_&quot;);
        if(cache[cache_prototype]) {
            return cache[cache_prototype];
        }
        console.log(&quot;again&quot;);
        return cache[cache_prototype] = multiple.apply(this, arguments);
    }
}

let multipleForReal = getMultiple();
//在这里打印:
//again
//168
console.log(multipleForReal(4, 6, 7));
//在这里打印:
//168
console.log(multipleForReal(4, 6, 7));
</code></pre><blockquote>
<p>让我们将事情变得更有趣一些</p>
</blockquote>
<pre><code>function plus() {
    let a = 0;
    for(let i = 0; i &lt; arguments.length; i ++) {
        a += arguments[i];
    }
    return a;
}

function multiple() {
    let a = 1;
    for(let i = 0; i &lt; arguments.length; i ++) {
        a *= arguments[i];
    }
    return a;
}

function getMethod(func) {
    let cache = {};
    return function () {
        let cache_prototype = Array.prototype.join.call(arguments, &quot;_&quot;);
        if(cache[cache_prototype]) {
            return cache[cache_prototype];
        }
        console.log(&quot;again&quot;);
        return cache[cache_prototype] = func.apply(this, arguments);
    }
}

let getMethodResult = getMethod(plus);
//在这里打印:
//again
//20
console.log(getMethodResult(4, 8, 8));
//在这里打印:
//20
console.log(getMethodResult(4, 8, 8));
let getMethodResult_multiple = getMethod(multiple);
//在这里打印:
//again
//256
console.log(getMethodResult_multiple(4, 8, 8));
//在这里打印:
//256
console.log(getMethodResult_multiple(4, 8, 8));
</code></pre><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote>
<p>除了某一些古代的语言,现代的程序语言都实现了内置迭代器,迭代器模式或许从来都没有被人所听说过,我们今天就用JavaScript来模拟迭代器模式</p>
</blockquote>
<pre><code>function each(arr, func) {
    for(let [key, value] of arr.entries()) {
        func.call(this, key, value);
    }
}

//在这里打印:
//0 2
//1 6
//2 8
each([2, 6, 8], function (index, item) {
    console.log(index, item);
});
</code></pre><blockquote>
<p>这只是内部迭代器模式,将迭代逻辑放在内部实现,但是这样做很不灵活,比如我要实现一个俩数组是否相等的函数compare,你会发现compare的实现方式并不美观,且很不灵活</p>
</blockquote>
<pre><code>function each(arr, func) {
    for(let [key, value] of arr.entries()) {
        func.call(this, key, value);
    }
}

function compare(arr, arrAno) {
    if(arr.length !== arrAno.length) {
        throw new Error(&quot;两个数组不相同&quot;);
    }
    each(arr, function (index, item) {
        if(item !== arrAno[index]) {
            throw new Error(&quot;两个数组不相同&quot;);
        }
    });
    console.log(&quot;两个数组是相同的&quot;);
}

//在这里打印:
//两个数组是相同的
compare([1, 2, 5], [1, 2, 5]);
//在这里报错:
//两个数组不相同
compare([1, 2, 8], [1, 3, 6]);
</code></pre><h2 id="外部迭代模式"><a href="#外部迭代模式" class="headerlink" title="外部迭代模式"></a>外部迭代模式</h2><blockquote>
<p>后来出现了外部迭代模式,代码如下,这种迭代模式,灵活的解决了外部传入迭代器时,一些比较复杂的需求,维护性、扩展性、灵活性都很高,且针对对象和数组,只要拥有length属性的对象都可以进行迭代</p>
</blockquote>
<pre><code>function Iterator(obj) {
    let index = 0,
        length = obj.length;
    function next() {
        index++;
    }    
    function isDone() {
        return index &lt; length;
    }
    function getCurrentItem() {
        return obj[index];
    }
    return {
        length,
        next,
        isDone,
        getCurrentItem
    }
}
let iterator_arr = Iterator([55, 66, 99, 10, 1, 11, 28, 32]);
//在这里打印:
//55
//66
//99
//10
//1
//11
//28
//32
while(iterator_arr.isDone()) {
    console.log(iterator_arr.getCurrentItem());
    iterator_arr.next();
}
</code></pre><blockquote>
<p>这样的话,我们来编写compare函数进行两个函数比对时,就会灵活,更可维护的多</p>
</blockquote>
<pre><code>function Iterator(obj) {
    let index = 0,
        length = obj.length;

    function next() {
        index++;
    }

    function getCurrentItem() {
        return obj[index];
    }

    function isDone() {
        return index &gt;= length;
    }

    return {
        length,
        isDone,
        getCurrentItem,
        next
    }; 
}

function compare(arr, arrAno) {
    if(arr.length !== arrAno.length) {
        throw new Error(&quot;两个数组不相同&quot;);
    }
    while(!arr.isDone() &amp;&amp; !arrAno.isDone()) {
        if(arr.getCurrentItem() !== arrAno.getCurrentItem()) {
            throw new Error(&quot;两个数组不相同&quot;);
        }
        arr.next();
        arrAno.next();
    }
    console.log(&quot;两个数组是相同的&quot;);
}

let iterator = Iterator([1, 6, 8, 10, 55, 25, 36, 96]);
let iterator_ano = Iterator([1, 6, 8, 10, 55, 25, 36, 96]);
let iterator_diff = Iterator([1, 6, 8, 10, 55, 25, 36, 96]);
let iterator_diff_ano = Iterator([1, 6, 8, 10, 55, 28, 36, 96]);
//在这里打印:
//两个数组是相同的
compare(iterator, iterator_ano);
//在这里报错:
//两个数组不相同
compare(iterator_diff, iterator_diff_ano);
</code></pre><blockquote>
<p>jQuery中的each方法,就提供了迭代的功能,但是each方法不仅可以迭代数组,还可以迭代对象,我们来看一下each方法的源代码实现方式</p>
</blockquote>
<pre><code>$.each = function (obj, func) {
    let value,
        i = 0,
        length = obj.length;
    if(Object.prototype.toString.call(obj) === &quot;[object Array]&quot;) {
        for(; i &lt; length; i++) {
            value = func.call(this, i, obj[i]);
            if(value === false) {
                break;
            }
        }
    } else {
        for(i in obj) {
            value = func.call(this, i, obj[i]);
            if(value === false) {
                break;
            }
        }
    }
}

//在这里打印:
//0 5
//1 8
//2 10
$.each([5, 8, 10, 3, 66], function (index, item) {
    if(item === 3) {
        return false;
    }
    console.log(index, item);
});
</code></pre><blockquote>
<p>这期间还使用了中断迭代器模式的判断语句 if(value === false) break;当函数返回false的时候,就将迭代器终止掉,直接break出for循环,下面我们来介绍反向迭代函数,我们分分钟搞定</p>
</blockquote>
<pre><code>function reverseEach(obj, func) {
    let value;
    for(let l = obj.length - 1; l &gt;=0; l--) {
        value = func.call(this, l, obj[l]);
        if(value === false) {
            break;
        }
    }
}

//在这里打印:
//4 101
//3 99
//2 66
reverseEach([10, 88, 66, 99, 101], function (index, item) {
    if(item === 88) {
        return false;
    }
    console.log(index, item);
});
</code></pre>]]></content>
      <categories>
        <category>Javascript设计模式</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-Git</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  昨天在配置我们这个博客项目系统的时候,配置主题时,发现主题大多数都是从外部的github项目里面clone到本地的themes目录下的,导致我上传到远程github时,没办法做到将外部的github项目一起推上去,而此系统固定的主题又想一键生成,不需要团队成员自己麻烦的手动配置。<br>  于是经过和同事的讨论（这里感谢我的同事——鹏辉[小灰灰]）,通过git子模块的形式,做到了一键hexo主题生成的方案。</p>
<blockquote>
<p>详情</p>
</blockquote>
<p>  首先将外部github hexo主题项目fork到自己的账号下，然后拉取自己账号下的项目，配置好主题的一些属性以及方法，push到远程，这样一个配置好的hexo主题项目就完成了。</p>
<p>  接着使用git submodule add @git/… themes/next将自己账号下刚刚fork的项目放到hexo主题目录下，这时候就会生成一个.gitmodules文件与子模块建立关系。</p>
<p>  最后编写bash文件，形成一个命令，这里我在package.json里面写一句命令语，也就是yarn run themes 或者 npm run themes，下面是bash文件的详情:</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! bin/bash</span></span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拉取并生成主题</p>
</blockquote>
<p>  完成之后，开发者就可以直接从远程git clone @git/…拉取项目，之后输入命令yarn run themes 或者 npm run themes，就可一键生成固定的主题啦!</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-整理sortOut</title>
    <url>/2020/01/14/%E6%AF%94%E6%9C%A8%E7%99%BDsortOut/</url>
    <content><![CDATA[<h1 id="足球前端规范"><a href="#足球前端规范" class="headerlink" title="足球前端规范"></a>足球前端规范</h1><h2 id="一、Git提交注释部分-git-comment-m-‘-’-，建议规范起来。"><a href="#一、Git提交注释部分-git-comment-m-‘-’-，建议规范起来。" class="headerlink" title="一、Git提交注释部分(git comment -m ‘?’)，建议规范起来。"></a>一、Git提交注释部分(git comment -m ‘?’)，建议规范起来。</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  首先比较重要的一点就是，当出现代码合并冲突问题或者代码合并合漏的情况，可以根据注释模板标识来进行查找，具体的人具体的提交版本可以一目了然，不必打扰其他相关的人；其次就是分支回滚时，可以清楚的看出回滚位置，做到很便捷的回滚；最后一点，能清晰的反应开发者这一个周都做了什么，更利于开发者回顾这一个周业务或者技术开发，再现实点儿的意义就是便于写周报，😄</p>
<pre><code>为此，我在我们足球业务组内部制定了一套注释草案，请大家建议、提意见或者查漏补缺:

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们以type:description形式来写注释，中间的:表达的是在某一种类型下，提交的某某某版本注释</span></span><br><span class="line">开发业务  <span class="string">'business:xxx'</span></span><br><span class="line">修改bug  <span class="string">'fix:xxx'</span></span><br><span class="line">优化  <span class="string">'optimize:xxx’</span></span><br><span class="line"><span class="string">追加文档  '</span>doc:xxx<span class="string">'</span></span><br><span class="line"><span class="string">生态搭建  '</span>build:xxx’</span><br><span class="line">样式修改  <span class="string">'style:xxx'</span></span><br><span class="line">重写  <span class="string">'rewrite:xxx'</span></span><br><span class="line">单元测试  <span class="string">'test:xxx'</span></span><br><span class="line"><span class="comment">//这里面是有交集冲突的，比如: </span></span><br><span class="line"><span class="comment">//如果只改了样式，而没有动任何其他的配置，那就是style:xxx</span></span><br><span class="line"><span class="comment">//但如果改了样式又改了其他的部分，是要按照当时业务场景来看的，可能是business、fix、optimize、rewrite等等</span></span><br><span class="line"><span class="comment">//以此类推，就是当单纯改了某一个分类，就按照分类算，但如果改了不同的分类，那就按照业务场景来看。</span></span><br><span class="line"><span class="comment">//有的小伙伴英语不好，多学几个单词感觉费劲，咱也有中文版:</span></span><br><span class="line">开发业务  <span class="string">'业务:xxx'</span></span><br><span class="line">修改bug  <span class="string">'问题:xxx'</span></span><br><span class="line">优化  <span class="string">'优化:xxx'</span></span><br><span class="line">追加文档  <span class="string">'文档:xxx'</span></span><br><span class="line">生态搭建  <span class="string">'生态:xxx'</span></span><br><span class="line">样式修改  <span class="string">'样式:xxx'</span></span><br><span class="line">重写  <span class="string">'重写:xxx'</span></span><br><span class="line">单元测试  <span class="string">'测试:xxx'</span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="二、Jenkins发布系统步骤"><a href="#二、Jenkins发布系统步骤" class="headerlink" title="二、Jenkins发布系统步骤"></a>二、Jenkins发布系统步骤</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  也就是为什么要有这个系统。我们的前端打包之后的文件实际上就是一些静态资源，开发人员每一次都要打包，而且还要上传到gitlab上面，静态资源是不应该放到gitlab代码管理库里面去的，有了这个发布系统，直接交给流程机器人进行打包处理，并自动发布到SIT、STG和PRD的环境上面，减少了人工的打包以及手动拉到服务器上面的时间，且静态资源也是分发到OSS静态资源服务器上面，可谓物归其所地。</p>
<blockquote>
<p>步骤</p>
</blockquote>
<p>  打开<a><a href="http://ticket.hupu.io/desk/" target="_blank" rel="noopener">http://ticket.hupu.io/desk/</a></a>这个发布工单的系统，如果是创建一个新的项目应用，无论是后台还是前端，选择”新应用申请”，申请一个新项目应用，申请就会耗一些时间，运维老大会对你申请的这个应用提出意见，比如应用名字等等，按照规范改，之后要找不同的人(王节红(运维老大)跟他说你这个应用的gitlab所在地址等等确认、邰鹏(拓海CBA官网的运维负责人)的确认)，最后新应用上线完成。</p>
<p>  之后，需要进行前端配置，由于OSS只放html文件，打包后的静态文件（CSS、JS等），需要放入W1服务器，OSS不支持CDN加速，而W1服务器实际上就是一个CDN服务器，所以需要配置webpack中的publicPath，访问静态文件需要使用w1的域名，路径为:<a><a href="http://w1.hoopchina.com.cn/games/static/项目名" target="_blank" rel="noopener">http://w1.hoopchina.com.cn/games/static/项目名</a></a>。</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>  当然也存在比较多的缺点，和前端小伙伴讨论的过程中，发现这个发布系统，只能单线程发布，对于多线程提交工单，并不支持，且进行提交工单的分支必须为release，所以当多人项目发布不同的功能点时，由于提交的时间点不同，当一人提交上去，另外的小伙伴就只能等着，等待这人的功能测试完全上线，才可以提交第二个工单，这样效率实际上是大大降低的。</p>
<blockquote>
<p>优化建议</p>
</blockquote>
<p>  和小伙伴商量之后，希望发布工单系统可以支持多分支提交工单，不只依赖于release分支，可以选择多个分支并入release分支，既可以勾选并入，也可以消除勾选移除，发布时，先检测是否存在冲突，解决完冲突之后，再发布至release，release分支发至sit和stg环境，待测试测完之后，再选择prd发布至线上并合入master分支（想法gitlab上的项目默认接入ci/cd，可以暴露gitlab的菜单选项，针对于某一个项目自定义自己的发布工单系统）。</p>
<h2 id="三、表单校验插件能在我们业务前端内使用"><a href="#三、表单校验插件能在我们业务前端内使用" class="headerlink" title="三、表单校验插件能在我们业务前端内使用"></a>三、表单校验插件能在我们业务前端内使用</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  抛弃之前的if else冗长的判断逻辑，将其集成插件使用，减少项目代码的冗余，提高规则插件的可复用性，此插件符合设计模式单一职责以及开放封闭的原则，使用策略模式来编写。</p>
<blockquote>
<p>原理</p>
</blockquote>
<p>  此插件是以校验规则为基则，支持添加一或多个校验变量对应一或多个校验规则，来实现一对一、多对一、一对多和多对多的校验方式，数据类型支持数组或者是字符串，校验规则可以自定义，且对出现异常或者问题时的提示语，也支持type:提示异常语的形式来弹出或者飞入等自定义形式提示异常。</p>
<blockquote>
<p>使用</p>
</blockquote>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> verify <span class="keyword">from</span> <span class="string">"../utils/verify"</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;phone, code, password, passwordConfirm&#125; = <span class="keyword">this</span>.state;</span><br><span class="line"><span class="keyword">return</span> verify.addRule([</span><br><span class="line">    phone,</span><br><span class="line">    code,</span><br><span class="line">    password,</span><br><span class="line">    passwordConfirm</span><br><span class="line">], [&#123;</span><br><span class="line">    rule: <span class="string">'isEmpty'</span>,</span><br><span class="line">    errMsg: [</span><br><span class="line">        <span class="string">'warning:请输入手机号'</span>,</span><br><span class="line">        <span class="string">'warning:请输入正确的验证码'</span>,</span><br><span class="line">        <span class="string">'warning:请输入6-16位密码'</span>,</span><br><span class="line">        <span class="string">'warning:请输入6-16位确认密码'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;]).addRule(</span><br><span class="line">    phone, [&#123;</span><br><span class="line">        rule: <span class="string">'isPhone:^1[3|4|5|6|7|8|9]\\d&#123;9&#125;$'</span>,</span><br><span class="line">        errMsg: [</span><br><span class="line">            <span class="string">'warning:输入的手机号不符合标准'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]).addRule(</span><br><span class="line">    password,</span><br><span class="line">    [&#123;</span><br><span class="line">        rule: <span class="string">'passwordBit:6'</span>,</span><br><span class="line">        errMsg: [</span><br><span class="line">            <span class="string">'warning:请输入6-16位密码'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">).addRule(</span><br><span class="line">    password,</span><br><span class="line">    [&#123;</span><br><span class="line">        rule: <span class="string">'passwordReg:^[\\w]+$'</span>,</span><br><span class="line">        errMsg: [</span><br><span class="line">            <span class="string">'warning:请输入数字或者字母'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">).addRule(</span><br><span class="line">    password, [&#123;</span><br><span class="line">        rule: <span class="string">`isConfirm:<span class="subst">$&#123;passwordConfirm&#125;</span>`</span>,</span><br><span class="line">        errMsg: [</span><br><span class="line">            <span class="string">'warning:两次输入得密码不一致'</span></span><br><span class="line">        ]</span><br><span class="line">&#125;]).execute();</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>源码</p>
</blockquote>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单校验插件</span></span><br><span class="line"><span class="keyword">let</span> verify = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ruleMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="keyword">const</span> rulesList = &#123;</span><br><span class="line">        <span class="comment">//校验输入框是否为空</span></span><br><span class="line">        isEmpty(val, type, errMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!val &amp;&amp; val !== <span class="number">0</span>) || val.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    type,</span><br><span class="line">                    errMsg</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//校验密码和确认密码是否相同</span></span><br><span class="line">        isConfirm(val, confirmVal, type, errMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val !== confirmVal) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    type,</span><br><span class="line">                    errMsg</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//校验密码长度</span></span><br><span class="line">        passwordBit(val, length, type, errMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val.length &lt; length) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    type,</span><br><span class="line">                    errMsg</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//校验密码是否是只有数字或者字母</span></span><br><span class="line">        passwordReg(val, reg, type, errMsg) &#123;</span><br><span class="line">            <span class="keyword">let</span> _reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(reg, <span class="string">'g'</span>);</span><br><span class="line">            <span class="keyword">if</span>(!_reg.test(val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    type,</span><br><span class="line">                    errMsg</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//校验手机号码</span></span><br><span class="line">        isPhone(val, reg, type, errMsg) &#123;</span><br><span class="line">            <span class="keyword">let</span> _reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(reg);</span><br><span class="line">            <span class="keyword">if</span>(!_reg.test(val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    type,</span><br><span class="line">                    errMsg</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Verify</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            ruleMap.set(<span class="keyword">this</span>, []);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加校验规则</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="variable">vals</span></span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="variable">rules</span></span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@returns <span class="type">&#123;Verify&#125;</span></span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        addRule = <span class="function">(<span class="params">vals, rules</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mapList = ruleMap.get(<span class="keyword">this</span>);</span><br><span class="line">            vals = (<span class="built_in">Object</span>.prototype.toString.call(vals) === <span class="string">"[object Array]"</span>) ? vals : [vals];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> vals.entries()) &#123;</span><br><span class="line">                rules.forEach(<span class="function"><span class="params">ruleItem</span> =&gt;</span> &#123;</span><br><span class="line">                    mapList.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> &#123;rule, errMsg&#125; = ruleItem;</span><br><span class="line">                        <span class="keyword">const</span> operation = rule.split(<span class="string">":"</span>);</span><br><span class="line">                        errMsg = errMsg <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? errMsg : [errMsg];</span><br><span class="line">                        <span class="keyword">const</span> currentErrMsg = errMsg[key];</span><br><span class="line">                        <span class="keyword">const</span> method = operation.shift();</span><br><span class="line">                        operation.unshift(val);</span><br><span class="line">                        operation.push(...currentErrMsg.split(<span class="string">":"</span>));</span><br><span class="line">                        <span class="keyword">return</span> rulesList[method](...operation);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ruleMap.set(<span class="keyword">this</span>, mapList);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行校验</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@returns <span class="type">&#123;boolean|*&#125;</span></span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        execute = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mapList = ruleMap.get(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">let</span> msg;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> mapVal <span class="keyword">of</span> mapList.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((msg = mapVal())) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.clear();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.clear();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将校验规则的方法都清除掉</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            ruleMap.set(<span class="keyword">this</span>, []);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Verify();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> verify;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="四、目录结构"><a href="#四、目录结构" class="headerlink" title="四、目录结构"></a>四、目录结构</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  建立一个生态，最重要的就是目录结构，一个好的目录结构，能够使开发的效率变高，省去过多的查找目录、路径和文件的时间，而开发一个生态或者一个项目，往往是要和业务连接起来的，所以目录结构有必要与业务紧密相连。</p>
<blockquote>
<p>详情</p>
</blockquote>
<p>  我们足球业务项目，建议采用umi的那种目录结构，配合业务界面的组件，无论是业务组件(不包含公用组件)、业务样式、私有业务样式变量，还是redux的行为action、触发redux action行为产生数据处理并返回的reducer、私有静态常量、私有工具，都放入和业务界面组件同一个目录路径下，这样在开发某一个界面的业务时，就不需要返回上一级甚至于根目录下寻找这些业务可能必备的样式、组件、工具、action、reducer和静态变量。</p>
<p>  而公有的部分则放入到盛装业务界面组件根路径的外部，比如静态图片、文字字体、音频和视频资源、公有的样式、公有的样式变量、公有的工具和组件以及公有的静态常量，都放入外部，分目录盛装，名字叫啥就不建议了，最起码要语义清晰且常用，让人能够比较容易的理解。</p>
<h2 id="五、react-state和props的使用"><a href="#五、react-state和props的使用" class="headerlink" title="五、react state和props的使用"></a>五、react state和props的使用</h2><blockquote>
<p>概括</p>
</blockquote>
<p>  state花心,props专一 ; state如此善变,props始终如一</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>  在还没有redux统一管理数据的年代,我们一般使用state来承接变量,在一个组件的内部,我们一般使用state来控制这个组件的喜怒哀乐和言行举止,控制器呢,就是setState;但是当组件套用时,父子关系呈现出来,父组件发现没办法传授和教育子组件一些经验和知识,因为组件都是有血有肉有自己意识的,所以只能强制,父组件通过传入自己的state,来改变子组件的一些坏习惯,俗话说得好,<b>“小树不修不直溜,人不修理哏啾啾”</b>,自然在子组件还没有成熟时,传入子组件内部的父组件state(也就是子组件props),子组件是无法修改的,只能听之任之,接受洗礼,但是当子组件变成熟,父组件变老,子组件想要改变父组件的需求也就自然显示出来,那如何能修改呢,只能劝父组件授权给他,以为父组件好的名义,父组件听到了心里,觉得”儿啊，长大了，懂事了”,直接给予子组件一个方法,这个方法行为直接可以改变父组件的state生活行为,而这个方法是子组件控制的。</p>
<p>  故state承接的是变量,而props只是state在父子传递state时的桥梁,桥梁是不可妄动的。</p>
<p>  建议state中不要放入常量,如果嫌某常量只是在本组件内使用或者嫌重新建一个静态常量文件麻烦,那就直接使用组件内部的this.constants = {number: ‘这是常量’};或者不放入到react组件内,直接在文件顶部加一个const constants = {number: ‘这是常量’};也是可以的。</p>
<h2 id="六、react事件"><a href="#六、react事件" class="headerlink" title="六、react事件"></a>六、react事件</h2><blockquote>
<p>定义</p>
</blockquote>
<p>  事件往往代表一个对象、一个组件和一套工具的行为,而react事件的演化从初始阶段的bind显示硬绑定,至中期的箭头函数,直至现阶段比较好的箭头函数配合data-propsType属性的方式。</p>
<blockquote>
<p>前期bind硬绑定</p>
</blockquote>
<p>  在前期,我们既希望事件函数的this指向React组件对象本身,又希望可以传递某些数据状态,且this不要指向事件所绑定的元素dom或者react虚拟dom，在这时候，我们选择了bind硬绑定,事件.bind(this, params)酱紫,但是发现这样大抵是为内存泄漏埋下了隐患。</p>
<p>  我们先看一下模拟bind的js源代码:</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        fBind,</span><br><span class="line">        args = [...arguments];</span><br><span class="line">    args.shift();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    fBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> newArgs = [...args, ...arguments];</span><br><span class="line">        <span class="keyword">return</span> _this.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBind ? <span class="keyword">this</span> : context, newArgs);</span><br><span class="line">   &#125;;</span><br><span class="line">    <span class="comment">//这里让返回的函数的隐式原型指向其绑定的事件函数的显式原型</span></span><br><span class="line">    F.prototype = _this.prototype;</span><br><span class="line">    fBind.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> fBind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><p>  这样就是一个完整的bind硬绑定的函数，基于Function函数对象的原型链上面，但是大家可以看到，bind硬绑定形成了一个闭包，fBind的这个函数对象，在异步机制中的内存当中是一直存在的。那就意味着，我硬绑定多个事件，就会形成多个闭包，这样迟早会形成内存泄漏，实在是不可取的一个方式。</p>
<blockquote>
<p>中期的箭头函数与现阶段的箭头函数配合data-propsType属性</p>
</blockquote>
<p>  对于箭头函数，我们极为熟悉，不能改变其this的指向、无arguments类参数数组、不能使用new绑定构造调用和引用关联以及不能使用super继承。这样既写法简单，this的指向又解决了，指向React组件对象本身，且不指向事件所绑定的元素dom或者react虚拟dom。那么参数如何传入呢，当然你如果不嫌麻烦，可以这样:</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onClick=&#123;(e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="string">'me'</span>;</span><br><span class="line">    <span class="comment">//这个就是你定义的箭头函数</span></span><br><span class="line">    onChangeHandler(type, e);</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">    来吧，点击</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre><p>  但是太过麻烦，每次都要内部一个箭头函数，在外面又要再定义一个封装的箭头函数，感觉有点儿烦。所以我们可以利用自定义属性的方法，来解决这个问题。</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  onChangeHandler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;target&#125; = e || &#123;&#125;;</span><br><span class="line">      <span class="keyword">const</span> type = target.getAttribute(<span class="string">'data-type'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(type);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;onChangeHandler&#125; = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          &lt;div </span><br><span class="line">              data-type=<span class="string">'me'</span></span><br><span class="line">              onClick=&#123;onChangeHandler&#125;&gt;</span><br><span class="line">                来吧，点击</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );   </span></span><br><span class="line"><span class="regexp">  &#125;   </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</code></pre><p>  这种箭头函数配合data-propsType属性的方式，简易实用，是现阶段比较好的事件实现过程。</p>
<h2 id="七、添加注释"><a href="#七、添加注释" class="headerlink" title="七、添加注释"></a>七、添加注释</h2><blockquote>
<p>详情</p>
</blockquote>
<p>  注释是体现一个好的开发人员素养的标识,好且有效的注释在多人团队同时开发过程中的垫脚石,所以建议小伙伴们,无论是在业务逻辑还是技术逻辑比较复杂的部分,做好详细的注释,复杂技术逻辑只要讲清楚代码逻辑即可,而复杂业务逻辑,就需要讲业务的背景讲清楚,即是什么、为什么详细的表达明白。</p>
]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>微信小程序</tag>
        <tag>JS</tag>
        <tag>TS</tag>
        <tag>Git</tag>
        <tag>Nginx</tag>
        <tag>moment</tag>
      </tags>
  </entry>
  <entry>
    <title>学习图解HTTP一书笔记</title>
    <url>/2019/02/03/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E8%A7%A3HTTP%E4%B8%80%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>HTTP协议: 超文本传输协议<br>URI:统一资源标识符<br>URL:统一资源定位符<br>从客户端应用层传输到服务器段应用层的过程:</p>
<pre><code>客户端应用层发出HTTP请求,将数据包加上应用层的首部发送给传输层(TCP),
TCP协议将数据包进行分割,分割成多个小数据包,并把小数据包进行标号(用在服务器端传输层以排序整合),之后将这些进行标号的小数据包加上传送层的首部发送给网络层(IP),
IP根据地址,进行查询并加上网络层的首部发送至服务器端的网络层(IP)。
接着服务器端的网络层对客户端网络层首部进行去掉的工作,并发送给传输层,
传输层对客户端传输层的首部进行去掉,并且将标号的小数据包根据标号进行排序整合,形成大数据包,发送至服务器的应用层,
服务器的应用层将大数据包的客户端应用层的首部进行去掉的工作,这样则看到了原数据。    
</code></pre>]]></content>
      <categories>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-moment</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-moment/</url>
    <content><![CDATA[<h1 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h1><h2 id="将时间戳-毫秒-转化为固定格式"><a href="#将时间戳-毫秒-转化为固定格式" class="headerlink" title="将时间戳(毫秒)转化为固定格式"></a>将时间戳(毫秒)转化为固定格式</h2><blockquote>
<p>详情</p>
</blockquote>
<p>   <a href="http://momentjs.cn/docs/#/displaying/" target="_blank">将时间戳转化为固定格式: 显示 format部分</a></p>
<h2 id="计算两个时间戳-毫秒-或者是固定格式的时间之间的数量级长度"><a href="#计算两个时间戳-毫秒-或者是固定格式的时间之间的数量级长度" class="headerlink" title="计算两个时间戳(毫秒)或者是固定格式的时间之间的数量级长度"></a>计算两个时间戳(毫秒)或者是固定格式的时间之间的数量级长度</h2><blockquote>
<p>原因</p>
</blockquote>
<p>   在开发小程序过程中,发现使用moment来计算两个时间戳或者固定格式时间之间的长度（比如两个时间之内差了几天、几个周、几个月、几年等等）,没有具体的例子,文档里面也没有说明,所以这里记录一下我探索出来的结果。</p>
<blockquote>
<p>详情</p>
</blockquote>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> startTime = <span class="number">1571414400000</span>;</span><br><span class="line"><span class="keyword">const</span> endTime = <span class="number">1598371200000</span>;</span><br><span class="line"><span class="comment">//这里就可以计算出这两个时间戳之间差了几天</span></span><br><span class="line"><span class="keyword">const</span> durationTime = moment(endTime).diff(moment(startTime), <span class="string">'days'</span>);</span><br><span class="line"><span class="comment">//如果再加一个参数,就可以精确的计算出两个时间戳之间差的天数(小数)</span></span><br><span class="line"><span class="keyword">const</span> durationTime_float = moment(endTime).diff(moment(startTime), <span class="string">'days'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//312 312(有时候会出现311.6666...7,是前端对于二进制的精度浮点数计算没有那么准确的原因)</span></span><br><span class="line"><span class="built_in">console</span>.log(durationTime, durationTime_float);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>moment</category>
      </categories>
      <tags>
        <tag>moment</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-web</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-web/</url>
    <content><![CDATA[<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="如何添加微信朋友圈分享网站页面的小图标"><a href="#如何添加微信朋友圈分享网站页面的小图标" class="headerlink" title="如何添加微信朋友圈分享网站页面的小图标"></a>如何添加微信朋友圈分享网站页面的小图标</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在搞欧冠”数说”欧冠的h5项目时,遇到了在手机浏览器分享和微信内部浏览器分享的问题。在都分享到朋友圈的情况下,手机浏览器分享,会截当前网站的图作为分享朋友圈的小图标,而微信内部浏览器分享朋友圈的小图标就为空(什么也没有,就是一个灰色的链接图)。后来发现,原来在微信内部分享至朋友圈,必须有公众号,绑定网站安全域名,使用JS接口调用缩率图…且此配置必须经手公众号后台配置,由前端调用weixin JSSDK方可设置小图标,微信非常保护自己的内部生态～～</p>
<blockquote>
<p>详情</p>
</blockquote>
<p>  <a href="https://www.metinfo.cn/faq/1830.html" target="_blank">如何添加微信朋友圈分享网站页面的小图标</a></p>
<h2 id="findIndex与IndexOf"><a href="#findIndex与IndexOf" class="headerlink" title="findIndex与IndexOf"></a>findIndex与IndexOf</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在搞CBA m站的适配,其中有一个ES6的方法让我耳目一新,那就是findIndex,与IndexOf类似,但是比其强大且更灵活,其强大更灵活的在于可以利用回调函数来找到数组或者字符串中的某数据类型的数据所在的位置,而类似的在于,两者返回的结果是一致的,如果不存在返回-1,如果存在则返回数组中数组元素的下标或者字符串中字符的下标。</p>
<blockquote>
<p>详情</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strArr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>],</span><br><span class="line">    char = <span class="string">'e'</span>,</span><br><span class="line">    anoChar = <span class="string">'f'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(strArr.indexOf(char));</span><br><span class="line"><span class="built_in">console</span>.log(strArr.indexOf(anoChar));</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(strArr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item === char));</span><br><span class="line"><span class="built_in">console</span>.log(strArr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item === anoChar));</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<h2 id="上传资源连接OSS-browsers-js"><a href="#上传资源连接OSS-browsers-js" class="headerlink" title="上传资源连接OSS(browsers.js)"></a>上传资源连接OSS(browsers.js)</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在写拓海官网后台的需求,在上传资源时,需要上传到阿里云OSS上面,经过了一番的折腾(查资料、询问同事…)终于搞懂了上传、授权访问和下载的流程。</p>
<p>  因为是私有域和资源,所以上传肯定需要带有accessKeyId和accessKeySecret,而访问和下载也需要带着keyId和keySecret,而访问和下载的资源链接都是临时的(30分钟一改变),因此上传时要存储到后台的字段不能为文件链接,只能是文件名称;为了防止命名重复冲突,导致文件覆盖,我对文件名称进行了处理(+时间戳+随机数)。</p>
<blockquote>
<p>详情</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> OSS <span class="keyword">from</span> <span class="string">'ali-oss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> endpoint = process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="string">'oss-cn-hongkong.aliyuncs.com'</span> : <span class="string">'oss-cn-hongkong-internal.aliyuncs.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> OSS(&#123;</span><br><span class="line">    <span class="comment">//这里为阿里云OSS服务器节点</span></span><br><span class="line">    region: <span class="string">'oss-cn-hangzhou'</span>,</span><br><span class="line">    <span class="comment">//keyId</span></span><br><span class="line">    accessKeyId: <span class="string">'xxx'</span>,</span><br><span class="line">    <span class="comment">//keySecret</span></span><br><span class="line">    accessKeySecret: <span class="string">'xxx'</span>,</span><br><span class="line">    <span class="comment">//endpoint地域节点</span></span><br><span class="line">    endpoint,</span><br><span class="line">    <span class="comment">//阿里云OSS项目名</span></span><br><span class="line">    bucket: <span class="string">'xxx'</span>,</span><br><span class="line">    <span class="comment">//阿里云项目后面的目录</span></span><br><span class="line">    dir: <span class="string">'xxx'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传阿里OSS配置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multipartUpload</span>(<span class="params">files = [], func = (</span>) =&gt; </span>&#123;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> file = files[<span class="number">0</span>][<span class="string">'file'</span>] || <span class="string">''</span>,</span><br><span class="line">        extraPoint = file[<span class="string">'name'</span>].lastIndexOf(<span class="string">'.'</span>),</span><br><span class="line">        name = file[<span class="string">'name'</span>].slice(<span class="number">0</span>, extraPoint),</span><br><span class="line">        extra = file[<span class="string">'name'</span>].slice(extraPoint);</span><br><span class="line">    <span class="comment">//这里在上传的文件上面+时间戳+随机数</span></span><br><span class="line">    name = <span class="string">`<span class="subst">$&#123;name&#125;</span>_<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>_<span class="subst">$&#123;<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">10000</span>)&#125;</span><span class="subst">$&#123;extra&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> client.multipartUpload(name, file, &#123;</span><br><span class="line">        progress: <span class="function">(<span class="params">p, checkpoint</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        func(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    client,</span><br><span class="line">    multipartUpload</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  上传搞定之后,可以查看阿里OSS的文档(文档在下方链接),搞定授权访问和下载。</p>
<p>  <div><a href="https://help.aliyun.com/document_detail/120092.html?spm=a2c4g.11186623.6.1323.15de18c9lFD7w0" target="_blank">阿里OSS browsers.js 授权访问</a></div><br>  <a href="https://help.aliyun.com/document_detail/64052.html?spm=a2c4g.11186623.6.1320.2b0219fdU4V9W8" target="_blank">阿里OSS browsers.js 下载</a></p>
<h2 id="分页删除功能交互处理"><a href="#分页删除功能交互处理" class="headerlink" title="分页删除功能交互处理"></a>分页删除功能交互处理</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在做小程序时,开发列表页面,列表有增删改查四个功能,在删除时,被要求需要有最优质最可靠最易于理解的交互,但是却在交互方面犯了难,如何在用户没有感知的情况下,将列表项删除.</p>
<blockquote>
<p>方案</p>
</blockquote>
<ol>
<li><p>不再使用pageNum和pageSize(页码和每页多少条列表项)来进行分页,使用某一页的最后一条的id来进行分页,在删除时,直接请求当前页最后一条id的列表项后面十条.<br>但是此方案有一个很大的缺点,在分布式后台系统的情况下,列表新增产生的列表项id并不会随着时间递增,并不一定id较大的一定排在id较小的列表项的后面,所以可能请求时,可能漏掉列表项.</p>
</li>
<li><p>还是使用pageNum和pageSize(页码和每页多少条列表项),只是在删除时,直接请求删除数据位置的页码的数据,如果正好分页请求到删除数据位置的页码,则不请求下一页;如果分页请求大于删除数据位置的页码,则请求删除数据位置的当前页以及下一页,而再接下来的页码,需要用户重新下拉请求.<br>此方案经过检验,是最好的分页删除功能交互处理方案,所以推荐此方案使用.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-Taro</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-Taro/</url>
    <content><![CDATA[<h1 id="微信小程序框架Taro"><a href="#微信小程序框架Taro" class="headerlink" title="微信小程序框架Taro"></a>微信小程序框架Taro</h1><h2 id="2-0升级压缩微信小程序包体积增大比较多"><a href="#2-0升级压缩微信小程序包体积增大比较多" class="headerlink" title="2.0升级压缩微信小程序包体积增大比较多"></a>2.0升级压缩微信小程序包体积增大比较多</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近taro框架由1.x升级至了2.0版本，变化比较大的就是编译这一块儿，增加了按需加载runtime第三方依赖，需要下载第三方按需加载依赖包babel-plugin-transform-runtime以及babel-runtime，编译器也进行了优化，新增了@tarojs/mini-runner编译依赖，使得编译优雅了许多，而且利用webpackChain配置，可以配置更多的webpack插件，比如说上面提到的ContextReplacementPlugin剔除某些外部依赖不打入至包内，再比如说webpack-bundle-analyzer这种可以监听打包之后包体积大小，进行可视化的第三方依赖都可以方便进行使用。</p>
<p>  但是实际效果,打包之后的体积比较与1.x版本,足足增大了400kb左右,导致我业务开发的小程序体积包从1.4M窜升至1.8M,uglify和csso压缩JS以及css的工具明显也不如之前1.x版本实用,开启压缩和不开启的实际效果,体积几乎没什么变化。</p>
<p>  由此基于小程序要上线,我又退回至1.x的最后一个版本,也许是@tarojs/mini-runner刚开发不久,编译依赖不够成熟吧。</p>
<p>  升级至2.0.6之后,这个问题有了不小的改善,Taro官方使用SplitChunksPlugin默认将打包分为四部分’runtime’,’vendors’,’taro’以及’commons’,分别代表的是懒加载、除了taro以外的在超过2个的入口模块都引入的第三方外部依赖包、taro除了taro以外的在超过2个的入口模块都引入的第三方外部依赖包以及在超过2个的入口模块都引入的公共业务部分。除了这些,taro还支持自己配置webpackChain SplitChunksPlugin自定义拆包。</p>
<p>  升级至2.1.0之后,这个问题基本有了彻底的改善,但是需要修改package.json scripts命令,将全局环境变量NODE_ENV更改为production,将开发环境代码打包、压缩、缓存以及多进程配置置为生产环境配置,加入至’dev:weapp’命令中,当然添加参数的方式有多样,可以用cross-env,也可以用yargs,这里我使用的是cross-env。</p>
<p>  taro-ui UI组件库的大小也改善了很多,尤其是支持了按需加载UI组件库方面,但是这里又出现了一个问题,taro-ui UI组件库在taro 2.1.0以后的版本生产环境也就是我所说的yarn run build:weapp,也可以使用我上述所说的将全局环境变量置为production,之后’dev:weapp’的方式,公共样式就不会导入进来,此bug在taro 2.1.5版本修复。<a href="https://github.com/NervJS/taro/issues/5998" target="_blank" rel="noopener">我提的taro issue</a></p>
<blockquote>
<p>使用</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是taro,这种使用react对接多端的框架,则是使用webpackChain</span></span><br><span class="line"><span class="comment">//2.0.6配置,config目录下的index.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mini: &#123;</span><br><span class="line">        commonChunks: [<span class="string">'runtime'</span>, <span class="string">'vendors'</span>, <span class="string">'common'</span>],</span><br><span class="line">        webpackChain(chain, webpack) &#123;</span><br><span class="line">            chain.optimization.splitChunks(&#123;</span><br><span class="line">                 minChunks: <span class="number">2</span>,</span><br><span class="line">                 minSize: <span class="number">0</span>,</span><br><span class="line">                 name: <span class="string">'vendors'</span>,</span><br><span class="line">                 maxInitialRequests: <span class="literal">Infinity</span>,</span><br><span class="line">                 chunks: <span class="string">'all'</span>,</span><br><span class="line">                 cacheGroups: &#123;</span><br><span class="line">                    common: &#123;</span><br><span class="line">                        minChunks: <span class="number">2</span>,</span><br><span class="line">                        name: <span class="string">'common'</span>,</span><br><span class="line">                        chunks: <span class="string">'initial'</span>,</span><br><span class="line">                        priority: <span class="number">1</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    vendors: &#123;</span><br><span class="line">                        minChunks: <span class="number">2</span>,</span><br><span class="line">                        name: <span class="string">'vendors'</span>,</span><br><span class="line">                        test: <span class="function">(<span class="params"><span class="built_in">module</span></span>)=&gt;</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="regexp">/[\\/]node_modules[\\/]/</span>.test(<span class="built_in">module</span>.resource);</span><br><span class="line">                        &#125;,</span><br><span class="line">                        chunks: <span class="string">'initial'</span>,</span><br><span class="line">                        priority: <span class="number">10</span></span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.1.0版本将开发环境代码置为生产环境代码,彻底解决2.0之后打包过大的问题</p>
</blockquote>
<p>  <img src="/images/taroPackageJson.png" alt></p>
<h2 id="微信小程序中转义换行问题"><a href="#微信小程序中转义换行问题" class="headerlink" title="微信小程序中转义换行问题"></a>微信小程序中转义换行问题</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  开发微信小程序时,发现后台返回的某一些字符串当中含有\n换行符,实际意义是为了让字符串在换行符的位置上进行换行展示,在PC端或者移动端开发中,我们可以使用\&lt;br/>来置换字符串中所有的\n换行符,而在小程序中,就感觉有一些手足无措。<br>  于是查阅资料,找到了解决方案。</p>
<blockquote>
<p>详情</p>
</blockquote>
<ol>
<li><p>在微信小程序中view标签中的任何可转义的字符,都不可以进行转义,只有在text标签中,且属性decode为true的情况下,才可以将转义字符进行转义。</p>
</li>
<li><p>字符串中的\n换行符,实际上为\n,故需要匹配字符串中所有的\n字符串,然后进行替换为\n换行符。</p>
</li>
</ol>
   <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Taro项目中的例子    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     render() &#123;</span><br><span class="line">         <span class="comment">//这样就可以在页面中显示</span></span><br><span class="line">         <span class="comment">//我叫尹文楷,</span></span><br><span class="line">         <span class="comment">//我今年十二岁了,</span></span><br><span class="line">         <span class="comment">//我喜欢写代码.</span></span><br><span class="line">         <span class="keyword">let</span> value = <span class="string">'我叫尹文楷,\\n我今年十二岁了,\\n我喜欢写代码.'</span>.replace(<span class="regexp">/\\n/g</span>, <span class="string">'\n'</span>);</span><br><span class="line">         <span class="keyword">return</span> (</span><br><span class="line">             &lt;Text decode&gt;</span><br><span class="line">                  &#123;value&#125;</span><br><span class="line">             &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">         )       </span></span><br><span class="line"><span class="regexp">     &#125;   </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="JSX渲染"><a href="#JSX渲染" class="headerlink" title="JSX渲染"></a>JSX渲染</h2><blockquote>
<p>原因</p>
</blockquote>
<p>   昨天在写Taro项目的时候,发现taro项目的渲染方法,最前端必须添加render,方可返回JSX,要是不添加render,编译时就会报错。而且不支持静态策略模式返回JSX,也会匹配不到语法而报错,所以就不使用策略模式来写了,而是使用判断语句switch来写,然而还是遇到了问题,switch每一个case分支判断语句,必须以{}花括号包裹返回。</p>
<p>   另外,在调用渲染JSX的方法时,即使是箭头函数,也不能以解构定义的变量去进行调用,必须以软绑定的形式去进行调用。</p>
<blockquote>
<p>使用</p>
</blockquote>
   <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    Image,</span><br><span class="line">    View</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">    renderShowConent = <span class="function">(<span class="params">type, content</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'TEXT'</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> &lt;Text&gt;</span><br><span class="line">                    &#123;content&#125;    </span><br><span class="line">                &lt;/Text&gt;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'IMG'</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> &lt;Image </span><br><span class="line">                    src=&#123;content&#125;</span><br><span class="line">                    alt=&#123;content&#125;</span><br><span class="line">                /&gt;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> type = <span class="string">'TEXT'</span>,</span><br><span class="line">              content = <span class="string">'yinwenkai'</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.renderShowConent(type, content)&#125;</span><br><span class="line">            &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="父子传参"><a href="#父子传参" class="headerlink" title="父子传参"></a>父子传参</h2><blockquote>
<p>原因</p>
</blockquote>
<p>   最近在写Taro小程序项目的时候,发现Taro小程序里面父子传参不像想象中的那么简单,尤其是this.props.children和自定义组件参数,实际在编译完之后this.props.children就是\&lt;slot>\&lt;/slot>,且在自组件里面使用this.props.children不能解构定义,比如{children} = this.props,必须使用this.props.children,而this.props.children不能为taro-ui的组件,必须为taro内置的原生组件;而自定义组件参数,规则就更多了,参数的命名前缀必须为render,在使用时也不可解构定义,必须使用this.props.render…,自定义组件参数最好不要是函数方法返回组件,而是直接赋值,这样可保万无一失。自定义组件参数既可为内置原生组件也可为taro-ui这种UI组件。</p>
<blockquote>
<p>使用</p>
</blockquote>
   <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    View</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        renderDemo: PropTypes.element</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.renderDemo&#125;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Demo;</span></span><br></pre></td></tr></table></figure>
   <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    View</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">     AtButton</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'taro-ui'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'../Demo'</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        renderDemo: PropTypes.element</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Demo renderDemo=&#123;</span><br><span class="line">                     &lt;AtButton type=<span class="string">'primary'</span>&gt;按钮&lt;<span class="regexp">/AtButton&gt;</span></span><br><span class="line"><span class="regexp">                 &#125;&gt;</span></span><br><span class="line"><span class="regexp">                     &lt;View&gt;</span></span><br><span class="line"><span class="regexp">                         尹文楷,god bless you~</span></span><br><span class="line"><span class="regexp">                     &lt;/</span>View&gt;</span><br><span class="line">                &lt;<span class="regexp">/Demo&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Parent;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Taro</category>
      </categories>
      <tags>
        <tag>taro</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-Nginx</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-Nginx/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>  <a href="https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7" target="_blank">CentOS 7 下 yum 安装和配置 Nginx</a></p>
<h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h2><blockquote>
<p>路径</p>
</blockquote>
<p>  centos下: /etc/nginx 使用sudo vim nginx.conf来进行配置</p>
<blockquote>
<p>问题</p>
</blockquote>
<p>  配置过程当中出现了403 forbidden的问题，查了一些资料，发现原来是nginx.conf文件下的配置族权限设置的问题</p>
<blockquote>
<p>详情</p>
</blockquote>
<pre><code># For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

# 只要将这里的族访问权限改为你新建的静态网页页面文件夹所处的族就可以了
# user nginx
user root root;

worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /root/blog/;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
#    server {
#        listen       443 ssl http2 default_server;
#        listen       [::]:443 ssl http2 default_server;
#        server_name  _;
#        root         /usr/share/nginx/html;
#
#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;
#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;
#        ssl_session_cache shared:SSL:1m;
#        ssl_session_timeout  10m;
#        ssl_ciphers HIGH:!aNULL:!MD5;
#        ssl_prefer_server_ciphers on;
#
#        # Load configuration files for the default server block.
#        include /etc/nginx/default.d/*.conf;
#
#        location / {
#        }
#
#        error_page 404 /404.html;
#            location = /40x.html {
#        }
#
#        error_page 500 502 503 504 /50x.html;
#            location = /50x.html {
#        }
#    }

}
</code></pre>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-React</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-React/</url>
    <content><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="List-List-Item"><a href="#List-List-Item" class="headerlink" title="List List.Item"></a>List List.Item</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在搞CBA m站适配时,尝试写了一把JS 基础组件,首当其冲的就是List List.Item列表组件,在我们m站适配中随处可见,其关键点就在于,怎么将某些在List列表组件中的属性,放到Item列表项组件里面,至此就想到了使用HOC高阶组件。</p>
<blockquote>
<p>详情</p>
</blockquote>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//List组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> cns <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">'./item'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        className: PropTypes.string,</span><br><span class="line">        onClick: PropTypes.func</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Item = Item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Item高阶组件</span></span><br><span class="line">    itemHOC = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;children, onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">children &amp;&amp; children.length &gt; <span class="number">0</span></span>) ? <span class="params">React</span>.<span class="params">Children</span>.<span class="params">map</span>(<span class="params">children, (child = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;<span class="attr">type</span>: Child, props = &#123;&#125;&#125; = child;</span><br><span class="line">            <span class="keyword">if</span>(Child !== Item) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'List component must be an Item component inside~'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &lt;Child &#123;...props&#125; onClick=&#123;onClick&#125;/&gt;;</span><br><span class="line">        &#125;) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;className = <span class="string">''</span>&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">const</span> &#123;itemHOC = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;section className=&#123;cns(</span><br><span class="line">                <span class="string">'list'</span>,</span><br><span class="line">                className</span><br><span class="line">            )&#125;&gt;</span><br><span class="line">                &#123;itemHOC()&#125;</span><br><span class="line">            &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default List;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Item组件  </span></span><br><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> cns <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        className: PropTypes.string,</span><br><span class="line">        onClick: PropTypes.func,</span><br><span class="line">        value: PropTypes.any</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            className = <span class="string">''</span>, </span><br><span class="line">            value,</span><br><span class="line">            onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, </span><br><span class="line">            children</span><br><span class="line">        &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=&#123;cns(<span class="string">'list-item'</span>, className)&#125;</span><br><span class="line">                 onClick=&#123;(e) =&gt; onClick(value, e)&#125;</span><br><span class="line">            &gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )   </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Item;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Item组件样式*/</span></span><br><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">14px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样就完成了List列表组件 List.Item列表项的基础组件的基础搭建,使用起来也是很简单的…</p>
<blockquote>
<p>使用</p>
</blockquote>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Item = List.Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> list = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123;<span class="attr">length</span>: <span class="number">10</span>&#125;), (item, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;[index]: (index + <span class="number">1</span>)&#125;;        </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            &lt;List className=<span class="string">'demo-list'</span></span><br><span class="line">                  onClick=&#123;(item, e) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(item);</span><br><span class="line">                  &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    list &amp;&amp; list.length &gt; <span class="number">0</span> &amp;&amp; list.map(<span class="function">(<span class="params">listItem, index</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> &lt;Item className='demo-list-item'</span><br><span class="line">                                     value=&#123;listItem&#125;</span><br><span class="line">                                     key=&#123;index&#125;</span><br><span class="line">                        &gt;</span><br><span class="line">                            &#123;JSON.stringify(listItem)&#125;</span><br><span class="line">                        &lt;/Item&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;<span class="regexp">/List&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="react-router路由多层嵌套"><a href="#react-router路由多层嵌套" class="headerlink" title="react-router路由多层嵌套"></a>react-router路由多层嵌套</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在搞拓海官网的后台管理时,使用了react-router 4的路由多层嵌套配合继承、装饰器搞了一套路由页面,自我感觉还是不错的,所以我分享这一套嵌套路由配置。</p>
<p>  PS: 此页面只适用于嵌套路由,嵌套路由指的是在某一父路由下的子路由只能在此父路由下使用,其余页面不可使用。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>  首先当然是安装依赖,配置打包、编译、缓存、压缩、分割chunks入口、404重定向、开发环境热更新、生产环境抽取、本地Node服务器和多核处理等等这些,这些属于搭建前端项目生态部分,我在之前的博客当中分享过的’多种方式搭建前端项目’中提到过了,下面我们就直接上干货好了。</p>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//入口</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Layouts <span class="keyword">from</span> <span class="string">'./layouts'</span>;</span><br><span class="line"></span><br><span class="line">render(&lt;Layouts /&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类,用于嵌套路由的继承,以及各级路由承接使用</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Route&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> DocumentTitle <span class="keyword">from</span> <span class="string">'react-document-title'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseLayout</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="comment">//路由列表</span></span><br><span class="line">        routers: PropTypes.array.isRequired </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="comment">//扁平化处理之后的路由</span></span><br><span class="line">        routersTransform: []</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对路由进行扁平化处理</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    transformRouters = <span class="function">(<span class="params">routers = [], path = <span class="string">'/'</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;transformRouters = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> &#123;routersTransform = []&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        routers.forEach(<span class="function">(<span class="params">routerItem, routerIndex</span>) =&gt;</span> &#123;</span><br><span class="line">            routerItem.path = <span class="string">`<span class="subst">$&#123;path&#125;</span>/<span class="subst">$&#123;routerItem.path&#125;</span>`</span>.replace(<span class="regexp">/[\/]+/g</span>, <span class="string">'/'</span>);</span><br><span class="line">            routersTransform = [...routersTransform, routerItem];</span><br><span class="line">            routerItem.children &amp;&amp; routerItem.children.length &gt; <span class="number">0</span> &amp;&amp; transformRouters(routerItem.children, routerItem.path);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> routersTransform;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        查找当前页面路径,并返回地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    searchMatch = <span class="function">(<span class="params">routers = [], pathname = <span class="string">'/'</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;searchMatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> routers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item.path.includes(pathname)) &#123;</span><br><span class="line">                <span class="keyword">return</span> item.title;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> item.children &amp;&amp; item.children.length &gt; <span class="number">0</span> &amp;&amp; searchMatch(item.children, pathname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        获取页面的标题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    getPageTitle = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;routers = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">const</span> &#123;<span class="attr">history</span>: &#123;<span class="attr">location</span>: &#123;pathname = <span class="string">''</span>&#125;&#125;&#125; = props;</span><br><span class="line">        <span class="keyword">const</span> &#123;searchMatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> searchMatch(routers, pathname);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;routers = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="comment">//这里用于不嵌套路由时使用</span></span><br><span class="line">        <span class="comment">// _routers = [];</span></span><br><span class="line">        <span class="comment">// const &#123;transformRouters = () =&gt; &#123;&#125;&#125; = this;</span></span><br><span class="line">        <span class="comment">// _routers = transformRouters([...routers]);</span></span><br><span class="line">        <span class="comment">// return _routers &amp;&amp; _routers.length &gt; 0 &amp;&amp; _routers.map(routerItem =&gt; &#123;</span></span><br><span class="line">        <span class="keyword">return</span> routers &amp;&amp; routers.length &gt; <span class="number">0</span> &amp;&amp; routers.map(<span class="function"><span class="params">routerItem</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;Route </span><br><span class="line">                key=&#123;routerItem.key&#125;</span><br><span class="line">                path=&#123;routerItem.path&#125;</span><br><span class="line">                exact=&#123;routerItem.exact&#125;</span><br><span class="line">                component=&#123;(props)=&gt; &#123;</span><br><span class="line">                    const Component = routerItem.component;</span><br><span class="line">                    return &lt;DocumentTitle&gt;</span><br><span class="line">                        &lt;Component &#123;...props&#125; routers=&#123;routerItem.children&#125; /&gt;</span><br><span class="line">                    &lt;/DocumentTitle&gt;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BaseLayout;</span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../pages/home'</span>;</span><br><span class="line"><span class="keyword">import</span> Master <span class="keyword">from</span> <span class="string">'../pages/master'</span>;</span><br><span class="line"><span class="comment">//路由静态配置</span></span><br><span class="line"><span class="keyword">const</span> routers = [&#123;</span><br><span class="line">    key: <span class="string">'home'</span>,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    title: <span class="string">'拓海官网 - 首页'</span>,</span><br><span class="line">    name: <span class="string">'首页'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    key: <span class="string">'master'</span>,</span><br><span class="line">    path: <span class="string">'/master'</span>,</span><br><span class="line">    title: <span class="string">'拓海官网 - 主子'</span>,</span><br><span class="line">    name: <span class="string">'主子'</span>,</span><br><span class="line">    component: Master</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    routers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Layout&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> BaseLayout <span class="keyword">from</span> <span class="string">'./base'</span>;</span><br><span class="line"><span class="keyword">import</span> Headers <span class="keyword">from</span> <span class="string">'./header'</span>;</span><br><span class="line"><span class="keyword">import</span> routers <span class="keyword">from</span> <span class="string">'../routers'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">'../utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Header, Content&#125; = Layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口处,使用class继承方式</span></span><br><span class="line"><span class="comment">//装饰器导入路由配置</span></span><br><span class="line">@utils.packageApi.decorators.getRouters(&#123;routers&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layouts</span> <span class="keyword">extends</span> <span class="title">BaseLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="comment">//路由列表</span></span><br><span class="line">        routers: PropTypes.array.isRequired</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;routers = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="comment">//这里用于不嵌套路由时使用</span></span><br><span class="line">        <span class="comment">// _routers = [];</span></span><br><span class="line">        <span class="comment">// const &#123;transformRouters = () =&gt; &#123;&#125;&#125; = this;</span></span><br><span class="line">        <span class="comment">// _routers = transformRouters([...routers]);</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Layout&gt;</span><br><span class="line">                &lt;Header&gt;</span><br><span class="line">                    &#123;<span class="comment">/*&lt;Headers routers=&#123;_routers&#125; /&gt;*/</span>&#125;</span><br><span class="line">                    &lt;Headers routers=&#123;routers&#125; /&gt;</span><br><span class="line">                &lt;<span class="regexp">/Header&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Content&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">                        &#123;super.render()&#125;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">                &lt;<span class="regexp">/Content&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Layout&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Layouts;</span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">//decorators 装饰器</span></span><br><span class="line"><span class="comment">//高阶函数 属性代理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRouters</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrapperComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">            state = &#123;</span><br><span class="line">                innerParams: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                    innerParams: &#123;...params&#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;   </span><br><span class="line">                </span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;innerParams&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;WrapperComponent &#123;...innerParams&#125; /&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    getRouters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Menu&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NavLink&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Item&#125; = Menu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头部路由导航</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Headers</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="comment">//路由列表</span></span><br><span class="line">        routers: PropTypes.array.isRequired</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;routers = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Menu&gt;</span><br><span class="line">                &#123;routers &amp;&amp; routers.length &gt; <span class="number">0</span> &amp;&amp; routers.map(<span class="function">(<span class="params">routerItem</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (&lt;Item key=&#123;routerItem.key&#125;&gt;</span><br><span class="line">                        &lt;NavLink to=&#123;routerItem.path&#125;&gt;</span><br><span class="line">                            &#123;routerItem.name&#125;</span><br><span class="line">                        &lt;/NavLink&gt;</span><br><span class="line">                    &lt;/Item&gt;)</span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;<span class="regexp">/Menu&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Headers;</span></span><br></pre></td></tr></table></figure>
<p>  自此react-router路由多层嵌套配置完成,如果想要只在某一路由下使用子路由,重复第2、4、6步即可。</p>
<p>  PS:附上我的目录结构图</p>
<p>  <img src="/images/routersConfig.png" alt></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-微信小程序</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  在开发虎芽足球小程序的过程中,发现有一些布局会造成页面闪动,比如有一张图片和一段文字需要上下左右居中,由于图片需要请求,无论是本地加载还是线上加载,所以用flex布局时,在图片还在请求加载时,文字是上下左右居中的,而图片请求加载成功时,图片会显示出来,文案会不再在原来的位置,所以会有这么一个闪动的bug。</p>
<blockquote>
<p>方案</p>
</blockquote>
<p>  使用一个开关变量,控制除了图片之外的段落、文案或者是整块儿内容,开始隐藏,使用Image标签的onload事件,等待图片加载完成显示之后,再将图片之外的段落、文案或者是整块儿内容显示出来。</p>
<h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  在开发虎芽足球小程序的过程中,发现当图片体积过大时,比如3M或者4M的图片,电脑开发者工具不会出现任何问题,但是在手机预览的小程序加载过程中,会造成页面白屏,甚至是闪退;</p>
<p>  后来发现是因为图片占据了小程序甚至是微信大量的内存,导致页面闪屏,最后微信也承受不住,导致闪退;</p>
<p>  最后发现小程序最多能承受图片体积的大小为500kb。</p>
<blockquote>
<p>方案</p>
</blockquote>
<ol>
<li>后台系统上传图片体积大小做限制,图片最大只能传500kb</li>
<li>前端小程序图片压缩做处理,添加阿里OSS后缀进行图片的缩放、剪切以及像素的压缩</li>
</ol>
<h2 id="登录-并与后端服务器接口建立会话"><a href="#登录-并与后端服务器接口建立会话" class="headerlink" title="登录,并与后端服务器接口建立会话"></a>登录,并与后端服务器接口建立会话</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近发现不少的小程序项目都存在入口app.js使用storage本地存储后端服务器接口返回的set-cookie建立用户会话,由于大部分用的都是异步storage本地存储(setStorageSync getStorageSync),导致当进入页面时,去请求接口获取存储的cookie时,发现并不能获取到。因为实际上这时候异步本地存储并没有存储下来,且项目和页面的渲染生命周期又是同步的,所以导致了此问题。</p>
<blockquote>
<p>方案</p>
</blockquote>
<p>  我之前也遇到这种问题,不论是在原生的微信小程序还是taro 微信小程序框架里面,我总体的方案是,将登录以及与后端服务器建立会话的接口放在页面的入口做,比如小程序在普通编译时,默认进入的页面(就是入口)放入登录和会话接口,这时候既将set-cookie值放入异步storage本地存储中,又将set-cookie值放入当前入口页面的某一个状态中,并做同步处理(这时候你应该懂了)。</p>
<p>  在Taro中,我们既可以放入state状态中,并将下一步调用的接口放入setState方法的第二个同步方法参数中;又可以放入redux store页面状态中,并做async await或者yield *同步处理。</p>
<h2 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h2><blockquote>
<p>详情</p>
</blockquote>
<p>  最近在开发虎芽小程序时,有获取用户手机号的需求,原以为和获取用户信息一样,只要通过按钮getUserInfo授权,并存入数据库,就可一劳永逸,后来发现getUserInfo授权并不能获取用户的手机号,还需要通过按钮getPhoneNumber授权,且还需要与后台配合解密,才能获取真正的手机号。</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-css</title>
    <url>/2020/03/02/%E6%AF%94%E6%9C%A8%E7%99%BD-css/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="文字两端对齐"><a href="#文字两端对齐" class="headerlink" title="文字两端对齐"></a>文字两端对齐</h2>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: justify;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h2>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动端适配rem"><a href="#移动端适配rem" class="headerlink" title="移动端适配rem"></a>移动端适配rem</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在写CBA m站官网适配,使用了cssnano和postcss-px2rem两个外部依赖包,将px直接转化为rem,这时候会发现字体大小(font-size)不能直接转为rem,因为随着手机屏幕的变化,字体有时候会很大,有时候会很小,是不一致的,边距、布局、边框甚至圆角都可以直接转为rem,但是字体大小等一些固定统一的部分,就不需要转rem了。</p>
<blockquote>
<p>使用</p>
</blockquote>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>; <span class="comment">/*no*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    类似于使用/*no\*\/这样将不需要转化为rem的部分添加上后缀,第三方依赖包就不会将px转化为rem了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="IOS-h5-overflow-hidden失效"><a href="#IOS-h5-overflow-hidden失效" class="headerlink" title="IOS h5 overflow:hidden失效"></a>IOS h5 overflow:hidden失效</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在写CBA m站官网适配,期间有一个问题,就是设置了body的overflow-x:hidden,没办法将溢出的部分隐藏;业务是这样的,我这边使用了swiper轮播图的组件,导致在手机端的viewport溢出屏幕好多,而且还可以滑动,所以我就直接在body上面添加了width:100%;overflow-x:hidden;的样式,以为这样就可以将溢出屏幕的部分隐藏。</p>
<p>  后来才发现,苹果手机上面还是会出现这个问题,当时我就诧异了,经过一番的查找之后,发现原来苹果手机的浏览器的机制就认为所有的viewport就应该展示出来,body是继承自viewport的样式配置的,而想要改变viewport,就必须先改变html的样式配置。</p>
<p>  原因是viewport是作用于html的样式配置的,所以首先要配置html width:100%;overflow-x:hidden;的样式,使body不再继承自viewport的样式配置,之后再在body上面添加width:100%;overflow-x:hidden;的样式。</p>
<blockquote>
<p>详情</p>
</blockquote>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-音频和视频</title>
    <url>/2020/03/22/%E6%AF%94%E6%9C%A8%E7%99%BD-%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h1 id="音频与视频"><a href="#音频与视频" class="headerlink" title="音频与视频"></a>音频与视频</h1><h2 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在写虎扑足球”战疫”期间,接触音频audio bgm在页面上播放、暂停和停止的功能,在react里面使用了纯的原生的元素标签,但是发现了一些问题,autoPlay属性自动播放并不能每一次刷新页面都会立即播放,而是自动播放的次数极少,后来发现原来是<a href="https://gamedev.stackexchange.com/questions/163365/html5-games-play-failed-because-the-user-didnt-interact-with-the-document-fi" target="_blank">用户不希望在打开网页之后,自动播放视频或者音频,他们希望自己能手动选择。</a>于是就选择了,不进行自动播放,一开始进入页面,音频是关着的,用户手动选择播放与否。</p>
<blockquote>
<p>使用</p>
</blockquote>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AudioBg <span class="keyword">from</span> <span class="string">'../assets/audio'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);<span class="keyword">this</span>.audio = <span class="literal">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    state = &#123;</span><br><span class="line">        isPlay: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        用户手动选择播放与否,播放或者暂停</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    onClickHandler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;isPlay = <span class="literal">false</span>&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            isPlay: !isPlay</span><br><span class="line">        &#125;, ()=&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPlay) &#123;</span><br><span class="line">                <span class="comment">//音频播放</span></span><br><span class="line">                <span class="keyword">this</span>.audio.play();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//音频暂停</span></span><br><span class="line">                <span class="keyword">this</span>.audio.pause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//取消冒泡事件</span></span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        如果音频播放完,则将其播放的时间调至开头,再次进行播放</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    onEndedHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.audio.currentTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.audio.play();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;onClickHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, onEndedHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;button onClick=&#123;onClickHandler&#125;&gt;点击播放/暂停&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;audio src=&#123;AudioBg&#125; </span></span><br><span class="line"><span class="regexp">                       loop=&#123;false&#125; </span></span><br><span class="line"><span class="regexp">                       autoPlay=&#123;false&#125; </span></span><br><span class="line"><span class="regexp">                       ref=&#123;refs =&gt; this.audio = refs&#125;</span></span><br><span class="line"><span class="regexp">                       onEnded=&#123;onEndedHandler&#125;</span></span><br><span class="line"><span class="regexp">                &gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>audio&gt;</span><br><span class="line">            &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;    </span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> export default Demo;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>audio and video</category>
      </categories>
      <tags>
        <tag>audio</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>think of testing</title>
    <url>/2022/05/29/thinkoftesting/</url>
    <content><![CDATA[<h1 id="测试-testing"><a href="#测试-testing" class="headerlink" title="测试(testing)"></a>测试(testing)</h1><h2 id="跨终端手动测试"><a href="#跨终端手动测试" class="headerlink" title="跨终端手动测试"></a>跨终端手动测试</h2><h3 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h3><blockquote>
<p><a href="https://www.lambdatest.com/" target="_blank" rel="noopener">lambdaTest</a></p>
</blockquote>
<ul>
<li><p>手动测试</p>
<ul>
<li><p><a href="https://app.lambdatest.com/console/realtime" target="_blank" rel="noopener">Browser Testing</a>.</p>
<p>可在线在不同的浏览器种类、版本、操作系统以及分辨率对website进行实时交互式测试,每次真实浏览器sessions可测试10分钟.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>可切换配置浏览器种类、版本、操作系统以及分辨率;</li>
<li>可在线录屏、截图(录屏、截图可下载);</li>
<li>可在线标记bug(编辑bug截图、下载bug截图以及上传到lambdaTest合作的SLACK、JIRA和ASANA项目管理系统);</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://app.lambdatest.com/console/realtime" target="_blank" rel="noopener">App Testing</a>.</p>
<p>可在线自由搭配不同的品牌手机、版本设备对App包或者App Url进行实时交互式测试,每次真机测试sessions可测试10分钟.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>可切换配置品牌手机以及版本设备;</li>
<li>可在线录屏、截图(录屏、截图可下载);</li>
<li>可在线标记bug(编辑bug截图、下载bug截图以及上传到lambdaTest合作的SLACK、JIRA和ASANA项目管理系统);</li>
<li>可下载新的上传的App、移除任意App.</li>
<li>可在线查看网络日志、App日志以及设备日志;</li>
</ul>
</li>
</ul>
</li>
<li><p>Browser Testing开发环境在线测试.</p>
<p>可配合lambdaTest桌面应用(LT_Windows or LT_Macs)配合在线网站进行开发环境在线测试.</p>
<ul>
<li><p>配置.</p>
<p><a href="https://www.lambdatest.com/support/docs/testing-locally-hosted-pages/" target="_blank" rel="noopener">Browser Testing开发环境在线测试视频</a>.</p>
</li>
</ul>
</li>
<li><p>结论.</p>
<ul>
<li>简洁、易用且容易理解;</li>
<li>功能完备,在线随时切换终端设备配置、录屏下载、Debug标记应有尽有;</li>
<li>测试过程流畅、无障碍性困难;</li>
<li>其合作生态成熟且完备,例如其合作的一套项目管理系统SLACK、JIRA和ASANA;</li>
<li>为测试人员大大提高了效率,节约了时间成本;</li>
<li>开放的终端设备可重复使用;</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>大部分终端设备不开放.</li>
<li>每个部分(Browser Testing or App Testing)体验时长不能超过30分钟.</li>
<li>终端设备开放、永久使用需要付费.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.browserstack.com/" target="_blank" rel="noopener">browserstack</a></p>
</blockquote>
<ul>
<li><p><a href="https://live.browserstack.com/dashboard#os=android&os_version=10.0&device=OnePlus+7T&device_browser=chrome&zoom_to_fit=true&full_screen=true&url=https%3A%2F%2Fwww.google.com%2F%3Fgws_rd%3Dssl&speed=1" target="_blank" rel="noopener">Browser Testing</a>.</p>
<p>可在线在不同的浏览器种类、版本、操作系统以及分辨率对website进行实时交互式测试,每次真实浏览器sessions可测试1分钟.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>可切换配置浏览器种类、版本、操作系统以及分辨率;</li>
<li>可在线标记bug(编辑bug截图、下载bug截图以及上传到Email、Github、browserstack合作的SLACK、JIRA和TRELLO项目管理系统);</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://app-live.browserstack.com/#os=iOS&os_version=14.0&zoom_to_fit=true&full_screen=true&speed=1" target="_blank" rel="noopener">App Testing</a>.</p>
<p>可在线自由搭配不同的品牌手机、版本设备对App包或者App Url进行实时交互式测试,每次真机测试sessions可测试无限制.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>可切换配置品牌手机以及版本设备;</li>
<li>可在线录屏、截图(录屏、截图可下载);</li>
<li>可在线标记bug(编辑bug截图、下载bug截图以及上传到Email、Github、browserstack合作的SLACK、JIRA和TRELLO项目管理系统);</li>
<li>可下载新的上传的App、移除任意App.</li>
<li>可切换手机语言配置.</li>
<li>可在线查看网络日志、App日志以及设备日志;</li>
</ul>
</li>
</ul>
</li>
<li><p>Browser Testing开发环境在线测试.</p>
<p>可配合browserstack桌面应用(BrowserStackLocal.exe or BrowserStackLocal.dmg)配合在线网站进行开发环境在线测试.</p>
<ul>
<li><p>配置.</p>
<p><a href="https://www.browserstack.com/docs/live/local-testing/test-using-local-testing" target="_blank" rel="noopener">Browser Testing开发环境在线测试视频</a>.</p>
</li>
</ul>
</li>
<li><p>结论.</p>
<ul>
<li>简洁、易用且容易理解;</li>
<li>功能比较完备,在线随时切换终端设备配置、Debug标记;</li>
<li>测试过程流畅、无障碍性困难;</li>
<li>其合作生态成熟且完备,例如Email、Github和browserstack合作的SLACK、JIRA和TRELLO项目管理系统;</li>
<li>为测试人员大大提高了效率,节约了时间成本;</li>
<li>大部分浏览器设备开放,可进行体验.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>体验时间过短,每次真实浏览器sessions只能测试1分钟.</li>
<li>App Testing体验时长不能超过30分钟.</li>
<li>终端设备开放、永久使用需要付费.</li>
<li>超过体验时间,不可重复体验开放的同一浏览器.</li>
</ul>
</li>
</ul>
<h2 id="跨终端自动化测试"><a href="#跨终端自动化测试" class="headerlink" title="跨终端自动化测试"></a>跨终端自动化测试</h2><ul>
<li><p>自动化测试</p>
<ul>
<li><p>WebDriver.</p>
<p>WebDriver是W3C的一个标准,是一个远程控制协议,提供操纵浏览器的方式,提供访问操作DOM的API.</p>
<ul>
<li><p>工作过程.</p>
<p><a href="https://blog.csdn.net/ant_ren/article/details/7970793" target="_blank" rel="noopener">WebDriver的工作过程</a>.</p>
</li>
<li><p>衍生.</p>
<p>Selenium、Appium都是基于WebDriver协议并进行了扩展,属于WebDriver的衍生品.</p>
</li>
</ul>
</li>
<li><p>浏览器自动化测试工具.</p>
<ul>
<li><p>Selenium.</p>
<p>Selenium是浏览器自动化测试工具领域最为流行的一种测试套件.</p>
<ul>
<li>Selenium支持多浏览器平台(Chrome、Firefox、IE、Opera、Safari等);</li>
<li>Selenium开发支持多语言(python、java、ruby、js、c#等);</li>
<li>Selenium的Remote Control可以通过录制用户的操作,来简化Web测试人员的各项重复作业;</li>
<li>Selenium的Grid具有编写、运行和并行处理测试的功能;</li>
<li>Selenium的Core则是基于JsUnit,完全由JavaScript所编写,因此可以被运行在各种支持JavaScript的主流浏览器之上;</li>
<li>Selenium开源免费;</li>
</ul>
</li>
<li><p>Selenium IDE.</p>
<p>Selenium IDE能够以插件的形式被安装到测试者的浏览器中,从而方便地实现Web界面的测试,是最为流行的一种可视化、自动化测试工具.</p>
</li>
<li><p>selenium-webdriver.</p>
<p>浏览器自动化库,提供了许多浏览器自动化接口,用于测试web应用.</p>
<ul>
<li><p>api.</p>
<p><a href="https://www.selenium.dev/selenium/docs/api/javascript/" target="_blank" rel="noopener">selenium-webdriver</a>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>App自动化测试工具.</p>
<ul>
<li><p>Appium.</p>
<p>Appium是一个开源的,适用于原生或混合移动应用(hybrid mobile apps)的自动化测试工具.</p>
</li>
<li><p>Appium特性.    </p>
<ul>
<li>Appium支持多App平台(Android、iOS等);</li>
<li>Appium支持多语言(python、java、ruby、js、c#等),Appium选择了Client/Server的设计模式,只要client能够发送http请求给server,那么client用什么语言来实现都是可以的,这就是如何做到支持多语言的原因;</li>
<li>Appium是跨平台的,可以用在OSX，Windows以及Linux桌面系统上运行;</li>
<li>Appium扩展了WebDriver的协议,这样的好处是以前的WebDriver API能够直接被继承过来,以前的WebDriver各种语言的binding都可以拿来就用,省去了为浏览器、App端各开发一个client的工作量;</li>
<li>Appium开源免费;</li>
</ul>
</li>
<li><p>Appium框架组成.</p>
<p><img src="https://image.white-than-wood.zone/appium/content.png" alt></p>
</li>
<li><p>Appium通信原理.</p>
<p>Client端运行Webdriver协议的机器发送自动化指令给Appium server,Appium Server接收到client发送的指令后,转换为移动端能够识别的指令,然后发送给移动端设备,并对移动端设备进行操作.</p>
</li>
<li><p>Appium整体流程.</p>
<p><img src="https://image.white-than-wood.zone/appium/tenet.png" alt></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="平台-1"><a href="#平台-1" class="headerlink" title="平台"></a>平台</h3><blockquote>
<p><a href="https://www.lambdatest.com/" target="_blank" rel="noopener">lambdaTest</a></p>
</blockquote>
<ul>
<li><p>lambdaTest配合Selenium IDE.</p>
<p><a href="https://www.lambdatest.com/support/docs/run-selenium-ide-tests-on-lambdatest-selenium-cloud-grid/" target="_blank" rel="noopener">Run Selenium IDE Tests with LambdaTest Selenium Grid</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>API、技术文档完备,引导配置成熟.</li>
<li>可视化编辑测试用例流畅并且效果顶级;</li>
<li>支持多语言编写测试用例(python、java、ruby、js、PHP、c#等).</li>
<li>与lambdaTest配合相得益彰,做到了跨浏览器自动化可视化测试完备且成熟的流程.</li>
<li>录制操作、编写测试用例二合一,既考虑了定制性、精确性,也考虑了自动化、可视化和灵活性.</li>
<li>测试报告: 截图、录屏、网络日志、Selenium日志、浏览器日志、浏览器参数以及终端日志俱有.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>无产品文档,无法直观具体了解产品.</li>
<li>测试报告中有一些不完整,如性能报告.</li>
</ul>
</li>
</ul>
</li>
<li><p>selenium-webdriver、jest配合lambdaTest.</p>
<p><a href="https://www.lambdatest.com/support/docs/automation-testing-with-selenium-and-jest/" target="_blank" rel="noopener">Jest with Selenium: Tutorial to Run Your First Test on LambdaTest</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>API、技术文档完备,引导配置成熟.</li>
<li>支持多语言编写测试用例(python、java、ruby、js、PHP、c#等).</li>
<li>测试报告: 截图、录屏、网络日志、Selenium日志、浏览器日志、浏览器参数以及终端日志俱有.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>在线平台不保存测试用例,也不集成测试套件,只能进行线下编辑测试用例,没有做到完全自动化可视化测试.</li>
<li>无产品文档,无法直观具体了解产品.</li>
<li>测试报告中有一些不完整,如性能报告.</li>
</ul>
</li>
</ul>
</li>
<li><p>lambdaTest配合Appium.</p>
<p><a href="https://www.lambdatest.com/support/docs/appium-nodejs-webdriverio/" target="_blank" rel="noopener">WebDriverIO With Appium in lambdaTest</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>API、技术文档完备,引导配置成熟.</li>
<li>支持多语言编写测试用例(python、java、ruby、js、PHP、c#等).</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>真机跨终端自动化测试需要付费,无法体验产品.</li>
<li>无产品文档,无法直观具体了解产品.</li>
</ul>
</li>
</ul>
</li>
<li><p>Visual UI Testing.</p>
<p><a href="https://app.lambdatest.com/console/screenshot" target="_blank" rel="noopener">Visual UI Testing Screenshot</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>可实行多终端UI截图,并可实现对比.</li>
<li>可下载、分享截图或者截图列表压缩包.</li>
<li>可配置各终端的分辨率以及布局.</li>
<li>可预定日程(每天、每个周、每个月)进行截图.</li>
<li>根据账号保存每次截图列表历史.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>不可实行本地终端UI截图.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.aliyun.com/product/mqc" target="_blank" rel="noopener">阿里云移动测试</a></p>
</blockquote>
<ul>
<li><p>阿里云移动测试配合Appium.</p>
<p><a href="https://help.aliyun.com/document_detail/175761.html" target="_blank" rel="noopener">阿里云移动测试产品文档</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>API、技术文档完备,引导配置成熟.</li>
<li>集成Appium IDE于阿里云平台内部,做到可视化、自动化测试.</li>
<li>录制、编写测试用例二合一,做到了跨浏览器自动化可视化测试完备且成熟的流程.</li>
<li>产品文档完备,可直观了解产品.</li>
<li>测试报告:截图、录屏、测试用例日志、Appium日志、移动设备日志、错误日志以及性能报告一应俱全.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>只支持Python编写测试用例.</li>
<li>测试报告中有一些不完整,如网络日志.</li>
</ul>
</li>
</ul>
</li>
<li><p>Visual UI Testing.</p>
<p>无Visual UI Testing功能.</p>
</li>
</ul>
<blockquote>
<p><a href="https://www.browserstack.com/" target="_blank" rel="noopener">browserstack</a>    </p>
</blockquote>
<ul>
<li><p>browserstack配合Appium.</p>
<p><a href="https://www.browserstack.com/docs/app-automate/appium/getting-started/nodejs/webdriverio" target="_blank" rel="noopener">WebDriverIO With Appium in browserstack</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>API、技术文档完备,引导配置成熟.</li>
<li>支持多语言编写测试用例(python、java、ruby、js、PHP、c#等).</li>
<li>做到了跨浏览器自动化测试比较完备且成熟的流程.</li>
<li>测试报告: 截图、录屏、网络日志、Appium日志、移动设备日志以及性能报告应有尽有.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>在线平台不保存测试用例,也不集成测试套件,只能进行线下编辑测试用例,没有做到完全自动化可视化测试.</li>
<li>测试报告中有一些不完整,如测试用例日志,需要在命令行中查看.</li>
<li>产品文档有欠缺,急需补足.</li>
</ul>
</li>
</ul>
</li>
<li><p>Visual UI Testing.</p>
<p><a href="https://www.browserstack.com/screenshots" target="_blank" rel="noopener">Visual UI Testing Screenshot</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>可进行多终端UI截图,进行对比.</li>
<li>可下载、分享截图或者截图列表压缩包.</li>
<li>根据账号保存每次截图列表历史.</li>
<li>可配置各终端的分辨率以及布局.</li>
<li>可实行本地终端UI截图.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>配置各终端的分辨率以及布局需付费.</li>
<li>不可预定日程(每天、每个周、每个月)进行截图.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://saucelabs.com/" target="_blank" rel="noopener">sauceLabs</a></p>
</blockquote>
<ul>
<li><p>sauceLabs配合Appium.</p>
<p><a href="https://github.com/saucelabs-training/demo-js/tree/main/webdriverio/appium-app/examples/simple-example" target="_blank" rel="noopener">WebDriverIO With Appium in sauceLabs</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>支持多语言编写测试用例(python、java、ruby、js、PHP、c#等).</li>
<li>做到了跨浏览器自动化测试比较完备且成熟的流程.</li>
<li>测试报告: 截图、录屏、网络日志、Appium日志以及移动设备日志俱有.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>Simple Demo冗杂耦合在一起,下载很慢,且很乱.</li>
<li>API、技术文档无任何引导,且比较简陋.</li>
<li>无产品文档,无法直观具体了解产品.</li>
<li>在线平台不保存测试用例,也不集成测试套件,只能进行线下编辑测试用例,自动化可视化测试能力不足.</li>
<li>测试报告中有一些不完整,如测试用例日志,需要在命令行中查看.</li>
</ul>
</li>
</ul>
</li>
<li><p>Visual UI Testing.</p>
<p>无Visual UI Testing功能.</p>
</li>
</ul>
<blockquote>
<p><a href="https://crossbrowsertesting.com" target="_blank" rel="noopener">CrossBrowserTesting</a></p>
</blockquote>
<ul>
<li><p>CrossBrowserTesting配合Appium.</p>
<p><a href="https://crossbrowsertesting.com/automated-testing/appium" target="_blank" rel="noopener">NodeJS With Appium in CrossBrowserTesting</a>.</p>
<ul>
<li><p>结论.</p>
<ul>
<li>支持多语言编写测试用例(python、java、ruby、js、PHP、c#等).</li>
<li>做到了跨浏览器自动化测试比较完备且成熟的流程.</li>
<li>测试报告: 截图、录屏、网络日志、Appium日志以及移动设备日志俱有.</li>
</ul>
</li>
<li><p>问题.</p>
<ul>
<li>API、技术文档无任何引导,且比较简陋.</li>
<li>无产品文档,无法直观具体了解产品.</li>
<li>在线平台不保存测试用例,也不集成测试套件,只能进行线下编辑测试用例,没有做到完全自动化可视化测试.</li>
<li>测试报告中有一些不完整,如测试用例日志,需要在命令行中查看.</li>
</ul>
</li>
</ul>
</li>
<li><p>Visual UI Testing.</p>
<p>无Visual UI Testing功能.</p>
</li>
</ul>
<blockquote>
<p><a href="https://www.aznfz.com/" target="_blank" rel="noopener">冰狐智能辅助</a></p>
</blockquote>
<p>  不使用Appium,有自己开发的一套移动端自动化测试工具.</p>
<p>  <a href="https://www.aznfz.com/mobile-terminal/about" target="_blank" rel="noopener">冰狐智能辅助 - 移动端</a>.</p>
<ul>
<li><p>问题.</p>
<ul>
<li>只适用Android自动化测试.</li>
<li>需要开发者自己准备设备,无在线真机调试,没有做到在线跨终端测试.</li>
<li>只支持Javascript编写测试用例.</li>
<li>在线平台不保存测试用例,也不集成测试套件,只能进行线下编辑测试用例,自动化可视化测试能力非常欠缺.</li>
<li>无产品概念,无测试报告,只是单一的一种工具.</li>
</ul>
</li>
</ul>
<ul>
<li><p>Visual UI Testing.</p>
<p>无Visual UI Testing功能.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>testing</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-Webpack</title>
    <url>/2020/02/27/%E6%AF%94%E6%9C%A8%E7%99%BD-Webpack/</url>
    <content><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="ContextReplacementPlugin"><a href="#ContextReplacementPlugin" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h2><blockquote>
<p>详情</p>
</blockquote>
<p>  taro小程序升级至2.0版本之后,由于transform-runtime按需打包的插件加入,导致taro小程序的包超过2M,通过webpack-bundle-analyzer查看每个模块体积的大小插件,可以看到moment.js以及其语言包占了差不多600kb-700kb的体积,所以需要将语言包剔除不需要的,只保留zh-CN中文包,这里需要使用到ContextReplacementPlugin,将不需要的依赖包不打入包内,进行剔除掉,做到按需打包。</p>
<blockquote>
<p>使用</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是webpack,则是要在webpack.config.js中的plugin里面配置</span></span><br><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">"webpack"</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.ContextReplacementPlugin(<span class="regexp">/moment\/\\locale$/</span>, /zh-cn/);</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是taro,这种使用react对接多端的框架,则是使用webpackChain</span></span><br><span class="line"><span class="comment">//2.0.0配置,config目录下的index.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mini: &#123;</span><br><span class="line">        webpackChain(chain, webpack) &#123;</span><br><span class="line">            chain.plugin(<span class="string">'contextReplacement'</span>).use(<span class="keyword">new</span> webpack.ContextReplacementPlugin(<span class="regexp">/moment[\/\\]locale/</span>, /zh-cn/), []);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h2><blockquote>
<p>详情</p>
</blockquote>
<p>  UglifyJsPlugin用于压缩、缓存和删除一些无用、注释的代码的作用。之前是放于webpack内部plugins插件数组里面的,webpack 4之后是将UglifyJsPlugin作为一个单独的插件抽取了出来,并把位置从plugins属性数组放入至optimization优化属性里面。</p>
<p>  最近在CBA移动端m站适配,还出现了IOS 10.13.1系统的苹果手机,打开缓存、压缩以及删除注释后的打包代码,页面打不开的情况,发现需要配置UglifyWebpackPlugin里面的uglifyOptions,添加mangle属性,并将safari10的内部属性设置为true。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>  普通配置如下(也是我这边使用的):</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                <span class="comment">//是否启用缓存文件机制</span></span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">//是否启用多核进行压缩文件</span></span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                uglifyOptions: &#123;</span><br><span class="line">                    output: &#123;</span><br><span class="line">                        <span class="comment">//这里将除了@license之外的注释全都剔除掉</span></span><br><span class="line">                        comments: <span class="regexp">/@license/i</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    mangle: &#123;</span><br><span class="line">                        safari10: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,   </span><br><span class="line">                <span class="comment">//是否剔除注释</span></span><br><span class="line">                extractComments: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<p>  uglifyjs-webpack-plugin只支持压缩、缓存以及剔除注释ES5语法的项目文件,如果想要这些功能放到ES6语法上面,需要下载其他的第三方外部依赖包 —— terser-webpack-plugin</p>
<h2 id="TerserWebpackPlugin"><a href="#TerserWebpackPlugin" class="headerlink" title="TerserWebpackPlugin"></a>TerserWebpackPlugin</h2><blockquote>
<p>详情</p>
</blockquote>
<p>  与uglifyjs-webpack-plugin的配置、使用方式以及产生的作用基本一样,不一样的点在于,uglifyjs-webpack-plugin不能对ES6语法的项目文件进行压缩、缓存文件以及剔除注释,而terser-webpack-plugin可以。</p>
<p>  最近在CBA移动端m站适配,还出现了IOS 10.13.1系统的苹果手机,打开缓存、压缩以及删除注释后的打包代码,页面打不开的情况,发现需要配置TerserWebpackPlugin里面的terserOptions,添加mangle属性,并将safari10的内部属性设置为true。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>  普通配置如下(也是我这边使用的):</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserWebpackPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> TerserWebpackPlugin(&#123;</span><br><span class="line">                <span class="comment">//是否启用缓存文件机制</span></span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">//是否启用多核压缩文件机制</span></span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                terserOptions: &#123;</span><br><span class="line">                    output: &#123;</span><br><span class="line">                        <span class="comment">//除了含有@license的注释,其余都剔除掉</span></span><br><span class="line">                        comments: <span class="regexp">/@license/i</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">//用于兼容IOS 10.13.1系统的h5页面</span></span><br><span class="line">                    mangle: &#123;</span><br><span class="line">                        safari10: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//是否剔除注释</span></span><br><span class="line">                extractComments: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h2><blockquote>
<p>详情</p>
</blockquote>
<p>  CommonsChunkPlugin的优化转化类型,重点是将多个入口的公共导入部分以及第三方依赖包的公共导入部分抽出,形成多个文件,由于浏览器加载文件是异步的,且可以生成浏览器缓存文件,所以对于整个网站的性能以及加载速度都是质的提升。之前CommonsChunkPlugin也是放于webpack内部plugins插件数组里面,现在把位置从plugins属性数组放入至optimization优化属性里面。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>  普通配置如下(也是我这边使用的):</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        SplitChunks: &#123;</span><br><span class="line">            <span class="comment">//导出公共部分的文件大小最小为0byte</span></span><br><span class="line">            minSize: <span class="number">0</span>,</span><br><span class="line">            <span class="comment">//至少一个入口，将一个入口里面的公共部分导出生成另外一个js文件</span></span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            chunks: <span class="string">'all'</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                <span class="comment">//将某些体积大的第三方依赖包里面的公共导入部分导出,并命名为packageBase</span></span><br><span class="line">                packageBase: &#123;</span><br><span class="line">                    name: <span class="string">'packageBase'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    chunks: <span class="string">'initial'</span>,</span><br><span class="line">                    <span class="comment">//对应的是react、redux、react-dom、lodash、moment和antd这些体积比较大的包</span></span><br><span class="line">                    test: <span class="function">(<span class="params"><span class="built_in">module</span></span>)=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="regexp">/(react|redux|react-dom|lodash|moment|antd)/</span>.test(<span class="built_in">module</span>.context);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">//优先级为10</span></span><br><span class="line">                    priority: <span class="number">10</span>   </span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//将自己编写的某些公共导入部分导出,并命名为commons</span></span><br><span class="line">                commons: &#123;</span><br><span class="line">                    name: <span class="string">'commons'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    chunks: <span class="string">'initial'</span>,</span><br><span class="line">                    <span class="comment">//优先级为5</span></span><br><span class="line">                    priority: <span class="number">5</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何设置url-loader的图片打包生成的目录路径"><a href="#如何设置url-loader的图片打包生成的目录路径" class="headerlink" title="如何设置url-loader的图片打包生成的目录路径"></a>如何设置url-loader的图片打包生成的目录路径</h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在搞欧冠”数说”欧冠的h5项目时,遇到了一个问题:打包生成的图片,如何放至打包目录的images目录下,经过查阅资料,images的配置不仅仅有limit属性设置图片体积大小的限制来区分什么时候图片以base64显示,什么时候以打包压缩之后的图片显示,还有一个name属性,可以用来设置打包生成的目录路径以及文件名称。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>  普通配置如下(也是我这边使用的):</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [<span class="comment">//...</span></span><br><span class="line">        &#123;</span><br><span class="line">               test: <span class="regexp">/(png|bmp|jpg|jpeg|gif)$/i</span>,</span><br><span class="line">               use: [&#123;</span><br><span class="line">                  loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                  options: &#123;</span><br><span class="line">                          limit: <span class="number">102400</span>,</span><br><span class="line">                          <span class="comment">//这样就可以配置图片打包生成的目录路径以及文件名称</span></span><br><span class="line">                          <span class="comment">//注意: [name]为chunks入口的名称</span></span><br><span class="line">                          name: <span class="string">'images/[name].[hash:6].[ext]'</span>  </span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;] </span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>wbpack</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-可视化</title>
    <url>/2020/03/22/%E6%AF%94%E6%9C%A8%E7%99%BD-%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><h2 id="lt-map-与-lt-area"><a href="#lt-map-与-lt-area" class="headerlink" title="\&lt;map>与\&lt;area>"></a>\&lt;map>与\&lt;area></h2><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在写虎扑足球”战疫”期间,接触了在一张原始图上迅速寻找热点并点击弹出弹窗的功能,由于是运营活动页,时间紧任务重,于是使用了\&lt;map>与\&lt;area>标签,任意一张图片img使用useMap属性,即可用\&lt;map>与\&lt;area>标签在上面构造热区和热点,并以图上的左上角为坐标的(0,0)点,构建所有热区和热点的位置,并支持href链接跳转以及事件处理</p>
<blockquote>
<p>使用</p>
</blockquote>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> images <span class="keyword">from</span> <span class="string">'../images'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;<span class="keyword">super</span>(props);&#125;</span><br><span class="line">   </span><br><span class="line">   onClickHandler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(e);</span><br><span class="line">   &#125;;   </span><br><span class="line">   </span><br><span class="line">   render() &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123;onClickHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125; = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;&gt;</span><br><span class="line">               &lt;img src=&#123;images._1&#125; useMap=<span class="string">'#planetmap'</span> /&gt;</span><br><span class="line">               &lt;map id=<span class="string">'planetmap'</span>&gt;</span><br><span class="line">                   &lt;area shape=<span class="string">'circle'</span> coords=<span class="string">'180,139,14'</span> href=<span class="string">'javascript:void(0);'</span> onClick=&#123;onClickHandler&#125;&gt;</span><br><span class="line">                   &lt;<span class="regexp">/area&gt;</span></span><br><span class="line"><span class="regexp">               &lt;/m</span>ap&gt;</span><br><span class="line">           &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">       )</span></span><br><span class="line"><span class="regexp">   &#125;    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Demo;</span></span><br></pre></td></tr></table></figure>
<p>  具体的使用方法在<a href="https://www.w3school.com.cn/tags/tag_area.asp" target="_blank">HTML \&lt;area> 标签</a>,在属性shape为circle的情况下,此时热区为圆形,coords的坐标,前两个为x轴和y轴的位置(px),最后一个为半径的长度(px);在属性shape为rect的情况下,此时热区为长方形,coords的坐标,前两个为x轴和y轴的位置(px),后面两个为长方形的长和宽。map标签的id则是img图片标签useMap属性要使用的。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-多种方式搭建项目</title>
    <url>/2020/04/04/%E6%AF%94%E6%9C%A8%E7%99%BD-%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="express-react-webpack"><a href="#express-react-webpack" class="headerlink" title="express+react+webpack"></a>express+react+webpack</h1><blockquote>
<p>原因</p>
</blockquote>
<p>  最近在写拓海官网的后台web项目,本来是想用webpack-dev-server搭建开发环境服务器的,后来查资料发现,webpack-dev-server没有express+webpack-dev-middleware+webpack-hot-middleware灵活,且第二种方案热更新走的是内存,所以就尝试了使用第二种方案。<br>  搭建好之后,发现第二种方案用起来超级爽,既可以配置webpack,也可以灵活自由的配置express服务器和各个中间件,另外由于我们是多入口的打包(就是每次打包,只打包项目中的一部分,也就是想打包的入口页面),所以使用第二种灵活的方案很适合现有的需求。</p>
<blockquote>
<p>详情 首先我们先下载需要的进行配置的第三方外部依赖包,这些第三方外部依赖包的使用和作用会在之后介绍</p>
</blockquote>
  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli @babel/cli @babel/core babel-loader @babel/preset-env @babel/preset-react file-loader url-loader core-js style-loader css-loader postcss-loader less-loader less ts-loader extract-text-webpack-plugin@next mini-css-extract-plugin express webpack-dev-middleware webpack-hot-middleware @babel/plugin-transform-runtime @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties @babel/runtime-corejs3 @babel/runtime autoprefixer webpack-bundle-analyzer html-webpack-plugin yargs shelljs ora glob cross-env http-proxy-middleware happypack terser-webpack-plugin connect-history-api-fallback --save-dev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置babel.config.js编译文件</p>
</blockquote>
<p>  @babel/preset-env 是babel进行编译es2015语法以上的模块,这里为了兼容更老的浏览器,比如说IE8,使用了core-js模块注入到入口处,属性按需加载@babel/runtime-corejs3模块:core-js第三版本</p>
<p>  @babel/preset-react 是babel进行编译react jsx语法的模块</p>
<p>  @babel/plugin-proposal-decorators 是babel进行编译 @xxx 这种装饰器的模块</p>
<p>  @babel/plugin-proposal-class-properties 是babel进行编译 类似于js变量类型规范,比如prop-types这种第三方外部依赖包的模块</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                useBuiltIns: <span class="string">'entry'</span>,</span><br><span class="line">                corejs: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'@babel/preset-react'</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'@babel/plugin-proposal-decorators'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                legacy: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'@babel/plugin-proposal-class-properties'</span>,</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                helpers: <span class="literal">false</span>,</span><br><span class="line">                regenerator: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置多入口部分页面打包、压缩、缓存和消除所有注释</p>
</blockquote>
<p>  yargs 此模块用于传递命令行传递参数,不是以{key: ‘value’}对象的这种结构,而是使用数组的数据结构,将外部的参数以字符串的形式来传递</p>
<p>  ora 此模块使输出的命令行更有活力更有色彩更有仪式感,比如说ora().file(‘error’),如果执行到这一句,命令行就会输出 ✖ error</p>
<p>  glob 此模块将所有查到的文件以数组的数据结构,在回调函数里面呈现出来,回调函数的第一个参数err,如果找不到文件等其他错误,就会报错;第二个参数files,就是查到的文件数组</p>
<p>  shelljs 此模块在js文件中,使用此模块,可以在js语法中,使用命令行命令</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> yargs = <span class="built_in">require</span>(<span class="string">'yargs'</span>),</span><br><span class="line">    ora = <span class="built_in">require</span>(<span class="string">'ora'</span>),</span><br><span class="line">    glob = <span class="built_in">require</span>(<span class="string">'glob'</span>),</span><br><span class="line">    shelljs = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = yargs.argv._[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!params) &#123;</span><br><span class="line">    ora().succeed(<span class="string">'必须传递参数!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    glob(<span class="string">'src/**/app.jsx'</span>, (err, files) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            ora(&#123;</span><br><span class="line">                color: <span class="string">'red'</span></span><br><span class="line">            &#125;).stopAndPersist(&#123;</span><br><span class="line">                symbol: <span class="string">'✖'</span>,</span><br><span class="line">                text: <span class="string">'没有找到此文件'</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> file = files.find(<span class="function"><span class="params">item</span> =&gt;</span> item.indexOf(params) !== <span class="number">-1</span>) || <span class="string">''</span>;</span><br><span class="line">        shelljs.exec(<span class="string">`npm set TARGET <span class="subst">$&#123;file&#125;</span> &amp;&amp; node server.js`</span>);</span><br><span class="line">        ora(&#123;</span><br><span class="line">            color: <span class="string">'green'</span></span><br><span class="line">        &#125;).stopAndPersist(&#123;</span><br><span class="line">            symbol: <span class="string">'✔'</span>,</span><br><span class="line">            text: <span class="string">'开发环境服务器启动成功~'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置webpack打包开发环境</p>
</blockquote>
<p>  path 该nodejs模块用于路径导航和路径拼接等功能</p>
<p>  terser-webpack-plugin 该模块用于对js es2015语法的代码的压缩</p>
<p>  html-webpack-plugin 该模块以某一个模版引擎或者是超文本传输协议文件作为基准进行处理,将提取出来的模块(js,css,image…)等其他资源注入到其模板中</p>
<p>  happypack 该模块能够提高打包和编译的速度,使用多进程进行编译和打包,将主进程分为指定的多个分进程,当输出编译的打包时,会将多个分进程合并为一个主进程</p>
<p>  webpack-hot-middleware 该模块可以对开发环境进行资源热加载,当项目中的文件内容发生变化时,资源热加载就会生效,引起开发环境服务器的重新刷新</p>
<p>  webpack-bundle-analyzer 该模块可以查看打包之后各个入口模块资源的大小、体积、名称以及打包压缩之后的所有的特征</p>
<p>  对于开发环境的css和less等样式文件的编译、打包、缓存以及压缩,本人不推荐使用extract-text-webpack-plugin和mini-css-extract-plugin,如果进行对css和less等样式文件进行抽取,当样式文件发生改变时,查找了好多资料,也使用了很多方法,比如css-hot-loader,都不会引起资源热加载,后来发现人家是有注释的: MiniCssExtractPlugin doesn’t support HMR;For developing, use ‘style-loader’ instead.</p>
<p>  <img src="/images/notSupportHMR.png" alt></p>
<p>  说明在开发环境,mini-css-extract-plugin修改样式文件,没办法引起资源热加载.所以我们在开发环境还是使用style-loader,而在预发和生产环境使用MiniCssExtractPlugin或者ExtractTextWebpackPlugin</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>),</span><br><span class="line">    webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>),</span><br><span class="line">    HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>),</span><br><span class="line">    TerserWebpackPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>),</span><br><span class="line">    ExtractWebpackPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>),</span><br><span class="line">    MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>),</span><br><span class="line">    HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>),</span><br><span class="line">    BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PUBLIC_DIR = <span class="string">'/'</span>,</span><br><span class="line">    OUTPUT_DIR = path.resolve(__dirname, <span class="string">'../build'</span>),</span><br><span class="line">    TEMPLATE_DIR = path.resolve(__dirname, <span class="string">'../public'</span>),</span><br><span class="line">    SRC_DIR = path.resolve(__dirname, <span class="string">'../src'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TARGET = <span class="string">`./<span class="subst">$&#123;process.env.npm_config_TARGET&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">'eval'</span>,</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: [</span><br><span class="line">            <span class="comment">//在入口处配置热加载模块的客户端配置,设置资源热加载内容变化时,开发环境服务器重新刷新,目录配置则是__webpack_hmr'</span></span><br><span class="line">            <span class="string">'webpack-hot-middleware/client?path=__webpack_hmr&amp;reload=true'</span>,</span><br><span class="line">            TARGET</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        publicPath: PUBLIC_DIR,</span><br><span class="line">        filename: <span class="string">`js/[name].[hash].js`</span>,</span><br><span class="line">        path: OUTPUT_DIR</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        modules: [</span><br><span class="line">            <span class="string">'node_modules'</span>,</span><br><span class="line">            SRC_DIR</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    externals: &#123;</span><br><span class="line">        jquery: <span class="string">'jQuery'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        runtimeChunk: <span class="literal">true</span>,</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> TerserWebpackPlugin(&#123;</span><br><span class="line">                <span class="comment">//是否开启缓存机制</span></span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">//是否开启多核压缩机制</span></span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                terserOptions: &#123;</span><br><span class="line">                    output: &#123;</span><br><span class="line">                        <span class="comment">//是否删除除了含有@license意外其他所有的注释</span></span><br><span class="line">                        comments: <span class="regexp">/@license/i</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    mangle: &#123;</span><br><span class="line">                        <span class="comment">//开启对ie8浏览器的兼容</span></span><br><span class="line">                        ie8: <span class="literal">true</span>,</span><br><span class="line">                        <span class="comment">//开启对IOS 10系统的兼容</span></span><br><span class="line">                        safari10: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//是否删除所有的注释</span></span><br><span class="line">                extractComments: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'all'</span>,</span><br><span class="line">            minSize: <span class="number">0</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                base: &#123;</span><br><span class="line">                    name: <span class="string">'base'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    chunks: <span class="string">'initial'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params"><span class="built_in">module</span></span>)=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="regexp">/(react|react-dom|lodash|moment|react-router)/</span>.test(<span class="built_in">module</span>.context)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                commons: &#123;</span><br><span class="line">                    name: <span class="string">'commons'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    chunks: <span class="string">'initial'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js[x]?$/</span>,</span><br><span class="line">            include: [</span><br><span class="line">                SRC_DIR</span><br><span class="line">            ],</span><br><span class="line">            use: [</span><br><span class="line">                <span class="comment">//happypack对js以及jsx文件进行处理,id为jsx</span></span><br><span class="line">                <span class="string">'happypack/loader?id=jsx'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="comment">//在不使用style-loader的情况下,可以使用extract-text-webpack-plugin和mini-css-extract-plugin将css样式抽成文件</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                use: ExtractWebpackPlugin.extract(&#123;</span></span><br><span class="line"><span class="comment">                    fallback: 'style-loader',</span></span><br><span class="line"><span class="comment">                    use: ['happypack/loader?id=css']</span></span><br><span class="line"><span class="comment">                &#125;)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            use: [</span><br><span class="line">                <span class="comment">//MiniCssExtractPlugin.loader,</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        loader: MiniCssExtractPlugin.loader,</span></span><br><span class="line"><span class="comment">                        options: &#123;</span></span><br><span class="line"><span class="comment">                            //只在开发环境开启资源热更新</span></span><br><span class="line"><span class="comment">                            hmr: process.env.NODE_ENV === 'development',</span></span><br><span class="line"><span class="comment">                            //当热更新失效时,是否强制刷新更新资源</span></span><br><span class="line"><span class="comment">                            reloadAll: true</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">//happypack对css文件进行处理,id为css</span></span><br><span class="line">                <span class="string">'happypack/loader?id=css'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            <span class="comment">//在不使用style-loader的情况下,可以使用extract-text-webpack-plugin和mini-css-extract-plugin将less样式抽成文件</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                use: ExtractWebpackPlugin.extract(&#123;</span></span><br><span class="line"><span class="comment">                    fallback: 'style-loader',</span></span><br><span class="line"><span class="comment">                    use: ['happypack/loader?id=less']</span></span><br><span class="line"><span class="comment">                &#125;)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            use: [</span><br><span class="line">                <span class="comment">//MiniCssExtractPlugin.loader,</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        loader: MiniCssExtractPlugin.loader,</span></span><br><span class="line"><span class="comment">                        options: &#123;</span></span><br><span class="line"><span class="comment">                            //只在开发环境开启资源热更新</span></span><br><span class="line"><span class="comment">                            hmr: process.env.NODE_ENV === 'development',</span></span><br><span class="line"><span class="comment">                            //当热更新不生效时,进行强制刷新更新资源</span></span><br><span class="line"><span class="comment">                            reloadAll: true</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">//happypack对less文件进行处理,id为less</span></span><br><span class="line">                <span class="string">'happypack/loader?id=less'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpeg|jpg|gif|bmp)$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="comment">//happypack对image图片文件进行处理,id为image</span></span><br><span class="line">                <span class="comment">//'happypack/loader?id=image'</span></span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">102400</span>,</span><br><span class="line">                        name: <span class="string">'[name].[hash:6].[ext]'</span>    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;       </span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            new ExtractWebpackPlugin(&#123;</span></span><br><span class="line"><span class="comment">                filename: 'css/[name].[hash:6].css'</span></span><br><span class="line"><span class="comment">            &#125;),</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            new MiniCssExtractPlugin(&#123;</span></span><br><span class="line"><span class="comment">                filename: 'css/[name].[hash:6].css'</span></span><br><span class="line"><span class="comment">            &#125;),</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'jsx'</span>,</span><br><span class="line">            <span class="comment">//将主进程分为4个分进程进行编译和打包</span></span><br><span class="line">            threads: <span class="number">4</span>,</span><br><span class="line">            loaders: [</span><br><span class="line">                <span class="comment">//使用babel-loader对js以及jsx文件进行编译</span></span><br><span class="line">                <span class="string">'babel-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'css'</span>,</span><br><span class="line">            <span class="comment">//将主进程分为2个分进程进行编译和打包</span></span><br><span class="line">            threads: <span class="number">2</span>,</span><br><span class="line">            loaders: [</span><br><span class="line">                <span class="comment">//使用style-loader,css-loader和postcss-loader对css文件进行编译</span></span><br><span class="line">                <span class="string">'style-loader'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'postcss-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'less'</span>,</span><br><span class="line">            <span class="comment">//将主进程分为2个分进程进行编译和打包</span></span><br><span class="line">            threads: <span class="number">2</span>,</span><br><span class="line">            loaders: [</span><br><span class="line">                <span class="comment">//使用style-loader,css-loader,postcss-loader和less-loader对css文件进行编译</span></span><br><span class="line">                <span class="string">'style-loader'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'less-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">//现在还不能使用happypack去多进程打包、缓存图片等应用url-loader模块的文件,会出现base 64图片等文件加载不出来的问题,具体看下面的问题结论链接</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            new HappyPack(&#123;</span></span><br><span class="line"><span class="comment">                id: 'image',</span></span><br><span class="line"><span class="comment">                //将主进程分为4个分进程进行编译和打包</span></span><br><span class="line"><span class="comment">                threads: 4,</span></span><br><span class="line"><span class="comment">                loaders: [&#123;</span></span><br><span class="line"><span class="comment">                    //使用url-loader对image文件进行编译</span></span><br><span class="line"><span class="comment">                    loader: 'url-loader',</span></span><br><span class="line"><span class="comment">                    options: &#123;</span></span><br><span class="line"><span class="comment">                        limit: 102400,</span></span><br><span class="line"><span class="comment">                        name: '[name].[hash:6].[ext]'</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;]</span></span><br><span class="line"><span class="comment">            &#125;),</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">//注入模块(js,css,image...)等其他资源的目录路径</span></span><br><span class="line">            publicPath: PUBLIC_DIR,</span><br><span class="line">            <span class="comment">//处理的模板引擎或者是超文本传输协议文件的名称</span></span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            <span class="comment">//模板引擎或者是超文本传输协议文件的目录地址</span></span><br><span class="line">            template: <span class="string">`<span class="subst">$&#123;TEMPLATE_DIR&#125;</span>/index.ejs`</span>,</span><br><span class="line">            <span class="comment">//选择要注入的模块名称</span></span><br><span class="line">            chunks: [<span class="string">'base'</span>, <span class="string">'commons'</span>, <span class="string">'app'</span>],</span><br><span class="line">            <span class="comment">//是否将注入的模块打上hash值</span></span><br><span class="line">            hash: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">//注入到模板引擎或者是超文本传输协议文件的位置</span></span><br><span class="line">            inject: <span class="string">'body'</span>,</span><br><span class="line">            <span class="comment">//是否压缩模板引擎或者是超文本传输协议文件</span></span><br><span class="line">            minify: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">//要传入到模板引擎当中的属性变量</span></span><br><span class="line">            templateParameters: &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  PS: <a href="https://github.com/amireh/happypack/issues/240" target="_blank">url-loader配合happypack,base64图片加载不出来</a></p>
<blockquote>
<p>配置express+webpack-dev-middleware+webpack-hot-middleware开发服务器</p>
</blockquote>
<p>  express 该模块用于启动nodejs服务器,可以作为路由、请求等处理,具体文档在这儿:<a href="https://expressjs.com/zh-cn/" target="_blank">express文档</a></p>
<p>  http-proxy-middleware 该模块作为中间件,可以处理代理服务器请求,类似于webpack-dev-server devServer proxy的配置</p>
<p>  webpack-dev-middleware 该模块作为中间件,可以处理资源热加载的启动</p>
<p>  webpack-hot-middleware 该模块作为中间件,资源热加载的主要处理工具</p>
<p>  connect-history-api-fallback 该模块作为中间件,处理404路由页面,重定向至index.html</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>),</span><br><span class="line">      path = <span class="built_in">require</span>(<span class="string">'path'</span>),</span><br><span class="line">      ora = <span class="built_in">require</span>(<span class="string">'ora'</span>),</span><br><span class="line">      proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>),</span><br><span class="line">      webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>),</span><br><span class="line">      history = <span class="built_in">require</span>(<span class="string">'connect-history-api-fallback'</span>),</span><br><span class="line">      webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>),</span><br><span class="line">      webpackHotMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>),</span><br><span class="line">      dev = <span class="built_in">require</span>(<span class="string">'./config/dev'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> NODE_ENV = process.env.NODE_ENV,</span><br><span class="line">      PORT = <span class="number">8024</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> app = express();</span><br><span class="line">    </span><br><span class="line">  app.use(history(&#123;</span><br><span class="line">    <span class="comment">//此配置最至关重要,用于中间件处理覆盖所有请求头为'text/html'或者'application/xhtml+xml'的文件,其余请求头不予处理</span></span><br><span class="line">    htmlAcceptHeaders: [<span class="string">'text/html'</span>, <span class="string">'application/xhtml+xml'</span>],</span><br><span class="line">    rewrites: [&#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="regexp">/^\/.*$/</span>,</span><br><span class="line">        to: <span class="string">`<span class="subst">$&#123;dev.output.publicPath&#125;</span>index.html`</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;));</span><br><span class="line">  </span><br><span class="line">  app.use(<span class="string">'/api'</span>, proxy.createProxyMiddleware(&#123;</span><br><span class="line">      target: <span class="string">'http://10.64.57.204'</span>,</span><br><span class="line">      secure: <span class="literal">false</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> compiler = webpack(dev);</span><br><span class="line">      app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">          publicPath: dev.output.publicPath</span><br><span class="line">      &#125;));</span><br><span class="line">      app.use(webpackHotMiddleware(compiler, &#123;</span><br><span class="line">          <span class="comment">//这里的heartbeat,值得是每隔3s,一检测资源内容是否发生变化,如果发生了变化,就强制资源热加载</span></span><br><span class="line">          heartbeat: <span class="number">3000</span></span><br><span class="line">      &#125;));</span><br><span class="line">      app.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">          <span class="keyword">const</span> file = path.join(__dirname, <span class="string">'public/index.ejs'</span>);</span><br><span class="line">          <span class="comment">//这里经过webpack打包、缓存、编译以及多进程处理之后,使用文件系统读取模板引擎或者超文本传输协议文件,将处理之后的资源放入到此文件中,并放入到开发环境服务器路由中</span></span><br><span class="line">          compiler.outputFileSystem.readFile(file, (err, result) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                  ora().stopAndPersist(&#123;</span><br><span class="line">                      symbol: <span class="string">'✖'</span>,</span><br><span class="line">                      text: <span class="string">'读取文件出现错误～'</span></span><br><span class="line">                  &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">              res.set(<span class="string">'content-type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">              res.send(result);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  app.listen(PORT, () =&gt; &#123;</span><br><span class="line">      ora().stopAndPersist(&#123;</span><br><span class="line">          symbol: <span class="string">'✔'</span>,</span><br><span class="line">          text: <span class="string">`web网站已在localhost:<span class="subst">$&#123;PORT&#125;</span>域名中启动`</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置postcss扩展样式表</p>
</blockquote>
<p>  autoprefixer 该模块用于css的样式扩展,兼容旧版本浏览器的样式</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        autoprefixer</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  package.json 配置browserslist浏览器兼容以及版本列表</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"Chrome &gt;= 35"</span>,</span><br><span class="line">    <span class="string">"Firefox &gt;= 31"</span>,</span><br><span class="line">    <span class="string">"Explorer &gt;= 9"</span>,</span><br><span class="line">    <span class="string">"Safari &gt;= 7.1"</span>,</span><br><span class="line">    <span class="string">"Opera &gt;= 12"</span>,</span><br><span class="line">    <span class="string">"IOS &gt;= 7"</span>,</span><br><span class="line">    <span class="string">"Android &gt;= 4"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接着,我们要下载安装编写业务代码时的第三方外部依赖包</p>
</blockquote>
  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install react react-dom prop-types --save</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之后,我们在每个入口处进行react配置</p>
</blockquote>
  <figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">render(&lt;div&gt;</span><br><span class="line">     我叫尹文楷,俺是一个好银,😂😂😂</span><br><span class="line">&lt;/div&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后,我们进行配置index.ejs或者index.html(模板引擎或者超文本传输协议)</p>
</blockquote>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-cn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>express+webpack+react搭建一个web项目<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们express+react+webpack方式搭建的web项目就已经完成了,最后的最后给大家展示一下我的目录结构</p>
<p><img src="/images/catalogue.png" alt></p>
<h1 id="webpack-webpack-dev-server-react"><a href="#webpack-webpack-dev-server-react" class="headerlink" title="webpack+webpack-dev-server+react"></a>webpack+webpack-dev-server+react</h1>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
        <tag>webpack-dev-server</tag>
        <tag>web</tag>
        <tag>nodejs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>browserstack screenshots</title>
    <url>/2022/06/07/browserstackscreenshots/</url>
    <content><![CDATA[<h1 id="实现browserstack-screenshots"><a href="#实现browserstack-screenshots" class="headerlink" title="实现browserstack screenshots"></a>实现browserstack screenshots</h1><h2 id="browserstack-screenshots-api"><a href="#browserstack-screenshots-api" class="headerlink" title="browserstack screenshots api"></a>browserstack screenshots api</h2><p>   <a hef="https://www.browserstack.com/screenshots/api">Screenshots API</a>，通过调用 Screenshots API 的例子<a href="https://github.com/scottgonzalez/node-browserstack/blob/master/lib/screenshot.js" target="_blank" rel="noopener">node-browserstack screenshots</a>就可以得知，通过 http 请求 <a href="https://www.browserstack.com/screenshots" target="_blank" rel="noopener">https://www.browserstack.com/screenshots</a> 接口:</p>
<ul>
<li>url(需要测试截图的url);</li>
<li>os(测试环境: 操作系统);</li>
<li>os_version(测试环境: 操作系统版本);</li>
<li>browser(测试环境: 浏览器类型);</li>
<li>browser_version(测试环境: 浏览器版本);</li>
<li>device(测试环境: 若需要移动设备,设备类型);</li>
<li>orientation(测试环境: 设备的屏幕方向);</li>
<li>mac_res(测试环境: mac浏览器屏幕分辨率);</li>
<li>win_res(测试环境: windows浏览器屏幕分辨率);</li>
<li>quality(测试环境: 截图是否压缩);</li>
<li>local(测试环境: 是否建立本地测试连接);</li>
<li>wait_time(测试环境: 截图前等待的时间);</li>
<li>callback_url(测试环境: 回调网址);</li>
</ul>
<p>选择性带入上述参数就可生成截图列表极其状态，并回调到对应的url页面上。类似的，lambdaTest 上面也是有一套 Screenshots API 实现逻辑，<a href="https://www.lambdatest.com/support/api-doc/" target="_blank" rel="noopener">AUTOMATED SCREENSHOTS API</a>，其例子请求方式相同，都是通过 http 请求。</p>
<h2 id="browserstack-Screenshots-API背后所实现的原理"><a href="#browserstack-Screenshots-API背后所实现的原理" class="headerlink" title="browserstack Screenshots API背后所实现的原理"></a>browserstack Screenshots API背后所实现的原理</h2><p>辗转反侧的通过 Google、询问平台技术支持人员，最后得到的结论是: Screenshots API背后使用了多个自动化测试脚本和不同的框架来捕获屏幕截图，其中包含了selenium webdriver，也就是说基本上为了捕获截图，browserstack 使用了 selenium webdriver 技术，但 selenium webdriver 只限于针对PC端/移动端的浏览器。</p>
<h2 id="哪些方式可以实现跨终端自动化截图？"><a href="#哪些方式可以实现跨终端自动化截图？" class="headerlink" title="哪些方式可以实现跨终端自动化截图？"></a>哪些方式可以实现跨终端自动化截图？</h2><ul>
<li><p>Selenium WebDriver</p>
<ul>
<li><p>Selenium 是什么?</p>
<p>Selenium 是一套基于浏览器的自动化工具，它提供了一种跨平台、跨浏览器的端到端的 web 自动化解决方案。</p>
<p>Selenium 主要包括三部分:</p>
<ul>
<li>Selenium IDE：它可以进行录制回放用户操作，并且可以把录制的操作以多种语言（如JAVA、Python、C#等）的形式导出成测试用例。</li>
<li>Selenium WebDriver：提供 Web 自动化所需的 API，主要用作浏览器控制、页面元素选择和调试，通常也被成为WebDriver。不同的浏览器需要不同的 WebDriver，例如针对Chrome使用的chromedriver。</li>
<li>Selenium Grid：提供了在不同机器的不同浏览器上运行 selenium 测试的能力，一个分布式运行用例时的工具。</li>
</ul>
</li>
<li><p>Selenium WebDriver 的工作原理</p>
<p>简单来说: 自动化 Selenium WebDriver API 测试脚本发送请求给浏览器的驱动，驱动将测试脚本解析后的结果发送给浏览器，浏览器执行驱动发来的指令，并最终完成想要的操作。</p>
</li>
<li><p>Selenium WebDriver 的结构</p>
<p>典型的 C/S 结构，Selenium WebDriver API 相当于是客户端，而浏览器驱动才是服务器端。</p>
</li>
<li><p>浏览器的驱动兼容多个测试脚本的原因</p>
<p>WebDriver基于的协议：JSON Wire protocol，这个协议规范在WebDriver中数据都是以JSON的形式存在并进行传送的，所以在 client 和 server 之间，只要是基于JSON Wire Protocol来传递数据，与具体的脚本语言无关。</p>
</li>
<li><p>WebDriver协议 - JSON Wire protocol</p>
<p><a href="https://www.selenium.dev/documentation/legacy/json_wire_protocol/" target="_blank" rel="noopener">JSON Wire protocol 官方文档</a>，是<a href="https://w3c.github.io/webdriver/" target="_blank" rel="noopener">W3C WebDriver协议</a>的前身，是在http协议基础上，对http请求及响应的body部分的数据的进一步规范，必须以JSON的形式存在并进行传送，提供了操作浏览器<a href="https://w3c.github.io/webdriver/#endpoints" target="_blank" rel="noopener">命令的方法以及所对应的 URI 模板。<a></a></a></p>
</li>
<li><p>深析 Selenium WebDriver 的工作原理</p>
<ol>
<li>对于每一条转换为 JSON 之后的 Selenium WebDriver API 测试脚本,会通过 CommandExecutor 发送 http 请求给浏览器的驱动。</li>
<li>浏览器驱动中包含了一个 WebDriver remote server，通过监听端口用来接收 http 请求。</li>
<li>WebDriver remote server 接收到请求后根据请求来具体操控对应的浏览器。</li>
<li>浏览器执行具体的测试脚本步骤。</li>
<li>浏览器将执行结果返回给 WebDriver remote server。</li>
<li>WebDriver remote server 又将结果返回给 Selenium WebDriver API client 端。</li>
</ol>
<p><img src="/images/basic_comms.png" alt></p>
</li>
<li><p>自动化截图</p>
<p>可以通过 Selenium WebDriver API 用于捕获当前浏览上下文的屏幕截图，会返回以 Base64 格式编码的 PNG 图片。</p>
<p><a href="https://www.selenium.dev/documentation/webdriver/browser/windows/#takescreenshot" target="_blank" rel="noopener">TakeScreenshot(屏幕截图)</a></p>
<p>也可以通过 Selenium WebDriver API 用于捕获当前浏览上下文的元素内的屏幕截图，会返回以 Base64 格式编码的 PNG 图片。</p>
<p><a href="https://www.selenium.dev/documentation/webdriver/browser/windows/#takeelementscreenshot" target="_blank" rel="noopener">TakeElementScreenshot(元素内屏幕截图)</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Appium</p>
<ul>
<li><p>Appium 是什么?</p>
<p>Appium 是一个开源的移动端自动化测试工具，用于自动化 iOS设备、 Android设备 和 Windows 桌面系统上的原生、移动 Web 和混合应用，通过 Node.js 编写，用于启动 Appium HTTP Server。</p>
<ul>
<li>[原生应用]指那些用 iOS、 Android 或者 Windows SDKs 编写的应用。</li>
<li>[移动 Web 应用]是用移动端浏览器访问的应用(Appium 支持 iOS 上的 Safari、Chrome 和 Android 上的内置浏览器）。</li>
<li>[混合应用]带有一个[ webview ]的包装器——用来和 Web 内容交互的原生控件。</li>
</ul>
</li>
<li><p>安装</p>
<p>可以通过 NPM 安装。</p>
<pre><code>npm install -g appium
</code></pre><p>也可以通过 <a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">Appium Desktop</a> 桌面应用程序安装。</p>
<p>PS: 安装的 Appium 实际上只是用于启动 Appium HTTP Server 的。要想建立连接，还需要<a href="https://appium.io/docs/en/about-appium/appium-clients/index.html" target="_blank" rel="noopener"> Appium 服务器的客户端程序库</a>，它是基于 WebDriver 协议: JSON Wire protocol 扩展实现了 <a href="https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md" target="_blank" rel="noopener">Mobile JSON Wire Protocol</a> 协议，它负责与Appium服务器建立连接，并将测试脚本的指令发送到Appium HTTP Server。</p>
<p>配置驱动，<a href="https://appium.io/docs/en/about-appium/getting-started/?lang=zh#driver-specific-setup" target="_blank" rel="noopener">Driver-Specific Setup</a>。</p>
<p>PS: 驱动是包含在 Appium server 的工作范围内的。</p>
</li>
<li><p>Appium 的结构</p>
<p>典型的 C/S 结构，Appium client 相当于是客户端，Appium server 是服务器端。</p>
</li>
<li><p>深析 Appium 的工作原理</p>
<ol>
<li>测试人员执行测试脚本(java,python等脚本)通过 Appium client 转换为 JSON 数据，通过CommandExecutor 发送 http 请求传递给 Appium server，Appium server默认监听4723端口，这和 Selenium WebDriver 工作原理的前两步是一致的。</li>
<li><p>之后，Appium server 需要与移动端 App 依赖的自动化测试框架进行通信。</p>
<p><img src="/images/automate_test.png" alt></p>
<p>Appium server 会通过 TCP/IP 协议转发请求并转化成移动设备可以识别的命令（command）给不同设备的中间件，在转发请求的同时，会在 PC 端开启一个监听端口 4724，来接收设备返回的结果。</p>
</li>
<li><p>Appium server with Android</p>
<p>以 UIAutomator 的自动化测试框架为例。</p>
<p><img src="/images/appium_android.png" alt></p>
<p>命令（command）由中间件 bootstrap.jar 通过监听设备的4724端口来获得，经过其解释，将它们转换为 Android 设备可理解的 UIAutomator 格式，Android 设备通过 UIAutomator 命令调用其提供的 API 去做一些实际的操作；接着，Android 设备通过 bootstrap.jar 将执行命令的结果返回到 Appium server；最后，Appium server 将此结果响应给 Appium client。</p>
</li>
<li><p>Appium server with IOS</p>
<p>以 XCUITest 的自动化测试框架为例。</p>
<p><img src="/images/appium_ios.png" alt></p>
<p>命令（command）由中间件 WebDriverAgent.app 通过监听设备的4724端口来获得，经过其解释，通过调用 IOS 设备的 XCUITest API 将它们转换为 IOS 设备可理解的格式，IOS 设备通过转换后的命令去做一些实际的操作；接着，IOS 设备通过 WebDriverAgent.app 将执行命令的结果返回到 Appium server；最后，Appium server 将此结果响应给 Appium client。</p>
</li>
</ol>
</li>
<li><p>DesiredCapabilities</p>
<p>用于配置 Appium C/S 会话，告诉 Appium Server 您想要自动化的平台、应用程序等一系列信息。其是一组设置的键值对的集合，其中键对应设置的名称，而值对应设置的值。其通过 Mobile JSON Wire Protocol 协议以 JSON 格式发送测试设备信息给 Appium server。</p>
</li>
<li><p>自动化截图</p>
<p>可以通过 Appium Commands API 用于截取当前视口/窗口/页面的图片，会返回以 Base64 格式编码的 PNG 图片。</p>
<p><a href="https://appium.io/docs/en/commands/session/screenshot/#take-screenshot" target="_blank" rel="noopener">TakeScreenshot(屏幕截图)</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>testing</tag>
        <tag>browserstack</tag>
        <tag>screenshots</tag>
      </tags>
  </entry>
  <entry>
    <title>比木白-ES6</title>
    <url>/2020/04/26/%E6%AF%94%E6%9C%A8%E7%99%BD-ES6/</url>
    <content><![CDATA[<h1 id="ES6语法重点"><a href="#ES6语法重点" class="headerlink" title="ES6语法重点"></a>ES6语法重点</h1><p>在最近阅读了《深入理解ES6》这本书之后,发现ES6中有一些不为人所熟悉的部分却成为了提升开发效率的利器,所以将这些语法重点进行规整总结,分享输出给各位小伙伴.</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h3><p>  ES6中的块级作用域为了防止变量提升,产生了临时死区的方案,也就是说如果你在let、const定义块级作用域变量之前,直接使用此名称的变量,临时死区里面的逻辑就会报错,在执行同步代码度过临时死区之前,使用任何名称的变量都会报错,直到执行过临时死区之后,才会解封.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="comment">//这时候a变量不存在变量提升,会报语法错误</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'a,china,my hometown~'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">//这里打印: a,china,my hometown~</span></span><br></pre></td></tr></table></figure>
<h3 id="for循环中的块级作用域"><a href="#for循环中的块级作用域" class="headerlink" title="for循环中的块级作用域"></a>for循环中的块级作用域</h3><p>  ES6中for循环块级作用域中使用的let和const定义变量,和在普通的块级作用域中定义变量不同.for循环块级作用域中是循环的每一次都会声明赋值变量,不是对上次迭代变量的叠加或者累计,而是重新赋值声明,值等于上一次迭代变量加一.在for…in循环获取对象的属性集合项中,也是每一次迭代都会重新声明赋值属性.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里打印:</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//9</span></span><br></pre></td></tr></table></figure>
<h3 id="块级作用域最佳实践"><a href="#块级作用域最佳实践" class="headerlink" title="块级作用域最佳实践"></a>块级作用域最佳实践</h3><blockquote>
<p>ES6块级作用域最佳实践</p>
</blockquote>
<p>  尽量在业务开发中,全部使用const定义数据,只有认识到此数据是要进行计算的,就使用let定义数据.</p>
<blockquote>
<p>原因</p>
</blockquote>
<p>  大部分的数据是不可变的,只是作为查询或者展示,而可变的用于前端计算赋值的数据在实际应用场景当中很少很少.</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="以码位而非字符来匹配字符"><a href="#以码位而非字符来匹配字符" class="headerlink" title="以码位而非字符来匹配字符"></a>以码位而非字符来匹配字符</h3><p>  在没有引入Unicode之前,正则表达式使用以一个16位编码也就是两个码位来匹配一个字符,那时候2^16次方个字符在计算机的字符世界中是够用的,但是在引入Unicode之后,2^16次方个字符在诺大的字符集当中非常吃不消,所以正则表达式新增了u描述符,以一个码位也就是32位编码来匹配一个Unicode字符.至此,所有Unicode字符被分为两类,基本平面(BMP)以及辅助平面,BMP是在2^16次方哥字符之内的,而其余超出的则是辅助平面范围</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'𠮷'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);                    <span class="comment">//2,已超过BMP范围,转以辅助平面</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">0</span>));                 <span class="comment">//无法识别的乱码,因为以BMP的方式去获取字符,超出范围获取到的只能是�</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">1</span>));                 <span class="comment">//还是�</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">0</span>));             <span class="comment">//55362,不能获取到真实字符的码位,只能获取到码位的一半</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">1</span>));             <span class="comment">//57271,不能获取到真实字符的码位,只能获取到码位的一半</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">55362</span>));    <span class="comment">//�</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">57271</span>));    <span class="comment">//�</span></span><br><span class="line"><span class="built_in">console</span>.log(str.codePointAt(<span class="number">0</span>));            <span class="comment">//134071,这才是非BMP的辅助平面的方式所匹配的32位码位的真实码位值</span></span><br><span class="line"><span class="built_in">console</span>.log(str.codePointAt(<span class="number">1</span>));            <span class="comment">//57271,不能获取到真实字符的码位,只能获取到码位的一半</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">//𠮷,直接使用非BMP的辅助平面的方式可以匹配到真实字符</span></span><br></pre></td></tr></table></figure>
<h3 id="u描述符"><a href="#u描述符" class="headerlink" title="u描述符"></a>u描述符</h3>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'𠮷'</span>,</span><br><span class="line">    str_double = <span class="string">'𠮷𠮷'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\u&#123;20bb7&#125;/</span>.test(str));         <span class="comment">//因为\u&#123;20bb7&#125;超过了BMP16位编码的限制,所以是false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\u&#123;20bb7&#125;/u</span>.test(str));        <span class="comment">//使用u描述符来表述辅助平面的范围,所以是true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/𠮷/</span>.test(str));                <span class="comment">//这里并没有转化成\u&#123;20bb7&#125;BMP16位编码,而是直接用字符去进行匹配,所以返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/𠮷&#123;2&#125;/</span>.test(str_double));      <span class="comment">//这里使用了&#123;2&#125;表示将前面的字符乘以2,但这时候就会转化成\u&#123;20bb7&#125;BMP16位编码,超过了BMP16位编码的限制,所以是false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/𠮷&#123;2&#125;/u</span>.test(str_double));     <span class="comment">//使用u描述符来表述辅助平面的范围,所以是true</span></span><br></pre></td></tr></table></figure>
<p>  如果u描述符要兼容老版本浏览器,需要使用try {} catch(err) {},并且使用构造调用,这样是最安全的</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">'𠮷'</span>,</span><br><span class="line">        reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\u&#123;20bb7&#125;'</span>, <span class="string">'u'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(str));</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="各种新增的处理字符串的方法"><a href="#各种新增的处理字符串的方法" class="headerlink" title="各种新增的处理字符串的方法"></a>各种新增的处理字符串的方法</h3><blockquote>
<p>includes,字符串中是否含有某字符或者某字符串</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello,world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'o'</span>));             <span class="comment">//表示此字符串中是否含有o字符,这里返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'o'</span>, <span class="number">7</span>));          <span class="comment">//表示此字符串中从下标为7位置开始直到字符串最后,是否含有o字符,这里返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'o'</span>, <span class="number">8</span>));          <span class="comment">//表示此字符串中从下标为8位置开始直到字符串最后,是否含有o字符,这里返回false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>startsWith,字符串中是否以某字符或者某字符串开头</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello,world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">'hello'</span>));       <span class="comment">//表示此字符串中是否以hello字符串开头,这里返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">','</span>, <span class="number">5</span>));        <span class="comment">//表示此字符串中从下标为5位置开始直到字符串最后是否以,字符开头,这里返回true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>endsWith,字符串中是否以某字符或者某字符串结尾</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello,world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'ld'</span>));            <span class="comment">//表示此字符串中是否以ld字符串结尾,这里返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'o'</span>, <span class="number">7</span>));          <span class="comment">//表示此字符串中从下标为7位置开始直到字符串开头是否以o字符结尾,这里返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'o'</span>, <span class="number">8</span>));          <span class="comment">//表示此字符串中从下标为8位置开始直到字符串开头是否以o字符结尾,这里返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'o'</span>, <span class="number">5</span>));          <span class="comment">//表示此字符串中从下标为5位置开始直到字符串开头是否以o字符结尾,这里返回true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>repeat,将某字符或者字符串重复n次</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'pet'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">2</span>));                 <span class="comment">//表示此字符串重复2次输出,这里返回petpet</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">5</span>));                 <span class="comment">//表示此字符串重复5此输出,这里返回petpetpetpetpet</span></span><br></pre></td></tr></table></figure>
<h3 id="y描述符-粘滞描述符"><a href="#y描述符-粘滞描述符" class="headerlink" title="y描述符,粘滞描述符"></a>y描述符,粘滞描述符</h3><p>  y粘滞描述符,是区别于g全局描述符,与正则表达式匹配的lastIndex有直接关系,其匹配必须从字符串的开头0下标开始,如果匹配,则从匹配结束的位置开始,再开始匹配,如果再次匹配不到,则回到字符串的开头0下标开始,多次匹配的规则在字符串中必须是连续的.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello.hello.hello.hello.hello.'</span>,</span><br><span class="line">    reg_y = <span class="regexp">/hello./y</span>,</span><br><span class="line">    reg_g = <span class="regexp">/hello./g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg_g.exec(str));               <span class="comment">//这时全局描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.exec(str));               <span class="comment">//这时粘滞描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_g.lastIndex);               <span class="comment">//带有全局描述符正则表达式的lastIndex为6</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.lastIndex);               <span class="comment">//带有粘滞描述符正则表达式的lastIndex为6</span></span><br><span class="line"><span class="comment">//这时候设置带有全局和粘滞描述符的正则表达式的lastIndex为1</span></span><br><span class="line">reg_g.lastIndex = <span class="number">1</span>;</span><br><span class="line">reg_y.lastIndex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//再去匹配整个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_g.exec(str));               <span class="comment">//这时全局描述符匹配到["hello.", index: 6, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.exec(str));               <span class="comment">//这时粘滞描述符匹配到的值为null</span></span><br><span class="line"><span class="comment">//可以看出y粘滞描述符与正则表达式匹配的lastIndex有直接关系,且必须是从lastIndex位置为起点字符串的开头开始能匹配到,才会有匹配值,否则为null,lastIndex会回到源字符串的头部也就是下标为0处,为下次匹配做准备.</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello.hello.hello.hello.hello.'</span>,</span><br><span class="line">    reg_ny = <span class="regexp">/hello/y</span>,</span><br><span class="line">    reg_y = <span class="regexp">/hello./y</span>,</span><br><span class="line">    reg_g = <span class="regexp">/hello./g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg_g.exec(str));               <span class="comment">//这时全局描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.exec(str));               <span class="comment">//这时粘滞描述符匹配到["hello.", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_ny.exec(str));              <span class="comment">//这时粘滞描述符匹配到["hello", index: 0, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_g.lastIndex);               <span class="comment">//带有全局描述符正则表达式的lastIndex为6</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.lastIndex);               <span class="comment">//带有粘滞描述符正则表达式的lastIndex为6</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_ny.lastIndex);              <span class="comment">//带有粘滞描述符正则表达式的lastIndex为5</span></span><br><span class="line"><span class="comment">//再去匹配整个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_g.exec(str));               <span class="comment">//这时全局描述符匹配到["hello.", index: 6, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.exec(str));               <span class="comment">//这时粘滞描述符匹配到["hello.", index: 6, input: "hello.hello.hello.hello.hello.", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_ny.exec(str));              <span class="comment">//这时粘滞描述符匹配到的值为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出y粘滞描述符多次匹配的规则在字符串中必须是连续的,且必须是从lastIndex位置为起点字符串的开头开始能匹配到,才会有匹配值,否则为null,lastIndex会回到源字符串的头部也就是下标为0处,为下次匹配做准备.</span></span><br></pre></td></tr></table></figure>
<p>  如果y粘滞描述符要兼容老版本浏览器,需要使用try {} catch(err) {},并且使用构造调用,这样是最安全的</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">'hello.hello.hello.hello.hello.'</span>,</span><br><span class="line">        reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'hello.'</span>, <span class="string">'y'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(reg.test(str));</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="source、flags与sticky"><a href="#source、flags与sticky" class="headerlink" title="source、flags与sticky"></a>source、flags与sticky</h3><p>  source用于获取正则表达式的除了描述符以外的内容,flags则用于获取正则表达式的描述符,而sticky则是用于获取此正则表达式是否存在y粘滞描述符</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg_g = <span class="regexp">/hello./g</span>,</span><br><span class="line">    reg_y = <span class="regexp">/hello./y</span>,</span><br><span class="line">    reg_yi = <span class="regexp">/hello./yi</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg_g.source, reg_g.flags, reg_g.sticky);       <span class="comment">//这里打印: hello. g false </span></span><br><span class="line"><span class="built_in">console</span>.log(reg_y.source, reg_y.flags, reg_y.sticky);       <span class="comment">//这里打印: hello. y true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg_yi.source, reg_yi.flags, reg_yi.sticky);    <span class="comment">//这里打印: hello. yi true</span></span><br></pre></td></tr></table></figure>
<p>  顺便说一下在没有flags来获取正则表达式的描述符时,一般会是这么去封装一个获取正则表达式描述符的方法</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flags</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _reg = <span class="built_in">String</span>(reg),</span><br><span class="line">        flagsPosition = _reg.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">return</span> flagsPosition !== <span class="number">-1</span> ? _reg.slice(flagsPosition + <span class="number">1</span>) : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flags(<span class="regexp">/hello./yi</span>));                            <span class="comment">//在这里打印: yi</span></span><br></pre></td></tr></table></figure>
<h3 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h3><p>  模板标签处理模板字符串的数据参数顺序以及源字符串的操作很便利,你只要写一个函数,并直接放在模板字符串前方,这样就可以直接模板字符串进行处理了,函数的第一个参数是一个数组,表示的是所有除了引入变量以外的字符片段的集合,而后面的参数则是按照引入变量的顺序从左至右的排开,你可以使用不定参数将其转化为数组,不论你怎么引入变量,字符片段的集合数组总是比不定参数转化的数组的长度多一,所以我们可以自己去写一个模板标签,用交织的形式去组合字符串的原顺序或是自定义顺序.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Gary'</span>,</span><br><span class="line">    age = <span class="number">27</span>,</span><br><span class="line">    hobby = <span class="string">'basketball'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tags</span>(<span class="params">iterators, ...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tags_str = <span class="string">''</span>,</span><br><span class="line">        iterators_length = iterators.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line">        tags_str += iterators[key];</span><br><span class="line">        tags_str += value;</span><br><span class="line">    &#125;</span><br><span class="line">    tags_str += iterators[iterators_length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> tags_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tags<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁了, 我的爱好是<span class="subst">$&#123;hobby&#125;</span>`</span>);   </span><br><span class="line"><span class="comment">//在这里打印: 我是Gary, 我今年27岁了, 我的爱好是basketball</span></span><br></pre></td></tr></table></figure>
<p>  还有一种处理源字符串操作的模板标签,可以使源字符串不做转义.那就是String.raw</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Gary'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`啊哈,\n<span class="subst">$&#123;name&#125;</span>,原来是你`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`啊哈,\n<span class="subst">$&#123;name&#125;</span>,原来是你`</span>);</span><br><span class="line"><span class="comment">//在这里打印: 啊哈,</span></span><br><span class="line"><span class="comment">//Gary,原来是你</span></span><br><span class="line"><span class="comment">//在这里打印: 啊哈,\nGary,原来是你</span></span><br></pre></td></tr></table></figure>
<p>  它可以使换行、制表这些转义符不做转义,我们可以自己写一个和它一致的模板标签,每一个源字符片段都有一个raw的特有属性,其可以将其本身变为不可转义.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Gary'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">raw</span>(<span class="params">iterators, ...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> raw_str = <span class="string">''</span>,</span><br><span class="line">        iterators_length = iterators.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line">        raw_str += iterators.raw[key];</span><br><span class="line">        raw_str += value;</span><br><span class="line">    &#125;</span><br><span class="line">    raw_str += iterators.raw[iterators_length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> raw_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`啊哈,\n<span class="subst">$&#123;name&#125;</span>,原来是你`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(raw<span class="string">`啊哈,\n<span class="subst">$&#123;name&#125;</span>,原来是你`</span>);</span><br><span class="line"><span class="comment">//在这里打印: 啊哈,</span></span><br><span class="line"><span class="comment">//Gary,原来是你</span></span><br><span class="line"><span class="comment">//在这里打印: 啊哈,\nGary,原来是你</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>  默认参数使得传参更加简化、方便,只有传递的参数为undefined,就给予默认值,如果不为undefined,则进行赋值,类似于for循环let、const每次创建一个声明一样,默认参数也会在函数词法作用域的顶部使用let、const创建一个声明.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params">name, age = <span class="number">25</span>, hobby = <span class="string">'basketball'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I'm <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span> year's old, I love <span class="subst">$&#123;hobby&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">getPerson(<span class="string">'Gary'</span>);</span><br><span class="line"><span class="comment">//在这里打印: I'm Gary, 25 year's old, I love basketball</span></span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="comment">//function getPerson(name, _age, _hobby) &#123;</span></span><br><span class="line"><span class="comment">//    let age = typeof _age === 'undefined' ? _age : 25;</span></span><br><span class="line"><span class="comment">//    let hobby = typeof _hobby === 'undefined' ? _hobby : 'basketball';</span></span><br><span class="line"><span class="comment">//    console.log(`I'm $&#123;name&#125;, $&#123;age&#125; year's old, I love $&#123;hobby&#125;`);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p>  甚至可以在非第一个默认参数上面去承接之前定义好的传参或者默认参数.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">first = <span class="number">1</span>, second = first</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`first: <span class="subst">$&#123;first&#125;</span>, second: <span class="subst">$&#123;second&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">getNumber();</span><br><span class="line"><span class="comment">//在这里打印： first: 1, second: 1</span></span><br><span class="line">getNumber(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//在这里打印: first: 10, second: 2</span></span><br><span class="line">getNumber(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//在这里打印: first: 100, second: 100</span></span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="comment">//function getNumber(_first, _second) &#123;</span></span><br><span class="line"><span class="comment">//  let first = _first || 1;</span></span><br><span class="line"><span class="comment">//  let second = _second || first;</span></span><br><span class="line"><span class="comment">//  console.log(`first: $&#123;first&#125;, second: $&#123;second&#125;`);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p>  但是默认参数也存在临时死区的,在没有把临时死区当中的变量释放出来之前,直接使用,会引起语法错误.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">first = second, second = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`first: <span class="subst">$&#123;first&#125;</span>, second: <span class="subst">$&#123;second&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">getNumber();</span><br><span class="line"><span class="comment">//在这里会报语法错误,因为在first不传参赋值的情况下,second变量还处于临时死区当中,并未释放,不可以赋值给first</span></span><br><span class="line">getNumber(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//在这里打印: first: 10, second: 2</span></span><br><span class="line">getNumber(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//在这里打印: first: 100, second: 1</span></span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="comment">//function getNumber(_first, _second) &#123;</span></span><br><span class="line"><span class="comment">//  let first = _first || _second;</span></span><br><span class="line"><span class="comment">//  let second = _second || 1;</span></span><br><span class="line"><span class="comment">//  console.log(`first: $&#123;first&#125;, second: $&#123;second&#125;`);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p>  也可使用函数返回值的形式作为默认参数.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumberOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">first = getNumberOne(</span>), <span class="title">second</span> = <span class="title">first</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`first: <span class="subst">$&#123;first&#125;</span>, second: <span class="subst">$&#123;second&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">getNumber();</span><br><span class="line"><span class="comment">//在这里打印: first: 1, second: 1</span></span><br><span class="line">getNumber(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//在这里打印: first: 10, second: 2</span></span><br><span class="line">getNumber(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//在这里打印: first: 100, second: 100</span></span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line"><span class="comment">//function getNumber(_first, _second) &#123;</span></span><br><span class="line"><span class="comment">//  let first = _first || getNumberOne();</span></span><br><span class="line"><span class="comment">//  let second = _second || first;</span></span><br><span class="line"><span class="comment">//  console.log(`first: $&#123;first&#125;, second: $&#123;second&#125;`);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><p>  在ES6之前,对于不确定传参的数量的函数,我们基本上使用arguments对象来处理,但是不怎么方便,因为遇到很多情况是,我既有前几个确定的参数,又有后面不确定的参数,所以这时候的处理就需要跳过前几个确定的参数,比如UnderScore.js的pick方法,我们可以来模拟一下.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;,</span><br><span class="line">        args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[val] !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            result[val] = obj[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Gary'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    hobby: <span class="string">'My dream is over the world~'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(pick(person, <span class="string">'name'</span>, <span class="string">'hobby'</span>));</span><br><span class="line"><span class="comment">//在这里打印: &#123;name: 'Gary', hobby: 'My dream is over the world~'&#125;</span></span><br></pre></td></tr></table></figure>
<p>  在ES6中,为了使这种传参更加方便,引入了不定参数,我们无需对不确定的参数进行特殊处理,还是拿UnderScore.js的pick方法来模拟.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">obj, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[val] !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            result[val] = obj[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Gary'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    hobby: <span class="string">'My dream is over the world~'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(pick(person, <span class="string">'name'</span>, <span class="string">'hobby'</span>));</span><br><span class="line"><span class="comment">//在这里打印: &#123;name: 'Gary', hobby: 'My dream is over the world~'&#125;</span></span><br></pre></td></tr></table></figure>
<p>  不定参数必须以函数参数的最后位置出现,如果后方位置还有参数,则会报错</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">obj, ...args, <span class="string">'age'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[val] !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            result[val] = obj[val];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Gary'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    hobby: <span class="string">'My dream is over the world~'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(pick(person, <span class="string">'name'</span>, <span class="string">'hobby'</span>));</span><br><span class="line"><span class="comment">//在这里就会报语法错误</span></span><br></pre></td></tr></table></figure>
<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>  在ES6之前,有一些内置函数和对象比如说Math.max不支持以数组传入参数,只能一个一个的传入,所以我们这时候就需要使用apply的形式,直接传入数组,然后转化为参数.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">100</span>,</span><br><span class="line">    value_ano = <span class="number">120</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value, value_ano));</span><br><span class="line"><span class="comment">//在这里打印: 120</span></span><br><span class="line"><span class="keyword">let</span> value_arr = [<span class="number">0</span>, <span class="number">99</span> ,<span class="number">-10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">200</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, value_arr));</span><br><span class="line"><span class="comment">//在这里打印: 2000</span></span><br></pre></td></tr></table></figure>
<p>  在ES6推出了展开运算符之后,这种情况发生了改变,我们不需要使用apply的这种形式进行显式绑定.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value_arr = [<span class="number">0</span>, <span class="number">99</span> ,<span class="number">-10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">200</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...value_arr));</span><br><span class="line"><span class="comment">//在这里打印: 2000</span></span><br></pre></td></tr></table></figure>
<p>  有了展开运算符和不定参数的支持,在函数传参方面大为改观,我们现在可以使用这两种新形势进行配合写一个bind显式绑定方法.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">let</span> fBind;</span><br><span class="line">        fBind = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">              <span class="comment">//这里做判断是为了防止返回的函数,使用new构造调用.new绑定的优先级高于其他绑定</span></span><br><span class="line">              <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBind ? <span class="keyword">this</span> : context, [...params, ...args])</span><br><span class="line">        &#125;;</span><br><span class="line">        F.prototype = self.prototype;</span><br><span class="line">        fBind.prototype = <span class="keyword">new</span> F();</span><br><span class="line">        <span class="keyword">return</span> fBind;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//实验一下</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'Gary'</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.introduce = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> year's old`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> func = Person.bind(obj, <span class="string">'Tom'</span>);</span><br><span class="line">    func(<span class="number">28</span>);</span><br><span class="line">    <span class="comment">//在这里打印: </span></span><br><span class="line">    <span class="comment">//Gary </span></span><br><span class="line">    <span class="comment">//Tom</span></span><br><span class="line">    <span class="comment">//25</span></span><br><span class="line">    <span class="comment">//28</span></span><br><span class="line">    <span class="keyword">let</span> _func = Person.bind(obj);</span><br><span class="line">    <span class="keyword">let</span> quote = <span class="keyword">new</span> _func(<span class="string">'Simon'</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(quote.name, quote.age);</span><br><span class="line">    quote.introduce();</span><br><span class="line">    <span class="comment">//在这里打印:</span></span><br><span class="line">    <span class="comment">//undefined</span></span><br><span class="line">    <span class="comment">//Simon</span></span><br><span class="line">    <span class="comment">//undefined</span></span><br><span class="line">    <span class="comment">//30</span></span><br><span class="line">    <span class="comment">//Simon 30</span></span><br><span class="line">    <span class="comment">//I'm Simon, 30 year's old</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>  函数在普通调用和构造调用时,所使用的内置函数是不同的,普通调用使用的是[[Call]]内置函数,而构造调用使用的是[[Constructor]],而在一些必须使用构造调用的函数的判断就成了问题.在ES6之前是这样判断的</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'此函数必须使用构造调用～'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gary = <span class="keyword">new</span> Person(<span class="string">'Yinwenkai'</span>, <span class="number">26</span>);</span><br><span class="line"><span class="built_in">console</span>.log(gary.name, gary.age);</span><br><span class="line"><span class="comment">//在这里打印: Yinwenkai 26</span></span><br><span class="line"><span class="keyword">let</span> simon = Person(<span class="string">'Yinwenkai'</span>, <span class="number">27</span>);</span><br><span class="line"><span class="comment">//在这里就会报语法错误,因为函数直接调用,使用的是[\[Call\]]内置函数,并不是[\[Constructor\]],这边就会抛出错误,this指向window或者global</span></span><br></pre></td></tr></table></figure>
<p>  但是这样还是会有漏洞的,我们可以使用硬绑定,将Person硬绑定至构造调用出来的引用对象上面.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'此函数必须使用构造调用～'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">let</span> gary = <span class="keyword">new</span> Person(<span class="string">'Yinwenkai'</span>, <span class="number">26</span>);</span><br><span class="line"><span class="built_in">console</span>.log(gary.name, gary.age);</span><br><span class="line"><span class="comment">//在这里打印: Yinwenkai 26</span></span><br><span class="line"><span class="keyword">let</span> simon = Person(<span class="string">'Yinwenkai'</span>, <span class="number">27</span>);</span><br><span class="line"><span class="comment">//在这里就会报语法错误,因为函数直接调用,使用的是[\[Call\]]内置函数,并不是[\[Constructor\]],这边就会抛出错误,this指向window或者global</span></span><br><span class="line"><span class="keyword">let</span> lily = Person.call(gary, <span class="string">'Yinwenkai'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">//在这里就不会报任何错误,因为硬绑定到构造调用出来的引用对象上面,就可以普通调用了.</span></span><br></pre></td></tr></table></figure>
<p>  所以ES6推出了new.target,此对象总是指向构造调用函数本身的,也就是说使用[[Constructor]]去调用才会有此对象,如果使用[[Call]]去调用就不会有此对象也就等于undefined</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'此函数必须使用构造调用～'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">let</span> gary = <span class="keyword">new</span> Person(<span class="string">'Yinwenkai'</span>, <span class="number">26</span>);</span><br><span class="line"><span class="built_in">console</span>.log(gary.name, gary.age);</span><br><span class="line"><span class="comment">//在这里打印: Yinwenkai 26</span></span><br><span class="line"><span class="keyword">let</span> simon = Person(<span class="string">'Yinwenkai'</span>, <span class="number">27</span>);</span><br><span class="line"><span class="comment">//在这里就会报语法错误,因为函数直接调用,使用的是[\[Call\]]内置函数,并不是[\[Constructor\]],这边就会抛出错误,this指向window或者global</span></span><br><span class="line"><span class="keyword">let</span> lily = Person.call(gary, <span class="string">'Yinwenkai'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">//在这里还是会报语法错误,因为new.target不管函数如何硬绑定,它也只在使用[[Constructor]]去调用函数的时候,才是存在的</span></span><br></pre></td></tr></table></figure>
<h3 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h3><p>  ES6中,因为有了块级作用域,所以对函数的声明限制在严格模式下做了强控,由此有了块级函数,只能在此块级作用域中可访问并调用到此函数,全局并不能访问到并调用</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is foo func~'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//ƒ foo() &#123;</span></span><br><span class="line"><span class="comment">//  console.log('this is foo func~');</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//this is foo func~</span></span><br><span class="line"><span class="comment">//下面就会报语法错误</span></span><br><span class="line"><span class="comment">//VM1182:9 Uncaught ReferenceError: foo is not defined</span></span><br><span class="line"><span class="comment">//at &lt;anonymous&gt;:9:17</span></span><br></pre></td></tr></table></figure>
<p>  但是如果不是在严格模式下,不仅在此块级作用域中可访问并调用到此函数,全局依然可以访问并调用</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is foo func~'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//ƒ foo() &#123;</span></span><br><span class="line"><span class="comment">//  console.log('this is foo func~');</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//this is foo func~</span></span><br><span class="line"><span class="comment">//ƒ foo() &#123;</span></span><br><span class="line"><span class="comment">//  console.log('this is foo func~');</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//this is foo func~</span></span><br></pre></td></tr></table></figure>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>  说到name,就不得不说它被开创的原因,它本来是为了追溯堆栈信息而生,就是当出现某些错误的时候,比如TypeError、ReferenceError和SyntaxError时,引擎就会根据此函数的name查找所在函数的发生错误的位置,一层层寻找下去,形成函数调用时追溯错误信息的堆栈.而name就成了函数的名称,length就成了函数参数的个数.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="built_in">console</span>.log(person.length);</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//person</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>  不同方式生成的函数的名称是不同的,比如说bind硬绑定,它所返回的函数的名称就是”bound [[函数真实名称]]”,而使用Function构造出来的函数的名称则是”anonymous”.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gary = person.bind(<span class="literal">null</span>, <span class="string">'Gary'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(gary.name);</span><br><span class="line"><span class="comment">//在这里打印</span></span><br><span class="line"><span class="comment">//bound person</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">//在这里打印</span></span><br><span class="line"><span class="comment">//anonymous</span></span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>  ES6中最让人感兴趣之一,也是变化最大之一的改动就是箭头函数了.特点在于它的方便和简化,它废弃了传统JS函数中的一些复杂而又让人费解的特性,其实际多应用在回调函数、Promise处理异步问题的结构中.<br>  特性:</p>
<ol>
<li>不可使用new绑定构造调用,就是说箭头函数里就无[[Constructor]]内置属性</li>
<li>不可改变函数this的指向,this永远指向外层词法作用域</li>
<li>不可在函数内部使用arguments,也就是说arguments在箭头函数里面压根儿不存在</li>
<li>不可在函数内部使用super,既然不能new绑定构造调用,那肯定也不能使用继承了,更不能使用super</li>
<li><p>不可使用new.target,既然不能new绑定构造调用,那肯定也用不了new.target,箭头函数里就无[[Constructor]]内置属性,而new.target又与[[Constructor]]内置属性相关</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Simon'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Gary'</span>,</span><br><span class="line">    getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> simon = &#123;</span><br><span class="line">    name: <span class="string">'Simon'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName());</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName.call(simon));</span><br><span class="line"><span class="comment">//在这里打印</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> aaron = <span class="keyword">new</span> Person(<span class="string">'aaron'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">//在这里会报类型错误</span></span><br><span class="line"><span class="comment">//Uncaught TypeError: Person is not a constructor</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="string">'Alice'</span>);</span><br><span class="line"><span class="comment">//在这里直接报引入错误</span></span><br><span class="line"><span class="comment">//VM74:3 Uncaught ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'此函数必须使用构造调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'比木白'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">//在这里直接报引入语法错误</span></span><br><span class="line"><span class="comment">//Uncaught SyntaxError: new.target expression is not allowed here</span></span><br></pre></td></tr></table></figure>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>  其实尾调用优化的定义非常简单,目标也很清楚,就是一句话:循环利用某一堆栈,让我们先看一张图</p>
<p>  <img src="/images/tailCall.png" alt></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">'Gary'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> b = <span class="string">'Simon'</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> c = <span class="string">'Lily'</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//Gary Simon Lily</span></span><br></pre></td></tr></table></figure>
<p>  上述代码和图全面阐述了非尾调用时,函数堆栈执行的情形,当baz函数执行时,会将此函数推到内存的,但是baz函数不会因为执行调用而被销毁,因为内部还存在bar函数,等待bar函数执行完毕之后,baz才会从堆栈栈底销毁,而bar函数的执行,又会产生推到内存栈底的函数,以此类baz -&gt; bar关系推bar -&gt; foo是一样的,堆栈随着内部函数的调用不断累积,且不能第一时间被销毁,必须等待内部的堆栈调用完全销毁才能轮到自己.这种不可复用的堆栈使用,ES6给出了优化功能,那就是尾调用.</p>
<p>  尾调用的条件</p>
<ol>
<li>内部函数的调用必须在外层函数结构体的最后一行执行,并且进行返回.</li>
<li>不可在内部函数结构体中,使用任何外层函数结构体中的变量、方法,也就是说不能存在闭包或者词法作用域链等行为.</li>
<li><p>内部函数的调用必须在外层函数结构体的最后一行不可进行显式计算返回.</p>
<p>让我们举一个非尾调用优化的例子,来个阶乘吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//120</span></span><br></pre></td></tr></table></figure>
<p>再举一个阶乘尾调用优化的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>, total * n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在这里打印:</span></span><br><span class="line"><span class="comment">//120</span></span><br></pre></td></tr></table></figure>
<p>这就是尾调用优化,符合一开始我所说的是三个条件,递归调用函数是在函数结构体的最后一行,且并没有进行显式计算,不存在闭包和函数作用域链使用任何外层函数结构体中的变量、方法的情况.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ECMAScript 2015</tag>
        <tag>ES6</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>这样的我，终究也熟了</title>
    <url>/2022/06/20/%E8%BF%99%E6%A0%B7%E7%9A%84%E6%88%91%E7%BB%88%E7%A9%B6%E4%B9%9F%E7%86%9F%E4%BA%86/</url>
    <content><![CDATA[<h1 id="我"><a href="#我" class="headerlink" title="我"></a>我</h1><p>本人29岁，独生子，从小属于那种父母捧在手里怕掉了，含在嘴里怕化了的典型，简称小皇帝；自主动手思考能力差，计划能力差，唯一的特长就是没有特长(哦，不对，我小时候特能跑，小学初中校级赛跑都得过奖，按照这样来说，应该是头脑简单，四肢发达)，成绩从小学到高中基本上是中等，大学考的也是不上不下，要不是选了一个好专业，肯定就得啃老；工作以后，自以为可以开拓一片天地，还找了一位红颜，可惜自己不珍惜，能力也有限: 头脑僵化、不知变通、思维迟钝、逻辑混乱、投机取巧、笨嘴笨舌、百无聊赖、词不达意，到现在工作地位也是不上不下，红颜也因为自己的原因给弄丢了，但就是这样，我竟然还活到了29岁，感觉是平平无奇的29年。不过终于有一天，天灵盖开光，这样的我，终究也熟了🐶。</p>
<p>在这’瓜’29年时间最终瓜熟蒂落之际，对自我成长、职业方面设定一个清晰的小目标，在一年时间内，使自身综合能力、技术水平、生活水准以及精神涵养方面有一些小进步，在这无人问津的博客上隆重做自己的成人礼!!!(是的，你没有看错，29岁做成人礼，走过路过不要错过🐶没见过活了29年还没活明白的男生吧🐶)</p>
<h1 id="自我成长"><a href="#自我成长" class="headerlink" title="自我成长"></a>自我成长</h1><ol>
<li><p>让自己变得有一些基本思想、有一些基本逻辑。</p>
<ul>
<li>方法及目标: 三个月内不断勤奋的学习、思考，能理解方法论，形成自己的基础思维观念。</li>
<li>工具: 《如何变得有思想》 —— 阮一峰，《逻辑表达力》 —— 刘琳，《简单的逻辑学》 —— D.Q.麦克伦尼，《系统思考》 —— 丹尼斯.舍伍娜</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>让自己变得有趣，提高自己的情商，让自己会说话并不再害怕说话，升级自己的表达能力。</p>
<ul>
<li>方法及目标: 半年内通过持续观察、学习、积累和实践，能形成自己的一套说话方式。</li>
<li>工具: 《蔡康永的情商课》 —— 蔡康永，《所谓情商高就是会说话》 —— 佐佐木圭一，《说话的艺术》—— 罗莎莉.马吉欧，《特别会说话的人都这样说话》 —— 大野萌子</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<p>半年内的终极目标: 思想逻辑、情商以及表达能力能与阿里蚂蚁金服P6+工程师 *悦 并驾齐驱。</p>
<h1 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h1><ol>
<li><p>webpack构建打包方面的专家。</p>
<ul>
<li>目标: 一个月内在webpack打包方面可以做到问题终结者，独挡一面，并能延伸和指导前端团队人员。</li>
<li>工具: 《深入浅出Webpack》—— 吴浩麟，《Webpack实战》—— 居玉浩，《玩转 webpack》(视频) —— 程柳锋，GitHub -&gt; Webpack，Webpack官网</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>能够精通、理解以及使用NodeJS。</p>
<ul>
<li>目标: 半年内在NodeJS方面做到精通，理解其设计模式，明确其C++扩展，实践其常用框架工具，尽量做到在一年内成为问题终结者，独挡一面，并能延伸和指导前端团队人员。</li>
<li>工具: 《node.js 入门指南》—— 司明岳，《了不起的Node.js》—— Rauch，《深入浅出Node.js》—— 朴灵，《Koa与Node.js实战》—— iKcamp，《Node.js实战》—— 图灵团队，《Node与Express开发》—— Ethan.Brown，《Node.js设计模式》—— 卢西安诺.马米诺 马里奥.卡西罗，《Node.js来一打C++扩展》—— 死月，《Node.js开发实战》(视频) —— 杨浩，NodeJS官网，GitHub -&gt; NodeJS 扩展</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>Typescript方面的专家。</p>
<ul>
<li>目标: 三个月内在Typescript方面可以做到问题终结者，独挡一面，并能延伸和指导前端团队人员。</li>
<li>工具: 《深入理解 TypeScript》 —— Basarat.Ali.Syed，《TypeScript 编程》—— Boris.Cherny，《TypeScript开发实战》(视频) —— 梁宵，Typescript官网，GitHub -&gt; TypeScript</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>能够精通、理解以及使用Electron。</p>
<ul>
<li>目标: 半年内在Electron方面做到精通，明确其内部原理和工程，并做到开发实践，尽量做到在一年内成为问题终结者，独挡一面，并能延伸和指导前端团队人员。</li>
<li>工具: 《深入浅出Electron》 —— 刘晓伦，《Electron实战》—— 刘晓伦，《Electron开发实战》(视频) —— 邓耀龙，Electron官网，GitHub -&gt; Electron</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>React方面的专家。</p>
<ul>
<li>目标: 三个月内在React方面可以做到问题终结者，独挡一面，并能延伸和指导前端团队人员。</li>
<li>工具: 《深入React技术栈》 —— 陈屹，《React - 引领未来的用户界面开发框架》—— League of Extraordinary Developers，《深入理解React Router》 —— 李杨韬，《React实战进阶45讲》(视频) —— 王沛，《React Hooks 核心原理与实战》(语音) —— 王沛，React官网，GitHub -&gt; React</li>
<li>PS: 如果还有其他时间则阅读其他有关书籍。</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>JS、ES6等基础方面做到权威专家。</p>
<ul>
<li>一年之内，不断的扩充自己的知识面，在基础背景方面深度挖掘，查漏补缺，尽量做到在前端基础理论和实践方面百科全书 —— 江湖百晓生。</li>
</ul>
</li>
</ol>
<p>一年内的终极目标: 阿里蚂蚁金服P7级别的专家，技术、眼界和能力上都远超过阿里蚂蚁金服P6+工程师 *悦，普通互联网企业技术/业务部门的架构师。</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>日常开发难点</title>
    <url>/2022/06/12/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%9A%BE%E7%82%B9/</url>
    <content><![CDATA[<h1 id="列表项上下键选中使用-scrollIntoView-behavior-‘smooth’-抖动问题"><a href="#列表项上下键选中使用-scrollIntoView-behavior-‘smooth’-抖动问题" class="headerlink" title="列表项上下键选中使用 scrollIntoView behavior: ‘smooth’ 抖动问题"></a>列表项上下键选中使用 scrollIntoView behavior: ‘smooth’ 抖动问题</h1><blockquote>
<p>原理分析</p>
</blockquote>
<p>  放弃计算DOM getBoundingClientRect的方式，也不使用原版每次选中都进行 scrollIntoView 自适应 ‘smooth’ 滚动，而是采用底层 API <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">Intersection Observer API</a> 来计算列表项(list-item)是否存在于可视的列表范围(list-container)之内，底层 API 性能、效率、效果都比前面两种方式高的多。</p>
<p>  Intersection Observer 从用法上还是蛮简单的，那理解上来说呢，简单来讲：是一个观察者模式，目标元素与视口会产生一个是否可见交叉区，通过观察视口与目标元素的交叉关系，可以在 callback 回调中获取目标元素与视口的交叉关系信息，产生”交叉观察器”的效果。</p>
<p>  <img src="https://image.white-than-wood.zone/difficult/intersection.gif" alt></p>
<p>  特性: callback 一般只会触发两次，一次是目标元素开始可见，另一次是开始不可见。</p>
<blockquote>
<p>可行性分析</p>
</blockquote>
<p>  那在个人的项目例子中呢，所有的 list-item 都是目标元素，通过观察完全超出视口范围的第一个 list-item 开始可见的时间点来引起 scrollIntoView 平滑动画过渡的 ‘smooth’ 滚动，在滚动之后视口有新的一批 list-item 的情况下，重建 IntersectionObserver，重置 IntersectionObserver 实例，以此来循环。</p>
<p>  可以这么想，”交叉观察器”观察的永远是新的一批 list-item 与视口的交叉关系，而老一批 list-item 在 scrollIntoView 滚动之后，因”交叉观察器”特性(只会触发两次)应当重建”交叉观察器”重新观察。</p>
<p>  在这时候可能想问，有没有可能存在一种情况，scrollIntoView 平滑动画过渡的 ‘smooth’ 滚动的时间会慢于按键的速度，通过完全超出视口范围的第二个、第三个等 list-item 开始可见的时间点再次引起滚动，从而产生抖动的问题呢？答案是理论上存在这种可能性，而在实际操作上，极端操作极速按键按住不放的情况下存在，而在比较快按键的节奏下，是不存在这种可能性的。</p>
<ul>
<li>首先，在第一次滚动之后，第一时间就对 IntersectionObserver 实行重建，IntersectionObserver 实例实行重置，将源实例置为null并停止对所有目标元素可见性变化的观察，虽然观察者本身仍然处于活动状态，在 disconnect() 之后，目标元素仍然可以通过 observe() 传递给观察者，但没有目标，在实例置为null后，会很快被垃圾回收机制处理，所以这时候是不会存在的。</li>
<li>其次，即使按键按住不放极速实行选中，也可以通过节流来解决，因为按键按住不放这种操作，本身就是一种非常规且触及极端边界的操作，不必实时且完全满足这种极端操作。</li>
</ul>
<p>PS: 这种重建 IntersectionObserver，重置 IntersectionObserver 实例的方式确实有一些不是很优雅，但官方并没有提供动态修改的方法，不可能把希望寄托在官方修改api上，了解ECMA的提案流程的同学肯定知道，那将是个十分漫长的过程，所以眼下就只能找到这种比较切实的办法来解决这个问题。</p>
<p>Attention: 原生事件的监听会阻断 scrollIntoView ‘smooth’ 滚动动画的执行，产生滑动卡顿，所以必须取消默认事件的执行( e.preventDefault() )或者直接取消监听事件。</p>
<blockquote>
<p>实际演示</p>
</blockquote>
  <video muted controls="controls" autoplay="autoplay" loop="loop"><br>    <source src="https://image.white-than-wood.zone/difficult/point.mp4" type="video/mp4"><br>  </video>
]]></content>
      <categories>
        <category>难点</category>
      </categories>
      <tags>
        <tag>难点</tag>
        <tag>日常开发</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建部署devtools-frontend</title>
    <url>/2022/07/03/%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2chrome-devtools-frontend/</url>
    <content><![CDATA[<h1 id="devtools-frontend"><a href="#devtools-frontend" class="headerlink" title="devtools-frontend"></a>devtools-frontend</h1><blockquote>
<p>原理分析</p>
</blockquote>
<p>原理在<a href="https://www.cnblogs.com/vivotech/p/15735242.html" target="_blank" rel="noopener">《DevTools 实现原理与性能分析实战》</a>和<a href="https://zhaomenghuan.js.org/blog/chrome-devtools-frontend-analysis-of-principle.html" target="_blank" rel="noopener">《Chrome DevTools Frontend 运行原理浅析》</a>这两篇文章中实际上已经说得很清楚了,整个 Devtools 实现 PC 端: chrome浏览器,Android客户端: chrome 浏览器、App webview中调试都是完全依赖了 Chromium 浏览器内核,其高性能的Blink(之前是Webkit)渲染引擎使得这一套生态得以实现.</p>
<blockquote>
<p>源码下载及编译</p>
</blockquote>
<p>DevTools Frontend 属于 Chromium 完全独立的一部分,代码托管在 Google 开源仓库上,代码开源可以从这里下载(但是不推荐,因为源代码不全,无法进行检出和编译): <a href="https://chromium.googlesource.com/devtools/devtools-frontend/" target="_blank" rel="noopener">Chromium DevTools Frontend</a> 或 <a href="https://www.npmjs.com/package/chrome-devtools-frontend" target="_blank" rel="noopener">GitHub DevTools Frontend 镜像</a>.DevTools Frontend 基于 GN 构建.</p>
<ul>
<li><p>构建系统</p>
<p>构建系统实际上就是一套编译规则,将无数的源代码文件根据一定的顺序和策略来进行编译,模块划分、编译成动静态库,最后链接成可执行代码通过构建系统的编译可以大大提升开发人员的工作效率.比如很常见的 GNU Makefile,但编写 GNU Makefile 是一件繁琐和乏味的事情,而且极容易出错.这时就出现了生成 GNU Makefile 的工具,比如 cmake、AutoMake 等等,这种构建系统称作元构建系统（meta build system）,如在Linux上软件仓库的概念还没有普及的时候,通常我们安装软件的步骤是:</p>
<pre><code>./configure
make
make install
</code></pre></li>
<li><p>Chromium 中的构建系统</p>
<p>几年前的chromium开源项目采用的是 GYP (Generate Your Projects）构建系统,这也是一种元构建系统.软件工程师根据 GYP 规则编写构建工程文件（通常以 gyp, gypi 为后缀）,GYP 工具根据 gyp 文件生成 GNU Makefile.接着chromium 项目又搞出了 Ninja 构建系统,但 Ninja 并不是用来取代 GYP 的,而是取代 GNU Makefile 的,据 Google 官方的说法是速度有了好几倍的提升.但对于开发者而言, 不需要去深入了解 GYP 或 GN 这样的元构建系统，因为这只是一种中间输出，所以 ninja 的出现，与开发者关系不大，原来怎么写 gyp，现在还是怎么写，只是构建命令稍微做了改变。GN 文件相当于 gyp 文件的下一代，和 GYP 差别不大，但是总体上比原来的 GYP 文件更清晰.</p>
</li>
<li><p>GN 元构建系统</p>
<p>GN 是一种元构建系统,生成 Ninja 构建文件（Ninja build files）,相较 GYP 而言,有很大的优点:</p>
<ol>
<li>可读性更好，更容易编写和维护.</li>
<li>速度更快，Google 官方给的数据是 20 倍的速度提升.</li>
<li>修改 GN 文件后,执行 ninja 构建时会自动更新 Ninja 构建文件.</li>
<li>更简单的模块依赖,提供了 public_deps, data_deps 等,在 GYP 中,只有一种目标依赖,导致依赖关系错综复杂,容易引入不必要的模块依赖.</li>
<li>提供了更好的工具查询模块依赖图谱: 这在 GYP 构建系统中是一个噩梦,要查一个目标依赖哪些模块或者一个模块被哪些目标依赖几乎是不可能的.</li>
<li>更好的调试支持: 在 GN 中，只需要一条 print 语句就可以解决.</li>
</ol>
</li>
</ul>
<ul>
<li><p>depot_tools</p>
<p>depot_tools是一个工具集,里面包含了gclient、gcl、gn和ninja等工具,用来下载、编译、运行 和调试 Chromium 中的独立的项目,所以为了学习 Chromium 代码,下载安装 depot_tools 是前提.</p>
<pre><code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
</code></pre><p>Tips: 这里使用终端下载 depot_tools 需要将终端或者 git 设置 VPN,否则会超时导致不能下载.</p>
<pre><code># 终端临时设置 VPN
export http_proxy=http://127.0.0.1:7890/
export https_proxy=$http_proxy

# 全局 git 设置 VPN
git config --global http.proxy http://127.0.0.1:7890/
git config --global https.proxy http://127.0.0.1:7890/
</code></pre><p>打开 ~/.bash_profile 文件，将 depot_tools 添加到环境变量中,这样 depot_tools 里的工具命令就添加到了全局变量中(/path/to/depot_tools 为你 depot_tools 本地的路径).</p>
<pre><code>vim ~/.bash_profile
export PATH=$PATH:/path/to/depot_tools
</code></pre><p>更新环境变量,立即生效命令.</p>
<pre><code>source ~/.bash_profile
</code></pre><p>这样所有的下载、编译、运行 和调试 Chromium 中的独立的项目的工具命令就全存在在全局变量中了,包括 GN 元构建系统.</p>
</li>
<li><p>源码下载</p>
<pre><code># fetch 也是 depot_tools 中的工具命令.
fetch devtools_frontend
</code></pre><p>Tips: 这里使用终端下载 devtools_frontend 需要将终端或者 git 设置 VPN,否则会超时导致不能下载.</p>
<pre><code># 终端临时设置 VPN
export http_proxy=http://127.0.0.1:7890/
export https_proxy=$http_proxy

# 全局 git 设置 VPN
git config --global http.proxy http://127.0.0.1:7890/
git config --global https.proxy http://127.0.0.1:7890/
</code></pre><p>PS: 如果电脑上装的是 python 3.x 的话,会出现证书验证失败的错误,需要手动验证激活,点击 Install Certificates.command 即可手动验证激活.</p>
<pre><code>urllib.error.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1108)
</code></pre><p><img src="https://image.white-than-wood.zone/devtools_frontend/urlError.png" alt></p>
<p>若出现以下内容:</p>
<p><img src="https://image.white-than-wood.zone/devtools_frontend/glicent.png" alt></p>
<p>说明资源发生了更新,运行以下命令来下载代码.</p>
<pre><code>gclient sync
</code></pre><ul>
<li><p>gclient</p>
<p>gclient 是由 Google 用 Python 开发的一套跨平台的 git 仓库管理工具,它的作用类似 git 的 submodule，用来将多个 git 仓库组成一个 solution 进行管理，比如 chromium 项目是由80多个独立的 git 仓库构成的.gclient sync 就是同步更新最新的代码资源.</p>
</li>
</ul>
</li>
<li><p>编译</p>
<pre><code>cd devtools-frontend
# GN 构建系统新生成一个编译目录,并产出 Ninja 构建文件
gn gen out/Default
# 运行 Ninja 构建文件进行根据编译规则实行编译
autoninja -C out/Default
</code></pre><p>编译生成的文件可以在 out/Default/gen/front_end 中找到.</p>
</li>
</ul>
<blockquote>
<p>基于Chrome运行</p>
</blockquote>
<p>  根据<a href="https://chromium.googlesource.com/devtools/devtools-frontend/+/HEAD/docs/workflows.md#Integrated-checkout" target="_blank" rel="noopener"> Devtools Frontend Workflows </a>以及<a href="https://docs.google.com/document/d/1COgCBWWuTh2o-Zbp6h_z0h0LtlJaimaEDsION4RZPxc/edit#heading=h.406e03aq0xjm" target="_blank" rel="noopener"> DevTools debugging workflow -&gt; Existing workflows </a>可知,原有的基于 DevServer 运行 DevTools 方式(npm start)已经移除,Chromium 79版本之后统一使用 –custom-devtools-frontend 方式.</p>
<ul>
<li><p>Chrome Canary</p>
<p>  众所周知,Chrome = Chromium + Google产品集,那么Chrome Canary是什么呢? Chrome Canary 是更新速度最快的 Chrome 版本,几乎每天更新且支持自动更新,也是功能、代码最先进的 Chrome 版本,可独立安装、与其他版本的 Chrome 程序共存,适合进阶用户或开发者人员安装备用,尝鲜最新功能,由于是每日更新的 Chrome Dev 版本,极其不稳定.</p>
<p>  Chrome Dev 是 Chrome 的开发者版本,每个周更新 1-2 次,虽然该版本已经过测试,但仍可能存在一些问题,但比 Chrome Canary 更稳定.</p>
<p>  Chrome Beta 是 Chrome 的测试版本,每周更新一次,而每 4 周会进行一次重大的可纳入到稳定版本的更新.</p>
</li>
<li><p>通过文件系统运行</p>
<pre><code>&lt;path-to-devtools-frontend&gt;/third_party/chrome/chrome-&lt;platform&gt;/chrome --custom-devtools-frontend=file://$(realpath out/Default/gen/front_end)
</code></pre><p>Tips: file://…在 Mac 和 Linux 上,文件 url 必须以三个斜杠开头,$(realpath out/Default/gen/front_end)扩展的 Devtools Frontend 目录路径必须为绝对路径.<br>PS: 为了避免代价昂贵的 Chromium 构建,可以在预构建的 Chromium 中运行 DevTools Frontend.例如,可以使用最新版本的 Chrome Canary,或者使用 third_party/chrome 中下载的二进制文件.</p>
<ul>
<li><p>实际演示</p>
<p>运行以下命令:</p>
<pre><code>./third_party/chrome/chrome-mac/Chromium.app/Contents/MacOS/Chromium --custom-devtools-frontend=file:///Users/yinwk/keryi/devtools-frontend/out/Default/gen/front_end/
</code></pre><video muted controls="controls" autoplay="autoplay" loop="loop" style="width:100%;"><br>  <source src="https://image.white-than-wood.zone/devtools_frontend/fileSystem.mp4" type="video/mp4"><br></video>

<p>终端显示:</p>
<p><img src="https://image.white-than-wood.zone/devtools_frontend/fileSystem.png" alt></p>
</li>
</ul>
</li>
<li><p>通过Server运行</p>
<p>将 out/Default/gen/front_end 的内容放入本地服务器,比如运行:</p>
<pre><code>python -m http.server
</code></pre><p>这里用的是http-server.</p>
<pre><code>cd out/Default/gen/front_end
http-server -p 8000
</code></pre><p><img src="https://image.white-than-wood.zone/devtools_frontend/remoteUrl.png" alt></p>
<ul>
<li><p>实际演示</p>
<p>运行以下命令:</p>
<pre><code>./third_party/chrome/chrome-mac/Chromium.app/Contents/MacOS/Chromium --custom-devtools-frontend=http://localhost:8000/
</code></pre><video muted controls="controls" autoplay="autoplay" loop="loop" style="width:100%;"><br>  <source src="https://image.white-than-wood.zone/devtools_frontend/remoteUrl.mp4" type="video/mp4"><br></video>

<p>终端显示:</p>
<p><img src="https://image.white-than-wood.zone/devtools_frontend/remoteUrlShow.png" alt></p>
</li>
</ul>
</li>
<li><p>通过远程连接运行</p>
<p>将 out/Default/gen/front_end 的内容放入本地服务器,比如运行:</p>
<pre><code>python -m http.server
</code></pre><p>这里用的是http-server.</p>
<pre><code>cd out/Default/gen/front_end
http-server -p 8000
</code></pre><p><img src="https://image.white-than-wood.zone/devtools_frontend/remoteUrl.png" alt></p>
<ul>
<li><p>实际演示</p>
<p>运行以下命令:</p>
<pre><code># 设置远程调试接口为 9222
./third_party/chrome/chrome-mac/Chromium.app/Contents/MacOS/Chromium --custom-devtools-frontend=http://localhost:8000/ --remote-debugging-port=9222
</code></pre><p>建立连接:</p>
<p>在任意地址栏中输入 <a href="http://localhost:9222" target="_blank" rel="noopener">http://localhost:9222</a> + EndPoint <a href="http://localhost:9222/json" target="_blank" rel="noopener">http://localhost:9222/json</a> -&gt; devtoolsFrontendUrl 值即可(等同于在当前页面直接打开 DevTools)</p>
<video muted controls="controls" autoplay="autoplay" loop="loop" style="width:100%;"><br>  <source src="https://image.white-than-wood.zone/devtools_frontend/hostedMode.mp4" type="video/mp4"><br></video>

<p>终端显示:</p>
<p><img src="https://image.white-than-wood.zone/devtools_frontend/hostedMode.png" alt></p>
</li>
<li><p>使用正式稳定版的 Chrome 演示运行</p>
<p>运行以下命令:</p>
<pre><code># 设置远程调试接口为 9222
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --custom-devtools-frontend=http://localhost:8000/ --remote-debugging-port=9222
</code></pre><p>建立连接:</p>
<p>在任意地址栏中输入 <a href="http://localhost:9222" target="_blank" rel="noopener">http://localhost:9222</a> + EndPoint <a href="http://localhost:9222/json" target="_blank" rel="noopener">http://localhost:9222/json</a> -&gt; devtoolsFrontendUrl 值即可(等同于在当前页面直接打开 DevTools)</p>
<video muted controls="controls" autoplay="autoplay" loop="loop" style="width:100%;"><br>  <source src="https://image.white-than-wood.zone/devtools_frontend/hostedModeChrome.mp4" type="video/mp4"><br></video>

<p>终端显示:</p>
<p><img src="https://image.white-than-wood.zone/devtools_frontend/hostedModeChrome.png" alt></p>
</li>
</ul>
</li>
</ul>
<p>上述所有方式均是在无 VPN 的情况下实现的运行.</p>
]]></content>
      <categories>
        <category>chrome-devtools-frontend</category>
      </categories>
      <tags>
        <tag>devtools-frontend</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>ios 16 体验分享</title>
    <url>/2022/07/17/ios16beta%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="ios-16-beta-3"><a href="#ios-16-beta-3" class="headerlink" title="ios 16 beta 3"></a>ios 16 beta 3</h1><p>现阶段 ios 16 内测版本已经出了 3 个版本,而今天要体验的 ios 16 就是最新的版本 —— ios 16 beta 3,在此可以直接通过 xcode beta ios 模拟器的方式直接体验.</p>
<blockquote>
<p>安装 xcode beta 版本</p>
</blockquote>
<p>通过<a href="https://developer.apple.com/cn/xcode/resources/" target="_blank" rel="noopener"> xcode 14.0 beta 3 </a>可下载 xcode beta 最新版本.</p>
<p><img src="https://image.white-than-wood.zone/ios16/download.png" alt></p>
<p>下载 xip 文件成功后,再解压安装.</p>
<ul>
<li>xcode 14.0 beta 3 (platform: ios 16 beta 3)</li>
</ul>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBeta.png" alt></p>
<ul>
<li>xcode 13.4.1 (platform: ios 15.5)</li>
</ul>
<p><img src="https://image.white-than-wood.zone/ios16/xcodePublic.png" alt></p>
<p>PS: Mac 磁盘空间至少留出 30G 方可解压安装 beta 版本,否则会总是出现’磁盘空间不足…’的提示.<br>Tips: xcode 正式版本至少留出 50G 才可下载解压安装.</p>
<blockquote>
<p>体验 ios 16 beta 3 模拟器</p>
</blockquote>
<ul>
<li><p>步骤</p>
<p>此步骤是为了照顾那些第一次使用 xcode 的童鞋,这里将演示如何创建 xcode 应用,添加、选择、运行 ios 模拟器的步骤,已经熟知的童鞋可以略过.</p>
<ul>
<li><p>创建新项目</p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaCreate.png" alt></p>
</li>
<li><p>选择创建 App 应用</p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaChooseApp.png" alt></p>
</li>
<li><p>项目以及组织、公司名称</p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaProduct.png" alt></p>
</li>
<li><p>WorkSpace、SwiftUI</p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaWorkSpace.png" alt></p>
</li>
<li><p>选择模拟器机型以及 ios 版本</p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaDevice.png" alt></p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaOS.png" alt></p>
</li>
<li><p>运行模拟器</p>
<p><img src="https://image.white-than-wood.zone/ios16/xcodeBetaRun.png" alt></p>
</li>
</ul>
</li>
<li><p>特性</p>
<p>现在是’硬菜’,在此将与 ios 15.5对比,来分享体验 ios 16,以此来体现出 ios 16 的特性.而在对比中,为了控制变量,选用机型都为 iPhone 13 Pro.</p>
<ul>
<li><p>锁屏界面个性化.</p>
<p>从 ios 16 开始,可以自定义锁屏界面的时间与日期样式,包含：颜色、背景、字型等,也能在锁屏加上实用小工具以快速查看,例如：天气、日历、智慧家庭等小工具. 此功能特性是 ios 16 最大的亮点,虽然在 xcode ios simulator 中 设置 -&gt; 壁纸 -&gt; 锁屏自定义(Lockscreen Widget) 并不存在,但可以通过锁屏右下角’相机’图标实行配置.<br><img src="https://image.white-than-wood.zone/ios16/lockscreens/changes.png" style="width: 40%"><br>锁屏的变动主要围绕着个性化进行展开,时间的上下部分都被 Apple 定义为了小组件区域,上部以单行图标配文字的形式进行展现,可以根据自己的需要选择日历、股市、健身、时钟、天气五个原生类目.<br><img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_1.png" style="width: 40%"><br>时间的下部区域是模块化的小组件区域,这个区域内的小组件包含了股市、家庭、健身、日历、时钟、提醒事项、天气、电池八个原生类目.和顶部小组件不同的是,这里的组件样式更加丰富,设计感更强,大小选择也更加多样化,可以根据自己的喜好进行随意搭配.值得一提的是,锁屏的小组件 Apple 已将相关权限开放给开发者,如果 App 进行适配,后续将可以在锁屏中看到更多精彩的内容.<br><img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_2.png" style="width: 40%"><br>中间时间部分,Apple 不仅调整了占位大小,还提供了阿拉伯数字、阿拉伯印度文、天城文三种文字,每种文字包含了 6 种不同的设计.针对色彩部分,可以在最下方选择背景适配色彩,也可以选择纯白色.</p>
<div style="display:flex;flex-flow: row nowrap;"><br> <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_3.png"><br> <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_3_1.png"><br> <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_3_2.png"><br></div><br>在 ios 16 中,可以将自己的锁屏以及桌面与专注模式进行关联,在开启不同专注模式的同时,锁屏和桌面会自动切换到自己先前设定的方案中.在不同的环境下你可能需要接受到信息不一样,例如在家需要看智能设备的状态,在工作的时候需要看日程计划,在摄影的时候需要关心日出日落.在小组件不同的同时,也可以换一张不同的壁纸,换个壁纸也换一个心情.当然在 xcode ios simulator 模拟器中现阶段是不能添加新的壁纸,也不存在’专注模式’,进而没有办法体验.<br><div style="display:flex;flex-flow: row nowrap;margin-bottom: 28px;"><br> <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_5.png"><br> <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_7.png"><br></div>

<p>ios 15.5 中并不能自定义锁屏,也不能自定义添加实用小工具,更不能通过锁屏右下角’相机’图标实行配置.<br><img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_old.png" style="width: 40%"></p>
</li>
<li><p>相册隐私加锁.</p>
<p>ios 16 在相册中’已隐藏’和’最近删除’选项中,已经支持加锁,增强用户对于相册中图片安全性的保护.</p>
<div style="display:flex;flex-flow: row nowrap;"><br> <img src="https://image.white-than-wood.zone/ios16/albums/ios16Albums.png"><br> <img src="https://image.white-than-wood.zone/ios16/albums/ios16AlbumsHidden.png"><br></div><br>ios 15.5 在相册中’已隐藏’和’最近删除’选项中,并没有加锁.<br><br><div style="display:flex;flex-flow: row nowrap;margin-bottom: 28px;"><br> <img src="https://image.white-than-wood.zone/ios16/albums/ios155Albums.png"><br> <img src="https://image.white-than-wood.zone/ios16/albums/ios155AlbumsHidden.png"><br></div>
</li>
<li><p>主界面底部页面改进.</p>
<p>ios 16 在界面底部显示 banner 位置的’点’替换为新的 Spotlight 搜索气泡,在桌面直接向下滑动即可打开. 与页面点一样,可以在搜索气泡上向左或向右滑动,以加快滚动浏览其他主屏幕页面. Spotlight 支持搜索系统和应用内的文本、照片、文件等,还能进行单位、货币换算,当 iPhone 接入网络后,可以直接用关键字搜索网页.</p>
<p><img src="https://image.white-than-wood.zone/ios16/views/ios16view.png" style="width: 40%"></p>
<p>ios 15.5 在界面底部显示 banner 位置的’点’还是原来的功能,向左或向右滑动,以加快滚动浏览其他主屏幕页面.</p>
<p><img src="https://image.white-than-wood.zone/ios16/views/ios155view.png" style="width: 40%"></p>
</li>
<li><p>短信息支持撤回以及二次编辑.</p>
<p>ios 16 在短信息方面也做了升级,短信息支持撤回以及二次编辑发送.</p>
<p><img src="https://image.white-than-wood.zone/ios16/message/ios16message.png" style="width: 40%"></p>
<p>ios 15.5 在短信息方面并不支持上述新功能.</p>
<p><img src="https://image.white-than-wood.zone/ios16/message/ios155message.png" style="width: 40%"></p>
</li>
<li><p>键盘方言方面追加了选项.</p>
<p>ios 16 在键盘方面针对拼音输入追加了四川话的选项.</p>
<p><img src="https://image.white-than-wood.zone/ios16/keyboard/ios16keyBoard.png" style="width: 40%"></p>
<p>ios 15.5 在键盘方面则不存在此选项.</p>
<p><img src="https://image.white-than-wood.zone/ios16/keyboard/ios155keyBoard.png" style="width: 40%"></p>
</li>
<li><p>锁屏通知底部显示.</p>
<p>由于 ios 16 在锁屏个性化上的重大改进(自定义锁屏界面、锁屏中上部设置实用小工具),导致锁屏通知底部显示.</p>
<div style="display:flex;flex-flow: row nowrap;margin-bottom: 28px;"><br> <img src="https://image.white-than-wood.zone/ios16/notice/notice.png"><br> <img src="https://image.white-than-wood.zone/ios16/notice/notice_2.png"><br></div>

<p>ios 15.5 锁屏通知仍然是屏幕中上部显示.</p>
<div style="display:flex;flex-flow: row nowrap;margin-bottom: 28px;"><br> <img src="https://image.white-than-wood.zone/ios16/notice/notice_3.png"><br> <img src="https://image.white-than-wood.zone/ios16/notice/notice_1.png"><br></div>
</li>
<li><p>健康App 用药提醒</p>
<p>ios 16 对于有日常药物服用需求的用户,可以在「健康」&gt;「 浏览」&gt;「用药」中设置并管理自己日常药物.设定好药品和服用时间后,ios 可以按时提示你去服用药物,并记录服药记录.此外,还支持一键导出自己的药品清单,方便购买时使用.</p>
<div style="display:flex;flex-flow: row nowrap;margin-bottom: 28px;"><br> <img src="https://image.white-than-wood.zone/ios16/medicine/medicine.png"><br> <img src="https://image.white-than-wood.zone/ios16/medicine/medicine_1.png"><br></div>

<p>ios 15.5 健康App 则不存在用药提醒这个功能.</p>
<p><img src="https://image.white-than-wood.zone/ios16/medicine/medicine_old.png" style="width: 40%"></p>
</li>
<li><p>兼容设备列表.</p>
<p>ios 16 已不再支持 iPhone 6S、6SPlus、7、7Plus、SE一代机型.</p>
<p><img src="https://image.white-than-wood.zone/ios16/device/deviceAdapter.png" alt></p>
</li>
</ul>
</li>
<li><p>憾事</p>
<p>比较遗憾的是,ios 16 有很多做了比较大改动的新功能特性,在 xcode ios simulator 模拟器上面体验不到,下面就来例举一下.</p>
<p>PS: 以下所有新功能特性,都是经过网上多渠道查询得论,未作实机验证.</p>
<ul>
<li><p>锁屏界面个性化.</p>
<p>新的壁纸类型包含人物、照片、随机、Emoji、天气、天文、颜色八个主题.其中,选择人物主题时,系统会自动检测照片中前景部分,将前景放置在组件和时间的前方,整体融合效果非常好.但在 xcode ios simulator 模拟器上现阶段是不能添加新的壁纸,且不能对壁纸实行个性化设置,如果对图片实行设置壁纸会出现莫名bug: 壁纸并没有设置,且呈为全黑.<br><div style="display:flex;flex-flow: column nowrap;"><br> <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_ios_3.png" style="width: 80%"><br> <div style="display:flex;flex-flow: row nowrap;width: 80%;margin: 0 auto;"><br>  <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_ios_1.png" alt><br>  <img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_ios_2.png" alt><br> </div><br></div><br>天气和天文这两种动态壁纸,则会根据你的定位和时间,实时变化锁屏的内容.说到这里,就不得不让人联想到这些锁屏和 AOD(全天候显示)的联系.自 iPhone 13 加入了 LTPO 的显示屏,支持显示刷新率在 10Hz 和 120Hz 之间动态调整.此外,近日在解析 ios 16 代码时发现了有关 AOD 相关的字段,显示 iPhone 14 Pro 和 iPhone 14 Pro Max 可能配备该功能.当然在 xcode ios simulator 模拟器上现阶段是不能添加新的壁纸,更无法设置动态壁纸,设置壁纸也会出现莫名bug,也无法通过内置搜索进行查询,进而无法实行设置.<br><img src="https://image.white-than-wood.zone/ios16/lockscreens/changes_ios.png" alt></p>
</li>
<li><p>强大的专注模式.</p>
<p>除了上面所提及的,专注模式与锁屏进行联动,实现锁屏壁纸和小组件的自动切换,它也可以同时定义解锁后显示某一页主屏,并切换 Apple Watch 的表盘,在 xcode ios simulator 模拟器中是不存在 ‘sspal’ 或者 ‘专注模式’ 的,进而也无法实行体验.<br><img src="https://image.white-than-wood.zone/ios16/sspal/sspal_1.png" alt><br>还提供了一项专注模式过滤条件.在这里可以针对日历、信息、浏览器、低电量模式、深色模式进行更加细致的设定.例如,当相应的专注模式开启时,日历会会被筛选,其余的日历无法查看,系统会自动开启等等.这样一来,专注模式的功能变得更加自动化、更加个性化.相信在以后的更新中,专注模式应该可以做到更多的事情.<br><img src="https://image.white-than-wood.zone/ios16/sspal/sspal_2.png" alt></p>
</li>
<li><p>地图多途经点路线规划</p>
<p>新版地图追加一项基础,但是又比较实用的功能多途经点路线规划,用户可以通过路线页面,追加自己需要到达的地点,实现途经点导航.目前该功能已在 11 个国家上线,国内上线时间未知.</p>
<p> <img src="https://image.white-than-wood.zone/ios16/maps/maps.png"></p>
<p>而在xcode ios simulator 模拟器上则是这番场景,GPS导航打开无法规划路线,坐标显示也是错误的.</p>
<p><img src="https://image.white-than-wood.zone/ios16/maps/ios16Maps.png" style="width: 40%"></p>
</li>
<li><p>视频中的实况文本</p>
<p>iOS 15 Apple 为我们带来了实况文本的功能,让我们可以找相册、相机、输入的时候快速提取到图像的文字信息,而在 iOS 16 中，Apple 再次加强了实况文本的功能,在任意包含文字的画面暂停视频,即可执行拷贝、翻译、查询、共享等操作,并且适用于照片、快速查看、Safari 和其他应用程序多种场景.</p>
<div style="display:flex;flex-flow: row nowrap;margin-bottom: 28px;align-items: center;"><br> <img src="https://image.white-than-wood.zone/ios16/videos/iosVideos.png"><br> <img src="https://image.white-than-wood.zone/ios16/videos/iosPictures.png"><br></div>

<p>而在xcode ios simulator 模拟器上则是无法提取任何的内容,视频实况文本功能是没有加上的.</p>
<p><img src="https://image.white-than-wood.zone/ios16/videos/videos.png" style="width: 40%"></p>
</li>
<li><p>照片支持快速抠图</p>
<p>在回顾 iOS 15 推出的看图查询 (Visual Lookup) 功能的时候,Apple 还向我们介绍了借助 CoreML 和神经网络引擎实现的全新的抠图功能.只要在照片上长按,可以快速抠出图片的前景部分,这个功能不仅适用于现实拍摄的照片,虚拟的动画也同样适用.将抠下来的图片按住不放,可以直接切换后台发送到即时通讯应用中.（经测试 iPhone 上 iMessage、Line 等均支持,iOS 微信暂不支持、iPadOS 微信支持）.</p>
<p><img src="https://image.white-than-wood.zone/ios16/pictures/ios16Pictures.png"></p>
<p>而在xcode ios simulator 模拟器上则是无法实行对百度下载的人像抠图功能,长按没有反应,是不存在全新的抠图功能的.</p>
<p><img src="https://image.white-than-wood.zone/ios16/pictures/pictures.png" style="width: 40%"></p>
</li>
</ul>
</li>
<li><p>技术特性以及问题</p>
<ul>
<li><p>ios 16 为了帮助使每行的长度在视觉上保持平衡,其中 TextKit,尤其是 TextKit 2,大大改进了换行算法,对于那些想要保持与 ios 15 相同外观以及追求’UI像素完美’的开发者可要注意哦~</p>
<p><img src="https://image.white-than-wood.zone/ios16/textview/ios15_5.png"><br><img src="https://image.white-than-wood.zone/ios16/textview/ios15_4.png" style="width:100%;"></p>
<p>从上面的图中可以看出,换行算法的修改还是很大的,为了始终保持 TextKit 2 两侧的间隙相同/平衡,苹果工程师舍弃了一些外观包袱和’UI像素完美’的标准.</p>
<ul>
<li><p>解决方案: </p>
<p>对于那些势必保持相同外观与追求’UI像素完美’的开发者来说,苹果的开发者论坛给出了一些可实行的方案,可以尝试一下.</p>
<p><img src="https://image.white-than-wood.zone/ios16/textview/resolve.png" style="width:100%;"></p>
</li>
<li><p>调用绘制图形 OpenGL API 崩溃</p>
<p>根据苹果开发者论坛 <a href="https://developer.apple.com/forums/thread/707644" target="_blank" rel="noopener">OpenGL crashes (iOS 16)</a>,当在 ios 16 beta simulator 模拟器中调用 presentRenderBuffer 时,OpenGL 崩溃,在 iOS 15 或更低版本运行正常.</p>
<ul>
<li><p>解决方案:</p>
<p>根据苹果的开发者论坛中某开发者所给的回复,已经在 ios 16 beta 3 中进行了修复.也就证明了 beta 3 之前的 ios 16 beta 版本都有调用 OpenGL presentRenderBuffer 以及 EXC_BAD_ACCESS 会出现崩溃的情况,开发小伙伴们注意了哦~</p>
<p><img src="https://image.white-than-wood.zone/ios16/crashed/openGL.png" style="width:100%;"></p>
<p>Tips: 此回复并没有得到确认,可能还是需要实践验证一下是否可行.</p>
</li>
</ul>
</li>
<li><p>Lockscreen Widget(锁屏小工具) 支持 ios 15</p>
<p>有没有一种可能,在现有的 Widget Bundle 中添加 Lock Screen Widget 并仍然支持 ios 15,怎么做可以实现呢?<br>答案是: 根据苹果开发者论坛和 stackoverflow 可知,上述代码应该是有效的,但也亟需实践验证可行性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> struct SomeWidgetBundle: WidgetBundle &#123;</span><br><span class="line">   @WidgetBundleBuilder</span><br><span class="line">   <span class="keyword">var</span> body: some Widget &#123;</span><br><span class="line">       AlwaysAvailableWidget()</span><br><span class="line">       LockScreenWidget()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> struct LockScreenWidget: Widget &#123;</span><br><span class="line">   <span class="keyword">var</span> body: some WidgetConfiguration &#123;</span><br><span class="line">     if #available(iOSApplicationExtension 16.0, *) &#123;</span><br><span class="line">       <span class="keyword">return</span> StaticConfiguration(</span><br><span class="line">         kind: <span class="string">"some.kind"</span>,</span><br><span class="line">         provider: LockScreenWidgetTimelineProvider()</span><br><span class="line">       ) &#123; provider <span class="keyword">in</span></span><br><span class="line">         Text(<span class="string">"Some view"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       .configurationDisplayName(<span class="string">"Some display name"</span>)</span><br><span class="line">       .description(<span class="string">"Some description"</span>)</span><br><span class="line">       .supportedFamilies([.accessoryCircular])</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> EmptyWidgetConfiguration()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  总得来说,ios 16 对于用户的安全性、便捷性、个性化和使用体感做的更加细致入微了,苹果在逐步将 iPhone 做的更加向纵深方向发展,而在横向创新领域,则并没有看到任何的扩展化,可能苹果是想现阶段在此 iPhone 的现功能基础上进行维护和深耕吧.</p>
]]></content>
      <categories>
        <category>ios16</category>
      </categories>
      <tags>
        <tag>ios16</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的Javascript</title>
    <url>/2019/05/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Javascript/</url>
    <content><![CDATA[<h1 id="lt-上篇-gt-整理-词法作用域、this以及原型对象"><a href="#lt-上篇-gt-整理-词法作用域、this以及原型对象" class="headerlink" title="&lt;上篇&gt;整理: 词法作用域、this以及原型对象"></a>&lt;上篇&gt;整理: 词法作用域、this以及原型对象</h1><h2 id="一、词法作用域"><a href="#一、词法作用域" class="headerlink" title="一、词法作用域"></a>一、词法作用域</h2><blockquote>
<p>浏览器执行JavaScript语言</p>
</blockquote>
 <p>在浏览器引擎执行JS之前,JS就已经经过了浏览器编译器的编译,也就是词法分析和语法分析,将关键字、保留字、自定义变量以及函数根据词法解释和抽象语法树进行解析,并且按照优先级和词法作用域放到应有的位置上,最后通过浏览器引擎执行</p>

<blockquote>
<p>词法分析</p>
</blockquote>
<pre><code>词法分析分为: 分词和词法解释。
分词就是将各个表达式根据空格分开,再根据关键字、保留字等词法进行匹配词法解释。
</code></pre><blockquote>
<p>语法分析</p>
</blockquote>
<pre><code>语法分析就是根据抽象语法树上面的语法解释,类型、强制类型转换、ToNumber、ToString和ToPrometive等泛泛含义对表达式解构。
</code></pre><blockquote>
<p>引擎执行</p>
</blockquote>
<pre><code>词法分析和语法分析之后,浏览器就会将已经编译好的JS代码,交给引擎执行。
</code></pre><blockquote>
<p>LHS、RHS</p>
</blockquote>
 <p>词法作用域限定了变量和函数产生效果的范围,分为三种: 全局作用域、函数作用域以及块级作用域(ES6引入),为了更好的理解这三种作用域,以及其中变量和函数的定义与赋值,从概念上引入了LHS和RHS,用来解释引擎执行时,变量的赋值目标以及赋值操作的源头</p>

<pre><code>LHS: 赋值操作的目标是谁
RHS: 谁才是赋值操作的源头
</code></pre><p> <b>例子</b></p>
<pre><code>//定义foo函数为LHS;获取变量a为RHS;var b = 为LHS;获取变量a和b为RHS
function foo(a) {
    var b = a;
    return a + b;
}
//var c = 为LHS;foo(10)为RHS;将实参10赋值给虚参a为LHS
var c = foo(10);
//console.log为RHS;获取变量c为RHS
console.log(c);
//五个表达式中,共有四个LHS和五个RHS
</code></pre><blockquote>
<p>词法作用域链</p>
</blockquote>
  <p>简单来说,作用域链使内部作用域内的变量和函数变成了私密且不可访问的,保证了内部变量不会污染到全局以及外部作用域,以免造成变量名冲突等不可预知的错误,外部作用域是访问不到以及操作不到的,而内部作用域的优先级却是越来越高,可以访问和操作到自己以及外部N层作用域的变量和函数</p>

<p><b>例子</b></p>
<pre><code>var a = &quot;hello&quot;;
function foo() {
    var b = &quot;world&quot;;
    //foo函数作用域,可以访问到和操作到a,这里打印&quot;hello&quot;
    console.log(a);
    function bar() {
        var c = &quot;wenkai.yin&quot;;
        //bar函数作用域,可以访问到和操作到c,b,a,这里打印&quot;wenkai.yin&quot; &quot;world&quot; &quot;hello&quot;
        console.log(c, b, a);
    }
    bar();
    //这里报错ReferrenceError c is not defined
    //因为foo函数作用域中访问不到和操作不到优先级最高的bar函数作用域中的私密变量c,
    //且在本作用域下找不到变量c,由此向外部作用域,也就是全局作用域中查找变量c,发现c并没有定义,更别说给c赋值了,
    //所以这时候会报ReferrenceError c is not defined
    console.log(c);
}
foo();
</code></pre><blockquote>
<p>变量提升</p>
</blockquote>
<p>综上所述,变量和函数的定义是在浏览器编译器编译时,具体应该是在词法分析的词法解释时,就已经定义好了变量和函数的位置,之后的引擎执行才是进行赋值,由此会出现变量提升的情况</p>

<p><b>例子一</b></p>
<pre><code>console.log(a);
var a = 14;
//这里打印的值为undefined,这里不会报错,因为变量a已经在浏览器编译中就定义了,执行顺序应该是:
//var a;
//console.log(a);
//a = 14;
</code></pre><p><b>例子二</b></p>
<pre><code>a = 14;
var a;
console.log(a);
//这里打印的值为14,执行顺序应该是:
//var a;
//a = 14;
//console.log(a);
</code></pre><p><b>例子三</b></p>
<pre><code>console.log(a);
let a = 14;
//这里会直接报错ReferrenceError a is not defined
//因为在ES6中let和const不会出现变量提升,let和const并不只是为了进行区分变量和常量才产生的
//其核心是为了产生块级作用域,块级作用域也遵从词法作用域的规则以及作用域链,所以才不会出现变量提升
//实际执行结果应该是:
//console.log(a);
//{
//  let a = 14;
//}
//这时候全局作用域中是没办法访问和操作块级作用域中的变量a的,由此判断a未定义,才会报错ReferrenceError a is not defined
</code></pre><p><b>例子四</b></p>
<pre><code>if(a in window) {
    var a = 10;
}
console.log(a);
//这里会直接打印:10
//这里是存在变量提升的概念的,变量a的定义是在浏览器编译的词法分析的词法解释时,就已经确定了a的位置,所以变量在window对象中是存在的
//实际浏览器引擎执行结果应该是:
//var a;
//if(a in window) {
//      a = 10;
//}
//console.log(a);
</code></pre><blockquote>
<p>eval和with</p>
</blockquote>
<p>eval通过将字符串转换为Javascript语句和表达式,来改变某个词法作用域;with通过创造词法作用域,使得某个对象属性获得with词法作用域中变量的值</p>

<p><b>例子一</b></p>
<pre><code>var b = &quot;bigger&quot;; 
function foo(sentence) {
    eval(sentence);
    console.log(b);
}
foo(&quot;var b = &apos;smaller&apos;&quot;);
//这里打印smaller,本来foo的词法作用域中是不存在变量b的,而eval改变了foo的词法作用域,使得foo词法作用域中出现了变量b
</code></pre><p><b>例子二</b></p>
<pre><code>var obj = {a: &quot;foo&quot;, b: &quot;bar&quot;};
with(obj) {
    a = &quot;bar&quot;;
    b = &quot;foos&quot;;
}
console.log(obj);
//这里打印{a: &quot;bar, b: &quot;foos&quot;},with创造了词法作用域,使得其中的变量赋值操作是私密的,不可访问且不可操作的
console.log(a);
console.log(b);
//变量a和b在全局作用域中都没有定义,只有在with创造的作用域下,进行赋值,
//所以这里会报错:ReferrenceError a is not defined;ReferrenceError b is not defined
</code></pre><p>eval由于对字符串词法和语法分析比较复杂,字符串中的变量和表达式会永久的保留在内存中的,不会被浏览器垃圾回收机制回收,会造成网站的性能较差的原因,被官方不推荐使用;而with由于也会造成网站性能变差,并且没有必要使用with改变对象属性值的原因,被官方列为禁用表达式语句</p>

<blockquote>
<p>作用域与闭包</p>
</blockquote>
<p>闭包跟作用域有着千丝万缕的联系,有时候你会不经意间使用到,但是却不知是闭包,其实你平时使用的好多场景都有闭包</p>

<pre><code>闭包简单来说,可以解释为:A函数里面定义了一个B函数,B函数在非A函数作用域下执行,在A函数释放的情况下,仍能访问和操作A函数作用域下的变量和函数
</code></pre><p>这就是闭包,在业务开发过程中,我们会遇到很多此类示例</p>

<p><b>例子一</b></p>
<pre><code>function foo() {
    var name = &quot;wenkai.yin&quot;;
    setTimeout(function time() {
        console.log(name);
        name = &quot;Gary&quot;;
        console.log(name);
    }, 1000);
}    
foo();
//在这里打印: 
//wenkai.yin
//Gary
//这就是一个闭包示例,名为time的函数在foo函数作用域下定义,在foo函数调用释放之后,在setTimeout这个函数作用域下执行,仍能访问和操作到foo函数作用域下的变量name,这就形成了一个闭包,变量name,明明应该随着foo函数的调用释放被销毁,但是却没有,在内存中获得保留,形成一块儿闭包区域
</code></pre><p><b>例子二</b></p>
<pre><code>function foo() {
    var name = &quot;world&quot;;
    function bar() {
        console.log(name);
        name = &quot;hello&quot;;
        console.log(name);
    }
    return bar;
}
foo()();
//这里打印:
//world
//hello
//在这里bar函数是在foo函数词法作用域下定义的,但是在foo函数调用释放之后,bar函数在全局作用域下还是能够访问和操作foo函数作用域下的本应被销毁掉的变量name,说明这时候变量name并没有在内存中显示,反而保留了下来,形成了一块儿闭包区域
</code></pre><p><b>例子三</b></p>
<pre><code>function deep() {
    for(var i = 0; i &lt; 10; i++) {
        setTimeout(function time() {
            console.log(i);
        }, i * 1000);
    }
}
deep();
//在这里会打印: 10个10
//由于延时器异步的关系,当浏览器引擎遇到异步代码时,会先把异步代码放到异步队列中,先执行同步代码,等待到同步代码执行完毕之后,再去轮询异步队列中的异步代码,而这时候for循环已经结束,i的值为10,所以打印了10个10
//当然里面也存在闭包,例子一中已经说明

//修复异步问题,使用闭包方法:
function deep() {
    for(var i = 0; i &lt; 10; i++) {
        setTimeout((function time(i) {
            var j = i;
            return function () {
                console.log(j);
            }
        })(i), i * 1000);
    }
}
deep();
//在这里会打印: 0-9十个数字
//j是time函数词法作用域下的变量,而for循环中的变量i通过参数的方式传入time IIFE自执行函数表达式,
//这时time函数词法作用域下返回一个匿名函数,且不在time函数词法作用域下而是在setTimeout函数作用域下执行,这时候形成了十个闭包,内存中保留了time函数释放之后的内部的i和j变量,形成了十个闭包区域

//修复异步问题,使用let关键字:
function deep() {
    for(let i = 0; i &lt; 10; i++) {
        setTimeout(function time() {
            console.log(i);
        }, i * 1000);
    }
}
deep();
//在这里会打印: 0-9十个数字
//实际上在这里每一次循环都会形成一个块级作用域,块级作用域下定义的time函数,
//而time函数在setTimeout函数词法作用域下执行,仍然可以获取到块级作用域下的变量i,这时的变量i是保留在内存当中的,形成了类似于闭包的十个块级作用域闭包区域
</code></pre><blockquote>
<p>IIFE自执行函数表达式</p>
</blockquote>
<p>IIFE自执行函数表达式的出现本质上是为了防止变量名称冲突,避免污染全局变量,利用函数词法作用域,做了一处自动执行的私密装置</p>

<p><b>例子</b></p>
<pre><code>var name = &quot;global&quot;;
(function IIFE(global) {
    var name = &quot;IIFE&quot;;
    console.log(name, global.name);
})(window);
console.log(name);
//在这里打印: IIFE global
//global
//体现了全局作用域下的变量name和IIFE函数词法作用域下的变量name的不同含义,且IIFE函数词法作用域下的变量不会造成全局变量的污染,不会造成命名冲突,是私密的。

//还有一种自执行函数表达式的写法
var name = &quot;global&quot;;
(function IIFE(fn) {
    fn(window);
})(function foo(global) {
    var name = &quot;IIFE&quot;;
    console.log(name, global.name);
});
console.log(name);
//在这里打印: IIFE global
//global
//同上含义,只不过传入的参数方式不同,一种是传递window参数,一种是直接传递函数
</code></pre><blockquote>
<p>try…catch…模拟块级作用域</p>
</blockquote>
 <p>早在ES6 let和const关键字出现之前,就已经有团队和公司在开始模拟块级作用域了,其中Google公司的Tracer解析编译工具在编译和模拟块级作用域时,编译出来的ES5代码,就是使用了try{} catch() {}这种方式</p>

<p><b>例子</b></p>
<pre><code>try {
    throw undefined;
} catch(a) {
    b = 12;
    console.log(b);
}
console.log(b);
//在这里打印:
//12
//ReferrenceError:b is not defined
//这种机制在ES3中就早已经出现了
</code></pre><h2 id="二、this动态作用域"><a href="#二、this动态作用域" class="headerlink" title="二、this动态作用域"></a>二、this动态作用域</h2><p>this动态作用域是公认的js闭包之外的第二个难点,有很多人不明白this所指代的是什么,是对象?词法作用域?还是上下文?其实都不是,让我们来一起揭开this的面纱</p>

<blockquote>
<p>this是什么</p>
</blockquote>
<pre><code>this实际上是函数对象调用执行时所处的上下文对象(这里的上下文对象指的并不是作用域)
</code></pre><blockquote>
<p>this指向分类</p>
</blockquote>
<pre><code>this指向的分类一共有四种: 
1. 普通函数调用执行,默认指向window
2. 使用对象调用执行,软绑定指向该对象
3. 使用apply、call或者bind绑定在某个对象上执行,硬绑定指向该对象
4. 使用new语法糖构造器调用执行,new绑定指向函数对象本身
</code></pre><p><b>例子一</b></p>
<pre><code>var a = 99;
function foo() {
    console.log(this.a);
}     
foo();
//在这里打印:
//99
//由于是普通调用在全局作用域下执行,此时的this指向的是window,
//由此console.log(window.a),打印的是99
</code></pre><p><b>例子二</b></p>
<pre><code>var $a = &apos;world&apos;;
var $obj = {
    $a: &apos;9hello9&apos;,
    b() {
        console.log(this.$a);
    }
};
$obj.b();
//在这里打印:
//9hello9
//由于是使用对象调用执行,软绑定this指向该对象
//由此console.log($obj.a),打印的是9hello9
</code></pre><p><b>例子三</b></p>
<pre><code>var $a = &apos;6world6&apos;;
var $obj = {
    $a: &apos;9hello9&apos;,
    b() {
        console.log(this.$a);
    }
};
var $_obj = {
    $a: &apos;7fast7&apos;
};
$obj.b.apply($_obj);
$obj.b.call($_obj);
//在这里打印:
//7fast7
//7fast7
//由于是使用apply、call或者bind绑定在某个对象上调用执行,硬绑定this指向该对象
//由此console.log($_obj.$a),打印的是7fast7
</code></pre><p><b>例子四</b></p>
<pre><code>var $a = &apos;6world6&apos;;
function Fo($a) {
    this.$a = $a;
}
var $fo = new Fo(&apos;9hello9&apos;);
console.log($fo.$a);
//在这里打印:
//9hello9
//由于是使用new语法糖构造器调用执行,new绑定指向函数对象本身
//由此console.log($fo.$a),打印的是9hello9
</code></pre><blockquote>
<p>this指向优先级</p>
</blockquote>
<pre><code>this默认绑定 &lt; 对象软绑定 &lt; apply、call和bind硬绑定 &lt; new绑定
</code></pre><p><b>对比对象软绑定和apply、call以及bind硬绑定的优先级</b></p>
<pre><code>function bar() {
    console.log(this.$a);
}
var $obj = {
    $a: &quot;5we5&quot;,
    bar: bar
};
var $_obj = {
    $a: &quot;6happy6&quot;
};
$obj.bar.apply($_obj);
$obj.bar.call($_obj);
//在这里打印:
//6happy6
//6happy6
//由此可见,apply、call以及bind硬绑定的优先级大于对象软绑定
</code></pre><p><b>对比对象软绑定和new绑定的优先级</b></p>
<pre><code>function bar() {
    console.log(this.$a);
}
var $obj = {
    $a: &quot;4snake4&quot;,
    bar: bar
};
var $result = new $obj.bar();
//在这里打印:
//undefined
//由此可见,new绑定的优先级大于对象软绑定
</code></pre><p>对比apply、call以及bind硬绑定和new绑定的优先级,由于apply/call和new不能同时使用,所以我们演示就使用bind硬绑定与new绑定进行优先级比较</p>

<pre><code>function Fo($a) {
    this.$a = $a;
}
var bar = {
    $a: &quot;8money8&quot;
};
var fBind = Fo.bind(bar);
var _bind = new fBind(&quot;3sheep3&quot;);
console.log(_bind.$a);
//在这里打印:
//3sheep3
//由此可见,new绑定的优先级大于apply、call以及bind硬绑定
</code></pre><blockquote>
<p>polyfill兼容模拟bind硬绑定</p>
</blockquote>
<pre><code>if(!Function.prototype.bind) {
    Function.prototype.bind = function (context) {
        if(typeof this !== &quot;function&quot;) {
            throw new TypeError(&quot;被绑定的对象并不是函数对象!&quot;);
        }
        let self = this,
            args = Array.from(arguments),
            fBind;
        args.shift();    
        function F() {}
        fBind = function () {
            let innerArgs = Array.from(arguments);
            return self.apply(this instanceof fBind ? this : context, [...args, ...innerArgs]);
        };
        F.prototype = self.prototype;
        fBind.prototype = new F();
        return fBind;
    };
}
//polyfill兼容模拟bind硬绑定大概上就是如此
//测试硬绑定,非new绑定模式
function Person(name, age) {
    this.name = name;
    this.age = age;
}
var $obj = {
    name: &quot;Gary&quot;,
    age: 26
};
var $_obj = Person.bind($obj);
var $obj_ano = {
    name: &quot;Clay yin&quot;,
    age: 29,
    $_obj
};
var $obj_empty = {};
$_obj(&quot;wenkai.yin&quot;, 27);
console.log($obj.name, $obj.age);
$obj_ano.$_obj(&quot;yin.wenkai&quot;, 25);
console.log($obj.name, $obj.age);
console.log($obj_ano.name, $obj_ano.age);
$_obj.apply($obj_empty, [&quot;Gary Yin&quot;, 24]);
console.log($obj_empty.name, $obj_empty.age);
console.log($obj.name, $obj.age);
//在这里打印:
//wenkai.yin 27
//yin.wenkai 25
//Clay yin 29
//undefined undefined
//Gary Yin 24

//测试硬绑定,new绑定模式
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function () {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var obj = {
    name: &quot;Gary Yin&quot;,
    age: 24
};
var fBind = Person.bind(obj);
var person = new fBind(&quot;wenkai.yin&quot;, 26);
console.log(person.name, person.age);
person.introduce();
console.log(obj.name, obj.age);
//在这里打印:
//wenkai.yin 26
//hello, I&apos;m wenkai.yin, 24 year&apos;s old
//Gary Yin 24
</code></pre><blockquote>
<p>polyfill兼容模拟softBind软绑定</p>
</blockquote>
<pre><code>Function.prototype.softBind = function (context) {
    if(typeof this !== &quot;function&quot;) {
        throw new TypeError(&quot;被绑定的对象并不是函数对象!&quot;);
    }
    var self = this,
        args = Array.from(arguments),
        fBind;
    args.shift();    
    function F() {}
    fBind = function () {
        var innerArgs = Array.from(arguments);
        return self.apply((!this || this === window) ? context : this, [...args, ...innerArgs]);
    };
    F.prototype = self.prototype;
    fBind.prototype = new F();
    return fBind;
};

//polyfill兼容模拟softBind软绑定大概上就是如此
//测试软绑定,非new绑定模式
function Person(name, age) {
    this.name = name;
    this.age = age;
}
var $obj = {
    name: &quot;Gary&quot;,
    age: 26
};
var $_obj = Person.softBind($obj);
$_obj(&quot;wenkai.yin&quot;, 27);
console.log($obj.name, $obj.age);
var $obj_ano = {
    name: &quot;Clay yin&quot;,
    age: 29,
    $_obj
};
var $obj_empty = {};
$obj_ano.$_obj(&quot;Gary Yin&quot;, 28);
console.log($obj_ano.name, $obj_ano.age);
console.log($obj.name, $obj.age);
$_obj.apply($obj_empty, [&quot;yin.wenkai&quot;, 24]);
console.log($obj_empty.name, $obj_empty.age);
console.log($obj.name, $obj.age);
//在这里打印:
//wenkai.yin 27
//Gary Yin 28
//wenkai.yin 27
//yin.wenkai 24
//wenkai.yin 27

//测试软绑定,new绑定模式
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function () {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var $obj = {
    name: &quot;Clay yin&quot;,
    age: 29
};
var $_obj = Person.bind($obj);
var person = new Person(&quot;Gary_yin&quot;, 22);
console.log(person.name, person.age);
person.introduce();
console.log($obj.name, $obj.age);
//在这里打印:
//Gary_yin 22
//hello, I&apos;m Gary_yin, 22 year&apos;s old
//Clay yin 29
</code></pre><blockquote>
<p>polyfill兼容模拟new绑定</p>
</blockquote>
<pre><code>function _new() {
    var args = Array.from(arguments),
        Collapse = args.shift(),
        _obj = {};
    _obj.__proto__ = Collapse.prototype;
    var target = Collapse.apply(_obj, args);
    return typeof target === &quot;object&quot; ? target : _obj;
}
//测试模拟new绑定
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function() {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var person = _new(Person, &quot;Gary&quot;, 26);
console.log(person.name, person.age);
person.introduce();
console.log(Object.getPrototypeOf(person) === Person.prototype);
console.log(Person.prototype.isPrototypeOf(person));
//在这里打印:
//Gary 26
//hello, I&apos;m Gary, 26 year&apos;s old
//true
//true
</code></pre><blockquote>
<p>注意点</p>
</blockquote>
<p>this与函数调用执行的位置的上下文对象息息相关,有时候千万不要被一些障眼法蒙蔽</p>

<p><b>例子一</b></p>
<pre><code>var name = &quot;Gary Yin&quot;;
function bar() {
    console.log(this.name);
}
var obj = {
    name: &quot;wenkai.yin&quot;,
    bar
};
var _bar = obj.bar;
_bar();
//在这里打印:
//Gary Yin
//此时bar函数调用执行位置的上下文对象,并不是对象软绑定,而是全局对象window
</code></pre><p><b>例子二</b></p>
<pre><code>function say() {
    console.log(this.name);
}
var obj = {
    name: &quot;obj_one&quot;
};
var objTwo = {
    name: &quot;obj_two&quot;
};
var objThree = {
    name: &quot;obj_three&quot;
};
var foo = say.bind(obj).bind(objTwo).bind(objThree);
foo();
//在这里打印:
//obj_one
//此时say函数调用执行this只硬绑定指向了一层上下文对象,那就是obj,剩下的两层硬绑定,都是bind硬绑定内部返回的函数对象fBind进行的,与say函数没有任何关系
</code></pre><p><b>例子三</b></p>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function() {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var $obj = {
    name: &quot;Gary&quot;,
    age: 26
};
var fBind = Person.bind($obj);
var person = new fBind(&quot;wenkai.yin&quot;, 28);
console.log(person.name, person.age);
person.introduce();
console.log($obj.name, $obj.age);
//在这里打印:
//wenkai.yn 28
//hello, I&apos;m wenkai.yin, 28 year&apos;s old
//Gary 26
//根据polyfill兼容模拟的bind,我们可以看出,当this指向其构造器fBind时,也就是new返回的函数,进行构造调用时,外部绑定的函数对象的this就不会指向绑定的对象,而是会指向构造器fBind,所以引用对象person委托关联指向fBind,并通过原型链指向Person。
//于是,名称和年龄是外部参数wenkai.yin和28,可以调用执行原型链上面的函数introduce,而$obj对象上面的属性值并没有发生任何改变
</code></pre><h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><p>原型链,从本质上来讲,就是引用对象与普通对象、引用对象与函数对象之间委托关联,当建立起委托关联后,引用对象本身的隐式原型<strong>proto</strong>与构造函数的显式原型prototype就会形成引用关系,使得引用对象不仅可以调用本身被显式绑定的属性值,也可以追本溯源的通过原型链调用构造函数原型链上面的属性和函数方法。</p>

<blockquote>
<p>伪继承</p>
</blockquote>
<p>继承在传统面向对象的语言中是子类直接复制父类的属性和方法,复制后,子类上是直接存在其父类的属性和方法的,但是在JS中,继承并不是复制,而是委托关联,通过原型链向父级搜索查找,直至继承树的顶端Object.prototype也就是Object对象的显式原型。</p>

<p><b>例子一</b></p>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function () {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
function Gary(name, age, hobby) {
    Person.call(this, name, age);
    this.hobby = hobby;
}
//以下三行就是JS伪继承委托关联的精髓s
//将子类的显式原型的隐式原型指向父类的显式原型
function F() {}
F.prototype = Person.prototype;
Gary.prototype = new F();

Gary.prototype.hobbyMine = function () {
    console.log(`${this.name}, I love ${this.hobby}`);
};
var gary = new Gary(&quot;wenkai.yin&quot;, 26, &quot;program&quot;);
console.log(gary.name, gary.age, gary.hobby);
gary.introduce();
gary.hobbyMine();
//在这里打印:
//wenkai.yin 26 program
//hello, I&apos;m wenkai.yin, 26 year&apos;s old
//wenka.yin, I love program
</code></pre><p><b>例子二</b></p>
<pre><code>//还是同样剧情的例子,不过这一次我们要换一下继承方式
//并且深究一下内部的委托关联原型链
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function () {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
function Gary(name, age, hobby) {
    Person.call(this, name, age);
    this.hobby = hobby;
}
//以下三行就是JS伪继承委托关联的精髓
//将子类的显式原型的隐式原型指向父类的显式原型
Gary.prototype = Object.create(Person.prototype);

Gary.prototype.hobbyMine = function () {
    console.log(`${this.name}, I love ${this.hobby}`);
};
var gary = new Gary(&quot;wenkai.yin&quot;, 26, &quot;program&quot;);
console.log(gary.name, gary.age, gary.hobby);
gary.introduce();
gary.hobbyMine();
console.log(gary.__proto__ === Gary.prototype);
console.log(Gary.prototype.__proto__ === Person.prototype);
console.log(Object.getPrototypeOf(gary) === Gary.prototype);
console.log(Object.getPrototypeOf(Object.getPrototypeOf(gary)) === Person.prototype);
console.log(Gary.prototype.isPrototypeOf(gary));
console.log(Person.prototype.isPrototypeOf(Gary.prototype));
//在这里打印:
//wenkai.yin 26 program
//hello, I&apos;m wenkai.yin, 26 year&apos;s old
//wenkai.yin, I love program
//true
//true
//true
//true
//true
//true
//这里使用了两个方法,isPrototypeOf和getPrototypeOf。
//a.isPrototypeOf(b)是判断b是否是在a的原型链上,可以用于检查引用对象和其他任意对象之间的委托关联关系
//Object.getPrototypeOf(b) === a与b.__proto__ === a的效果相同的,Object.getPrototypeOf(b)也只不过是提取了b对象中的隐式原型与a对象或者a函数对象的显式原型进行比对。
</code></pre><blockquote>
<p>polyfill兼容模拟Object.create方法</p>
</blockquote>
<p>从polyfill兼容模拟Object.create方法的源代码来看,利用的是原型链的机制,将子类与父类或者说是子对象与父对象委托关联起来。使用Object.create的优势,首先,不需要再去考虑委托关联构造调用时的参数问题,使用第三函数对象,也就是F函数中转承接;第二,适用于引用对象与任意对象(普通对象、函数对象)之间的委托关联。</p>

<pre><code>if(!Object.create) {
    Object.create = function(o) {
        function F() {}
        F.prototype = o;
        return new F();
    };
}
</code></pre><p><b>例子一</b></p>
<pre><code>var a = {
};
var b = {
    age: &quot;b&quot;
};
a = Object.create(b);
console.log(a.age);
//在这里打印:
//b
</code></pre><p><b>例子二</b></p>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.introduce = function () {
    console.log(`hello, I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
function Gary(name, age, hobby) {
    Person.call(this, name, age);
    this.hobby = hobby;
}
//以下三行就是JS伪继承委托关联的精髓
//将子类的显式原型的隐式原型指向父类的显式原型
Gary.prototype = Object.create(Person.prototype);

Gary.prototype.hobbyMine = function () {
    console.log(`${this.name}, I love ${this.hobby}`);
};
var gary = new Gary(&quot;wenkai.yin&quot;, 26, &quot;program&quot;);
console.log(gary.name, gary.age, gary.hobby);
gary.introduce();
gary.hobbyMine();
//在这里打印:
//wenka.yin 26 program
//hello, I&apos;m wenkai.yin, 26 year&apos;s old
//wenkai.yin, I love program
</code></pre><blockquote>
<p>注意点</p>
</blockquote>
<p>instanceof通常是检查引用对象是否在某一个函数对象的原型链上,不过也只是作用于引用对象和函数对象之间,并不能检查引用对象和普通对象之间的委托关联关系</p>

<p><b>例子一</b></p>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
var gary = new Person(&quot;wenkai.yin&quot;, 26);
console.log(gary instanceof Person);
console.log(gary instanceof Object);
//在这里打印:
//true
//true
</code></pre><p><b>例子二</b></p>
<pre><code>var a = {
    name: &quot;Gary&quot;,
    age: 26
};
var b = {
    name: &quot;wenkai.yin&quot;,
    age: 28
};
a = Object.create(b);
console.log(Object.getPrototypeOf(a) === b);
console.log(b.isPrototypeOf(a));
//在这里打印:
//true
//true
//当遇到检查引用对象和普通对象之间的委托关联,判断引用对象是否在普通对象的原型链上时,
//就不能使用instanceof,我们这里使用的是isPrototypeOf,b.isPrototypeOf(a)
</code></pre><p>原型链的顶部,也就是Object.prototype,Object对象的显式原型,那按照原型链的规则来看,原型链的顶部Object对象的显式原型的隐式原型指向哪儿呢? 答案是null</p>

<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
var gary = new Person(&quot;wenkai.yin&quot;, 26);
console.log(Object.getPrototypeOf(gary) === Person.prototype);
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype);
console.log(Object.getPrototypeOf(Object.prototype) === null);
console.log(Person.prototype.isPrototypeOf(gary));
console.log(Object.prototype.isPrototypeOf(Person.prototype));
//在这里打印:
//true
//true
//true
//true
//true
</code></pre><h2 id="四、对象"><a href="#四、对象" class="headerlink" title="四、对象"></a>四、对象</h2><p>定义对象有两种方式,一种是构造调用进行定义,还有一种是使用字面量语法糖的形式定义。</p>

<p><b>例子一</b></p>
<pre><code>var obj = new Object();
obj.name = &quot;Gary&quot;;
obj.age = 24;
console.log(obj);
//在这里打印:
//Object {name: &quot;Gary&quot;, age: 24}
//使用构造调用定义,添加属性或者方法,必须使用.或者[字符串]的形式,一行一行添加,非常繁琐
</code></pre><p><b>例子二</b></p>
<pre><code>var obj = {
    name: &quot;Gary Yin&quot;,
    age: 26
};
console.log(obj);
//在这里打印:
//Object {name: &quot;Gary Yin&quot;, age: 26}
//使用字面量语法糖定义,批量添加属性或者方法,一般定义对象,基本都这样使用
</code></pre><blockquote>
<p>添加或者修改对象属性或者方法</p>
</blockquote>
<p><b>例子一</b></p>
<pre><code>var obj = {
    name: &quot;Gary Yin&quot;,
    age: 26
}; 
obj.name = &quot;wenkai.yin&quot;;
obj.hobby = &quot;basketball&quot;;
obj.sexy = &quot;men&quot;;
console.log(obj);
//在这里打印:
//Object {name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;basketball&quot;, sexy: &quot;men&quot;}
//这种.形式添加或者修改对象属性或者方法,弊端在于属性名或者方法名,必须遵守定义变量名称的规则
//也就是必须以字母、下划线或者$符号开头,且属性名称或者方法名称只允许使用数字、字母、下划线和$符号
</code></pre><p><b>例子二</b></p>
<pre><code>var obj = {
    name: &quot;Gary Yin&quot;,
    age: 26
}; 
obj[&quot;name&quot;] = &quot;wenkai.yin&quot;;
obj[&quot;1hobby&quot;] = &quot;basketball&quot;;
obj[&quot;sexy&quot;] = &quot;men&quot;;
obj[&quot;@#$%&quot;] = &quot;@#$%&quot;;
console.log(obj);
//在这里打印:
//Object {name: &quot;wenkai.yin&quot;, age: 26, 1hobby: &quot;basketball&quot;, sexy: &quot;men&quot;, @#$%: &quot;@#$%&quot;}
//这种[字符串]形式添加或者修改对象属性或者方法,属性名或者方法名可以使用任意的字符串进行定义,没有任何的限制,兼容所有的字符串(包括汉字)
</code></pre><p><b>例子三</b></p>
<pre><code>var obj = {
};
Object.defineProperty(obj, &quot;name&quot;, {
    value: &quot;wenkai.yin&quot;,
    writable: true,
    enumerable: true,
    configurable: true
});
console.log(obj);
//在这里打印:
//Object {name: &quot;wenkai.yin&quot;}

Object.defineProperties(obj, {
    age: {
        value: 26,
        writable: true,
        enumerable: true,
        configurable: true
    },
    hobby: {
        value: &quot;program&quot;,
        writable: true,
        enumerable: true,
        configurable: true
    }
});
console.log(obj);
//在这里打印:
//Object {name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;program&quot;}
//defineProperty和defineProperties是添加和修改配置对象属性方法最细致的两种方式,defineProperty只能添加和修改一项属性和方法,而defineProperties可以批量添加和修改属性和方法
</code></pre><blockquote>
<p>获取对象属性和方法的配置信息</p>
</blockquote>
<p><b>例子一</b></p>
<pre><code>var obj = {
    name: &quot;wenkai.yin&quot;,
    age: 26,
    hobby: &quot;program&quot;
};
console.log(Object.getOwnPropertyDescriptors(obj));
//在这里打印:
//{
//      name: {
//          configurable: true,
//          enumerable: true,
//          value: &quot;wenkai.yin&quot;,
//          writable: true
//      },
//      age: {
//          configurable: true,
//          enumerable: true,
//          value: 26,
//          writable: true
//      },
//      hobby: {
//          configurable: true,
//          enumerable: true,
//          value: &quot;program&quot;,
//          writable: true
//      }
//}
//批量获取对象属性和方法的配置信息

console.log(Object.getOwnPropertyDescriptor(obj, &quot;age&quot;));
//在这里打印:
//{
//      configurable: true,
//      enumerable: true,
//      value: 26,
//      writable: true
//}
//获取对象单个属性或者方法的配置信息
</code></pre><p>获取对象的属性和方法的配置信息后,将要解释一下这些配置信息的作用,value就是属性值,writable是用来控制属性或者方法是否可修改值的开关,configurable是用来控制属性或者方法是否可配置、可添加以及可删除,enumerable是用来控制属性或者方法是否可枚举</p>

<p><b>例子一</b></p>
<pre><code>var obj = {
    name: &quot;Gary&quot;
};
Object.defineProperties(obj, {
    age: {
        value: 26,
        enumerable: false,
        writable: true,
        configurable: true
    },
    hobby: {
        value: &quot;program&quot;,
        enumerable: true,
        writable: true,
        configurable: true
    }
});
for(var key in obj) {
    console.log(key);
}
//在这里打印:
//name
//program
//属性的enumerable可枚举如果为false,遍历对象的属性名称,就不会出现
for(let key of Object.keys(obj)) {
    console.log(key);
}
//在这里打印:
//name
//program
//属性的enumerable可枚举如果为false,遍历对象的属性名称,就不会出现
console.log(Object.getOwnPropertyNames(obj));
//在这里打印:
//[&quot;name&quot;, &quot;age&quot;, program&quot;]
console.log(obj.hasOwnProperty(&quot;age&quot;));
//在这里打印:
//true
console.log(Reflect.ownKeys(obj));
//在这里打印:
//[&quot;name&quot;, &quot;age&quot;, &quot;program&quot;]
//由此可得出结论,除了for...in、Object.keys(obj)、Object.values(obj)和Object.entries(obj)受控制是否可枚举的属性enumerable影响之外,其他方式都可以获取到控制是否可枚举属性enumerable为false的属性名称
//for...in、Object.keys(obj)、Object.values(obj)和Object.entries(obj)还是能获取原型链上的属性和方法的遍历方式
</code></pre><p><b>例子二</b></p>
<pre><code>var obj = {
    name: &quot;Gary&quot;
};
Object.defineProperties(obj, {
    age: {
        value: 26,
        enumerable: true,
        writable: true,
        configurable: true
    },
    hobby: {
        value: &quot;program&quot;,
        enumerable: true,
        writable: false,
        configurable: true
    }
});
obj.name = &quot;wenkai.yin&quot;;
obj.hobby = &quot;basketball&quot;;
console.log(obj);
//Object {name: &quot;wenkai.yin&quot;, age: 26, hobby: &quot;program&quot;}
//当设置了控制属性值是否可修改的writable为false时,属性值便不可被改变
//且当writable设置为false时,不可被再次设置为true
Object.defineProperty(obj, &quot;hobby&quot;, {
    value: &quot;program&quot;,
    writable: true,
    configurable: true,
    enumerable: true
});
//在这里打印:
//直接报错,property can not redefine: hobby
</code></pre><p><b>例子三</b></p>
<pre><code>var obj = {
    name: &quot;Gary&quot;
};
Object.defineProperties(obj, {
    age: {
        value: 26,
        enumerable: true,
        writable: true,
        configurable: true
    },
    hobby: {
        value: &quot;program&quot;,
        enumerable: true,
        writable: true,
        configurable: false
    }
});
delete obj.age;
delete obj.program;
console.log(obj);
//在这里打印:
//Object {name: &quot;Gary&quot;, hobby: &quot;program&quot;}
Object.defineProperty(obj, &quot;hobby&quot;, {
    value: &quot;basketball&quot;,
    writable: true,
    enumerable: true,
    configurable: true
});
//在这里打印:
//直接报错,property can not redefine: hobby
</code></pre><p><b>例子四</b></p>
<pre><code>var obj = {
    name: &quot;Gary&quot;,
    age: 26,
    hobby: &quot;basketball&quot;
};
Object.preventExtensions(obj);
obj.sexy = &quot;men&quot;;
obj.hobby = &quot;program&quot;;
console.log(obj);
//在这里打印:
//Object {name: &quot;Gary&quot;, age: 26, hobby: &quot;program&quot;}
//preventExtensions方法使得obj对象不可添加新的属性
</code></pre><p><b>例子五</b></p>
<pre><code>var obj = {
    name: &quot;Gary&quot;,
    age: 26,
    hobby: &quot;basketball&quot;
};
Object.seal(obj);
obj.sexy = &quot;men&quot;;
obj.hobby = &quot;program&quot;
delete obj.age;
delete obj.name;
console.log(obj);
//在这里打印:
//Object {name: &quot;Gary&quot;, age: 26, hobby: &quot;program&quot;}
for(var key in obj) {
    console.log(key);
}
//在这里打印:
//name
//age
//program
Object.defineProperty(obj, &quot;name&quot;, {
    value: &quot;wenkai.yin&quot;,
    configurable: true,
    writable: true,
    enumerable: true
});
console.log(obj);
//在这里打印:
//直接报错: property can not redefine: name
//由此可以得出结论: seal方法使得obj对象所有属性不可配置对象属性和方法信息、不可删除对象属性,且不可添加对象属性,但是属性名称还是可以枚举的,原属性值还是可以修改的,也就是说seal方法使得obj对象所有属性的configurable置为false,所有属性的writable和enumerable还是维持原来的状态
</code></pre><p><b>例子六</b></p>
<pre><code>var obj = {
    name: &quot;Gary&quot;,
    age: 26,
    hobby: &quot;basketball&quot;
};
Object.freeze(obj);
obj.sexy = &quot;men&quot;;
obj.hobby = &quot;program&quot;
delete obj.age;
delete obj.name;
console.log(obj);
//在这里打印:
//Object {name: &quot;Gary&quot;, age: 26, hobby: &quot;basketball&quot;}
for(var key in obj) {
    console.log(key);
}
//在这里打印
//name
//age
//hobby
Object.defineProperty(obj, &quot;name&quot;, {
    value: &quot;wenkai.yin&quot;,
    configurable: true,
    writable: true,
    enumerable: true
});
console.log(obj);
//在这里打印:
//直接报错: property can not redefine: name
//由此可以得出结论: freeze方法使得obj对象不可配置对象属性和方法信息、不可删除对象属性、不可添加对象属性,且不可修改对象属性值,但是属性名称还是可以枚举的,也就是说freeze方法使得obj对象所有属性的configurable和writable置为false,所有属性的enumerable还是维持原来的状态
</code></pre><blockquote>
<p>对象遍历</p>
</blockquote>
<p>ES6语法中,新增了keys、values、entries和Reflect.OwnKeys遍历对象的函数方法,当然你也可以直接使用ES5语法中的for…in、getOwnPropertyNames等形式对对象进行遍历,还有一种使用迭代器(Symbol.iterator)的方式,这种方式需要开发者手写对象的Symbol.iterator迭代器方法,并不常见</p>

<p><b>例子一</b></p>
<pre><code>var obj = {
    name: &quot;wenkai.yin&quot;,
    age: 26,
    hobby: &quot;basketball&quot;
};
for(let key of Object.keys(obj)) {
    console.log(key);
}
//在这里打印:
//name
//age
//hobby

for(let value of Object.values(obj)) {
    console.log(value);
}
//在这里打印:
//wenkai.yin
//26
//basketball

for(let [key, value] of Object.entries(obj)) {
    console.log(key, value);
}
//在这里打印:
//name wenkai.yin
//age 26
//hobby basketball

for(let key in obj) {
    console.log(key);
}
//在这里打印:
//name
//age
//hobby
</code></pre><p><b>例子二</b></p>
<pre><code>var obj = {
    name: &quot;wenkai.yin&quot;,
    age: 26,
    hobby: &quot;basketball&quot;
};
var objNames = Object.getOwnPropertyNames(obj);
for(let val of objNames) {
    console.log(val);
}
//在这里打印:
//name
//age
//hobby
var objOwnKeys = Reflect.ownKeys(obj);
for(let val of objOwnKeys) {
    console.log(val);
}
//在这里打印:
//name
//age
//hobby
</code></pre><p><b>例子三</b></p>
<pre><code>var obj = {
    name: &quot;wenkai.yin&quot;,
    age: 26,
    hobby: &quot;basketball&quot;,
    [Symbol.iterator]() {
        var self = this,
            index = 0,
            objArr = Object.keys(self),
            length = objArr.length;
        return {
            next() {
                return {
                    value: self[objArr[index++]],
                    done: index &gt; length
                };
            }
        };
    }
};
for(let val of obj) {
    console.log(val);
}
//在这里打印:
//wenkai.yin
//26
//basketball
</code></pre><h2 id="笔试训练"><a href="#笔试训练" class="headerlink" title="笔试训练"></a>笔试训练</h2><p>自此你不知道的Javascript&lt;上篇&gt;整理: 词法作用域、this以及原型对象重点都已经划完了,下面我们会进入上篇的笔试训练阶段。</p>

<p><b><em>笔试一</em></b></p>
<pre><code>var a = 20;
var foo = {
    a: 10,
    getA: function () {
        return this.a;
    }
};  
var _getA = foo.getA;
console.log(_getA());
//在这里打印:
//20
</code></pre><p><b><em>笔试二</em></b></p>
<pre><code>var timer1 = (cb, time) =&gt; {
    (function loop() {
        cb();
        setTimeout(loop, time);
    })();
};
var timer2 = (cb, time) =&gt; {
    cb();
    setInterval(cb, time);
};
//1.timer1和timer2实现了什么功能,执行结果上会有什么区别?
//回答: timer1和timer2实现了隔时轮询的功能,从执行结果上来看并没有任何的区别
//2.模拟requestAnimationFrame方法的话应该参照哪种实现?
//回答: 应该参照第一种timer1的实现方法
//3.timer1中调换cb()和setTimeout的先后顺序会有什么影响?
//回答: 并不会有什么影响,由于JS语言是单线程语言,所以同一时间只能做同一件事,它会先执行同步代码,当遇到异步代码时,会先把异步代码放进异步队列中,等待同步代码执行完毕之后,再轮询异步队列中的异步代码,由此不会有任何的影响
</code></pre><p><b><em>笔试三</em></b></p>
<pre><code>var a = 1;
function f() {
    console.log(a);
    var = 2;
}
f();
//在这里打印:
//undefined
</code></pre><p><b><em>笔试四</em></b></p>
<pre><code>f();
g();
function f() {
    console.log(&apos;f&apos;);
}      
var g = function() {
    console.log(&apos;g&apos;);
};
//在这里打印:
//f
//TypeError: g is not a function
</code></pre><p><b><em>笔试五</em></b></p>
<pre><code>var person = {
    name: &quot;Messi&quot;
};
console.log(person.hasOwnProperty(&quot;name&quot;));
console.log(person.hasOwnProperty(&quot;hasOwnProperty&quot;));
console.log(Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;));
//在这里打印:
//true
//false
//true
</code></pre><p><b><em>笔试六</em></b></p>
<pre><code>function person(pname, page) {
    this.name = pname;
    this.age = page;
}
person.prototype.profession = &quot;football player&quot;;
var person1 = new person(&quot;Messi&quot;, 29);
var person2 = new person(&quot;Bale&quot;, 28);
console.log(person1.hasOwnProperty(&quot;name&quot;));
console.log(person1.hasOwnProperty(&quot;hasOwnProperty&quot;));
console.log(person1.__proto__ === person.prototype);
console.log(person.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;));
console.log(person1.__proto__.__proto__ === person.prototype.__proto__);
console.log(person.prototype.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;));
//在这里打印:
//true
//false
//true
//false
//true
//true
</code></pre><p><b><em>笔试七</em></b></p>
<pre><code>function shallowClone(o) {
    const obj = {};
    for(let i in o) {
        obj[i] = o[i];
    }
    return obj;
}    
const oldObj = {
    a: 1,
    b: [&apos;e&apos;, &apos;f&apos;, &apos;g&apos;],
    c: {h: {i: 2}}
};
const newObj = shallowClone(oldObj);
console.log(newObj.c.h, oldObj.c.h);
console.log(newObj.c.h === oldObj.c.h);
newObj.c.h = &quot;change&quot;;
console.log(newObj.c.h, oldObj.c.h);
//在这里打印:
//{i: 2} {i: 2}
//true
//&apos;change&apos; &apos;change&apos;
</code></pre><blockquote>
<p>自此你不知道的Javascript&lt;上篇&gt;整理: 词法作用域、this以及原型对象整理结束</p>
</blockquote>
<h1 id="lt-花絮-gt-整理polyfill兼容模拟的函数方法以及元素视图盒模型"><a href="#lt-花絮-gt-整理polyfill兼容模拟的函数方法以及元素视图盒模型" class="headerlink" title="&lt;花絮&gt;整理polyfill兼容模拟的函数方法以及元素视图盒模型"></a>&lt;花絮&gt;整理polyfill兼容模拟的函数方法以及元素视图盒模型</h1><h2 id="polyfill兼容模拟的函数方法"><a href="#polyfill兼容模拟的函数方法" class="headerlink" title="polyfill兼容模拟的函数方法"></a>polyfill兼容模拟的函数方法</h2><blockquote>
<p>polyfill兼容模拟new绑定</p>
</blockquote>
<pre><code>function _new() {
    var obj = {},
        args = Array.from(arguments),
        Collapse = args.shift();
    obj.__proto__ = Collapse.prototype;
    var target = Collapse.apply(obj, args);
    return typeof target === &quot;object&quot; ? target : obj;
}
function Person(name, age) {
    this.name = name;
    this.age = age;
}    
Person.prototype.introduce = function() {
    console.log(`I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var person = _new(Person, &quot;wenkai.yin&quot;, 26);
console.log(person.name, person.age);
person.introduce();
//在这里打印:
//wenkai.yin 26
//I&apos;m wenkai.yin, 26 year&apos;s old
</code></pre><blockquote>
<p>polyfill兼容模拟bind硬绑定</p>
</blockquote>
<pre><code>if(!Function.prototype.bind) {
    Function.prototype.bind = function(context) {
        if(typeof this !== &quot;function&quot;) {
            throw new TypeError(&quot;被绑定的对象类型并不是函数~&quot;);
        }
        var self = this,
            args = Array.from(arguments)
            fBind;
        args.shift();
        function F() {}
        fBind = function() {
            var innerArgs = Array.from(arguments);
            return self.apply(this instanceof fBind ? this : context, [...args, ...innerArgs]);
        }
        F.prototype = self.prototype;
        fBind.prototype = new F();
        return fBind;
    } 
}
function Person(name, age) {
    this.name = name;
    this.age = age;
}    
Person.prototype.introduce = function() {
    console.log(`I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var obj = {
    name: &quot;Gary Yin&quot;,
    age: 26
};
var fBind = Person.bind(obj);
var obj_ano = {
    name: &quot;wenkai.yin&quot;,
    age: 27,
    fBind
};
obj_ano.fBind(&quot;one piece&quot;, 12);
console.log(obj, obj_ano);
//在这里打印:
//Object {name: &quot;one piece&quot;, age: 12}
//Object {name: &quot;wenkai.yin&quot;, age: 27, fBind: f}
var obj_empty = {};
fBind.apply(obj_empty, [&quot;Gary wenkai&quot;, 22]);
console.log(obj, obj_empty);
//在这里打印:
//Object {name: &quot;Gary wenkai&quot;, age: 22}
//Object {}
</code></pre><blockquote>
<p>polyfill兼容模拟Object.create</p>
</blockquote>
<pre><code>if(!Object.create) {
    Object.create = function(o) {
        function F() {}
        F.prototype = o;
        return new F();
    };
}
var gary = {
    name: &quot;Gary Yin&quot;,
    age: 24
};
var gary_ = Object.create(gary);
console.log(gary_.name, gary_.age);
console.log(gary.isPrototypeOf(gary_));
console.log(Object.getPrototypeOf(gary_) === gary);
//在这里打印:
//Gary Yin 24
//true
//true
</code></pre><blockquote>
<p>polyfill兼容模拟函数截流以及函数防抖</p>
</blockquote>
<pre><code>//函数截流
var throttle = (function () {
    var firstTime = true,
        timer = null;
    return function(func, speed) {
        if(firstTime) {
            func();
            firstTime = false;
            return false;
        }
        if(timer) {
            return false;
        }
        timer = setTimeout(function time() {
            clearTimeout(timer);
            timer = null;
            func();
        }, speed);
    };    
})();
window.onresize = function (event) {
    throttle(function () {
        console.log(event);
    }, 1000);
};
//快速缩小或者放大浏览器长宽最多会打印两条数据,输出的数据会很慢:
//Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …}
//Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …}

//函数防抖
var debounce = (function () {
    var timer = null;
    return function (func, speed) {
        if(timer) {
            clearTimeout(timer);
            timer = null;
        }
        timer = setTimeout(function time() {
            func();
        }, speed);
    }
})();
window.onresize = function(event) {
    debounce(function() {
        console.log(event);
    }, 1000);
};
//持续快速缩小或者放大浏览器长宽1s之后,只会打印一条数据:
//Event {isTrusted: true, type: &quot;resize&quot;, target: Window, currentTarget: Window, eventPhase: 2, …}
</code></pre><blockquote>
<p> polyfill兼容模拟softBind软绑定</p>
</blockquote>
<pre><code>if(!Function.prototype.softBind) {
    Function.prototype.softBind = function(context) {
        if(typeof this !== &quot;function&quot;) {
            throw new TypeError(&quot;被绑定的对象类型并不是函数~&quot;);
        }
        var self = this,
            args = Array.from(arguments),
            fSoftBind;
        args.shift();
        function F() {}
        fBind = function() {
            var innerArgs = Array.from(arguments);
            return self.apply((!this || this === window) ? context : this, [...args, ...innerArgs]);
        };
        F.prototype = self.prototype;
        fBind.prototype = new F();
        return fBind;
    };
}
function Person(name, age) {
    this.name = name;
    this.age = age;
}    
Person.prototype.introduce = function() {
    console.log(`I&apos;m ${this.name}, ${this.age} year&apos;s old`);
};
var obj = {
    name: &quot;Gary Yin&quot;,
    age: 26
};
var fBind = Person.softBind(obj);
var obj_ano = {
    name: &quot;wenkai.yin&quot;,
    age: 27,
    fBind
};
obj_ano.fBind(&quot;one piece&quot;, 12);
console.log(obj, obj_ano);
//在这里打印:
//Object {name: &quot;Gary Yin&quot;, age: 26}
//Object {name: &quot;one piece&quot;, age: 12, fBind: f}
var obj_empty = {};
fBind.apply(obj_empty, [&quot;Gary wenkai&quot;, 22]);
console.log(obj, obj_empty);
//在这里打印:
//Object {name: &quot;Gary Yin&quot;, age: 26}
//Object {name: &quot;Gary wenkai&quot;, age: 22}
</code></pre><blockquote>
<p>polyfill兼容模拟isInteger是否为整数</p>
</blockquote>
<pre><code>if(!Number.isInteger) {
    Number.isInteger = function(num) {
        return typeof num === &quot;number&quot; &amp;&amp; (num % 1 === 0);
    };
}

console.log(Number.isInteger(44.6));
console.log(Number.isInteger(Number.MAX_SAFE_INTEGER));
console.log(Number.isInteger(Infinity));
console.log(Number.isInteger(NaN));
console.log(Number.isInteger(99));
//在这里打印:
//false
//true
//false
//false
//true
</code></pre><blockquote>
<p>polyfill兼容模拟isNaN是否为NaN</p>
</blockquote>
<pre><code>if(!Number.isNaN) {
    Number.isNaN = function(num) {
        return typeof num === &quot;number&quot; &amp;&amp; (num !== num);
    };
}

console.log(Number.isNaN({}));
console.log(Number.isNaN([]));
console.log(Number.isNaN(NaN));
console.log(Number.isNaN(0 * Infinity));
console.log(Number.isNaN(1 / 0));
console.log(Number.isNaN(1 / Infinity));
console.log(Number.isNaN(Infinity / Infinity));
//在这里打印:
//false
//false
//true 
//true
//false
//false
//true
</code></pre><blockquote>
<p>polyfill兼容模拟isNagetiveZero是否为负零,负号一般代指方向</p>
</blockquote>
<pre><code>if(!Number.isNagetiveZero) {
    Number.isNagetiveZero = function(num) {
        return typeof num === &quot;number&quot; &amp;&amp; (1 / num === -Infinity);
    };
}

console.log(Number.isNagetiveZero(-0));
console.log(Number.isNagetiveZero(0));
console.log(Number.isNagetiveZero(1 / Infinity));
console.log(Number.isNagetiveZero(99 / -Infinity));
//在这里打印:
//true
//false
//false
//true
</code></pre><blockquote>
<p>polyfill兼容模拟isEpsilon来判断0.1 + 0.2 === 0.3</p>
</blockquote>
<pre><code>if(!Number.isEpsilon) {
    Number.isEpsilon = function(num) {
        return num &lt; Number.EPSILON;
    };
}

console.log(Number.isEpsilon(0.1 + 0.2 - 0.3));
//在这里打印:
//true
</code></pre><h2 id="元素视图盒模型"><a href="#元素视图盒模型" class="headerlink" title="元素视图盒模型"></a>元素视图盒模型</h2><pre><code>//获取浏览器屏幕的可视宽度以及高度
console.log(window.innerWidth, window.innerHeight);
//获取页面元素的无边框宽度以及高度
var box = document.getElementById(&quot;box&quot;);
console.log(box.clientWidth, box.clientHeight);
//获取页面元素的有边框宽度以及高度
console.log(box.offsetWidth, box.offsetHeight);
//获取页面文档的高度
console.log(document.body.clientHeight || document.documentElement.clientHeight);
//获取滑块滑动后距离顶部的高度
console.log(document.body.scrollTop || document.documentElement.scrollTop);
//获取元素在页面的相对位置
var position = box.getBoundingClientRect();
console.log(position.top, position.left, position.right, position.bottom);
//获取元素在页面的绝对位置
var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
var absoluteTop = position.top + scrollTop,
    absoluteBottom = position.bottom + scrollTop;
console.log(absoluteTop, absoluteBottom);
//获取元素的滑块滑动高度
console.log(box.scrollHeight);
</code></pre><h1 id="lt-中篇-gt-整理-类型、语法"><a href="#lt-中篇-gt-整理-类型、语法" class="headerlink" title="&lt;中篇&gt;整理: 类型、语法"></a>&lt;中篇&gt;整理: 类型、语法</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><blockquote>
<p>基本类型</p>
</blockquote>
<p>Javascript中基本类型分为: number、string、boolean、undefined和null,null类型由于JS最初时的一个bug导致它的typeof类型为object</p>

<blockquote>
<p>引用类型</p>
</blockquote>
<p>Javascript中引用类型分为: object以及function</p>

<blockquote>
<p>内置函数和内置对象</p>
</blockquote>
<p>Javascript中存在内置函数和内置对象,它们分别是: String、Number、Boolean、Object、Array、Function、RegExp、Math、JSON、Symbol和Error,当你去构造调用一个内置函数时,你就可以使用这些内置函数所拥有的属性或者方法,譬如说toString,valueOf,toFixed等等,但是你可能会问,为什么那些常量,比如说var string = “string”;string.toString();也可以调用构造调用的引用对象才能调用的属性或者方法呢?<br>回答: 这些常量本身并没有这些属性和方法,而是它们在调用属性或者方法的时候,浏览器引擎会将它们封装成理应匹配的构造调用内置函数或者内置方法,这样这些常量就可以调用了</p>

<p><b>例子</b></p>
<pre><code>var string_obj = new String(&quot;I&apos;m Gary&quot;),
    string = &quot;I&apos;m Seven&quot;;
console.log(string_obj.slice(0, 5));
console.log(string.slice(0, 6));
//在这里打印:
//I&apos;m G
//I&apos;m Se
var number_obj = new Number(10),
    number = 22;
console.log(number_obj.toFixed(2));
console.log(number.toFixed(2));
//使用数字常量去调用数字构造调用的属性或者方法时,必须使用两个点调用,第一个点浏览器会认为是数字常量浮点类型的第一个点,第二点才是调用数字构造调用的属性或者方法的点
console.log(40..toFixed(2));
//在这里打印:
//10.00
//22.00
//40.00
</code></pre><blockquote>
<p>0.1 + 0.2 !== 0.3</p>
</blockquote>
<p>大家都清楚,在JS里,0.1+0.2!==0.3,而是等于0.30000000000000004,原因:浮点数十进制在底层转化为二进制机器码进行运算,由于JS的浮点数并不是很精确,所以运算之后,转化为十进制之后,并不是0.3,而是0.30000000000000004<br>那该怎么解决这个问题,使得0.1+0.2===0.3呢? ES6在Number内置函数上提供了一个属性EPSILON,它可以进行甄别0.1+0.2相加运算之后的值是否是在这个范围之内,如果是,就返回true,如果不是,就返回false</p>

<p><b>例子</b></p>
<pre><code>function isEpsilon(num) {
    return num &lt; Number.EPSILON
}
console.log(isEpsilon(0.1 + 0.2 - 0.3));
//在这里打印:
//true
//说明0.1 + 0.2 - 0.3是在这个区间之内的,说明0.1 + 0.2 === 0.3
//而这个Number.EPSILON的区间范围是:2.220446049250313e-16
</code></pre><blockquote>
<p>内置数字函数Number处理</p>
</blockquote>
<p>下面是Number内置数字函数对各个类型的常量或者变量处理的结果,当处理基本类型的常量或者变量时,遇到null、false、0、””、”      “和”0”时,会处理成0;遇到true,会处理成1;遇到undefined、NaN、字符串中含有字母时,会处理成NaN;当处理引用类型的常量或者变量时,会根据对象的ToNumber、ToString和ToPremitive进行处理,当遇到Number内置数字函数进行处理时,会直接调用对象的ToNumber也就是valueOf,遇到空数组时,会处理成0;遇到有一个数组元素的数组时,会处理成这一个数组元素产生的结果;遇到有两个数组的数组时,会处理成NaN;遇到对象时,会处理成NaN</p>

<p><b>例子</b></p>
<pre><code>console.log(Number(undefined));
console.log(Number(null));
console.log(Number(NaN));
console.log(Number(0));
console.log(Number(&quot;0&quot;));
console.log(Number(&quot;0n0&quot;));
console.log(Number(&quot;&quot;));
console.log(Number(&quot;     &quot;));
console.log(Number({}));        
console.log(Number([]));
console.log(Number([44]));
console.log(Number([&quot;4N4&quot;]));
console.log(Number([44, 99]));
console.log(Number(true));
console.log(Number(false));
//在这里打印:
//NaN
//0
//NaN
//0
//0
//NaN
//0
//0
//NaN
//0
//44
//NaN
//NaN
//1
//0
</code></pre><blockquote>
<p>内置字符串函数String处理</p>
</blockquote>
<p>下面是String内置字符串函数对各个类型的常量或者变量处理的结果,当处理基本类型的常量或者变量时,遇到undefined、null、NaN、true、false、1、0时,会处理成”undefined”,”null”,”NaN”,”true”,”false”,”true”,”false”,”1”,”0”;当处理引用类型的常量或者变量时,会根据对象的ToNumber、ToString和ToPremitive进行处理,当遇到String内置字符串函数进行处理时,会直接调用对象的ToString也就是toString,遇到空数组时,会处理成””;遇到有一个数组元素的数组时,会处理成这个数组元素的字符串形式;遇到有多个数组的数组时,会处理成每个数组元素的字符串形式并在中间加上逗号;遇到对象时,会处理成其原型链上toString后显示的结果[object Object]</p>

<p><b>例子</b></p>
<pre><code>console.log(String(undefined));
console.log(String(null));
console.log(String(0));
console.log(String(NaN));
console.log(String(true));
console.log(String(false));
console.log(String([]));
console.log(String({}));
console.log(String([44]));
console.log(String([66, 99]));
console.log(String(&quot;      &quot;));
//在这里打印:
//&quot;undefined&quot;
//&quot;null&quot;
//&quot;0&quot;
//&quot;NaN&quot;
//&quot;true&quot;
//&quot;false&quot;
//&quot;&quot;
//[object Object]
//&quot;44&quot;
//&quot;66,99&quot;
//&quot;      &quot;
</code></pre><blockquote>
<p>字符串toString方法处理</p>
</blockquote>
<p>下面是toString字符串方法对各个类型的常量或者变量处理的结果,当处理基本类型的常量或者变量时,遇到undefined、null时,会直接报TypeError错误,表明undefined和null并不存在toString方法;当遇到NaN、true、false、1、0时,会直接处理成”NaN”,”true”,”false”,”1”,”0”;当处理引用类型的常量或者变量时,会根据对象的ToNumber、ToString和ToPremitive进行处理,当遇到toString字符串方法进行处理时,遇到空数组时,会处理成””;遇到有一个数组元素的数组时,会处理成这个数组元素的字符串形式;遇到有多个数组的数组时,会处理成每个数组元素的字符串形式并在中间加上逗号;遇到对象时,会处理成其原型链上toString后显示的结果[object Object]</p>

<p><b>例子</b></p>
<pre><code>console.log(undefined.toString());
console.log(null.toString());
console.log(0..toString());
console.log(1..toString());
console.log(true.toString());
console.log(false.toString());
console.log(NaN.toString());
console.log([].toString());
console.log({}.toString());
console.log([44].toString());
console.log([&quot;4n4&quot;].toString());
console.log([44, 89].toString());
console.log(&quot;      &quot;.toString());
//在这里打印:
//TypeError: Cannot read property &apos;toString&apos; of undefined
//TypeError: Cannot read property &apos;toString&apos; of null
//&quot;0&quot;
//&quot;1&quot;
//&quot;true&quot;
//&quot;false&quot;
//&quot;NaN&quot;
//&quot;&quot;
//[object Object]
//&quot;44&quot;
//&quot;4n4&quot;
//&quot;44, 89&quot;
//&quot;      &quot;
</code></pre><blockquote>
<p>polyfill兼容模拟判断一个常量或者一个变量是否为NaN</p>
</blockquote>
<p>通常我们使用内置数字函数Number上的isNaN静态方法来判断一个常量或者一个变量是否为NaN,当然当遇到不兼容Number.isNaN方法的浏览器时,我们可以手写一个polyfill兼容版的静态方法,利用NaN的特性:NaN自己不等于其本身</p>

<p><b>例子</b></p>
<pre><code>console.log(Number.isNaN(NaN));
//在这里打印:
//true

if(!Number.isNaN) {
    Number.isNaN = function(num) {
        return num !== num;
    };
}
console.log(Number.isNaN(NaN));
console.log(Number.isNaN(0));
console.log(Number.isNaN({}));
console.log(Number.isNaN([]));
console.log(Number.isNaN([44]));
//在这里打印:
//true
//false
//false
//false
//false
</code></pre><blockquote>
<p>内置数字函数Number上的属性或者方法</p>
</blockquote>
<p>Number内置数字函数的MAX_VALUE和MIN_VALUE属性代表的是JS里所能表示的最大数值和最小数值;而MAX_SAFE_INTEGER和MIN_SAFE_INTEGER代表的是JS里面最大的和最小的安全整数;isInteger是判断一个常量或者一个变量是否是整数;而isSafeInteger则是判断一个常量或者一个变量是否是安全整数;当然我们也可以polyfill兼容模拟判断一个常量或者一个变量是否为整数isInteger</p>

<p><b>例子</b></p>
<pre><code>console.log(Number.MAX_VALUE);
console.log(Number.MIN_VALUE);
console.log(Number.MAX_SAFE_INTEGER); 
console.log(Number.MIN_SAFE_INTEGER);
console.log(Number.isInteger(Number.MAX_VALUE));
console.log(Number.isInteger(Infinity));
console.log(Number.isInteger(44.7));
console.log(Number.isInteger(1.7976931348623157e+308));
console.log(Number.isSafeInteger(1.7976931348623157e+308));
console.log(Number.isSafeInteger(9007199254740991));
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1));
//在这里打印:
//1.7976931348623157e+308
//5e-324
//9007199254740991
//-9007199254740991
//true
//false
//false
//true
//false
//true
//false

//polyfill模拟判断一个常量或者一个变量是否为整数isInteger
if(!Number.isInteger) {
    Number.isInteger = function (num) {
        return typeof num === &quot;number&quot; &amp;&amp; (num % 1 === 0);
    };
}
console.log(Number.isInteger(Number.MAX_VALUE));
console.log(Number.isInteger(Infinity));
console.log(Number.isInteger(44.7));
console.log(Number.isInteger(1.7976931348623157e+308));
console.log(Number.isInteger(44));
//在这里打印:
//true
//false
//false
//true
//true
</code></pre><blockquote>
<p>Infinity、-Infinity、0与-0</p>
</blockquote>
<p>除了0与-0之外,任何与Infinity进行运算(除了除法运算)的数值结果全都为Infinity或者-Infinity,任何与-Infinity进行运算(除了除法运算)的数值结果全都为Infinity或者-Infinity,任何与Infinity或者-Infinity进行运算的非数值结果根据隐式类型转换(valueOf)后决定;0与Infinity进行乘法运算的结果为NaN,进行加减运算的结果为Infinity或者-Infinity;-0与Infinity进行乘法运算的结果为NaN,进行加减运算的结果为Infinity或者-Infinity;任何与Infinity进行除法运算的数值结果全都为0或者-0;任何与-Infinity进行除法运算的数值结果全都为0或者-0;除了0与-0之外,任何与0进行除法运算的数值结果全都为Infinity或者-Infinity;任何与-0进行除法运算的数值结果全都为Infinity或者-Infinity;0, -0与0, -0进行除法运算的结果为NaN;</p>

<p><b>例子</b></p>
<pre><code>console.log(1 * Infinity);
console.log(-1 * Infinity);
console.log(1 / Infinity);
console.log(-1 / Infinity);
console.log(199 * Infinity);
console.log(-199 * Infinity);
console.log(&quot;1ab&quot; * Infinity);
console.log(Infinity * Infinity);
console.log(-Infinity * Infinity);
console.log(-Infinity * -Infinity);
console.log([44] * Infinity);
console.log([&quot;4n4&quot;] * Infinity);
console.log([99, 77, 29] * Infinity);
console.log({} * Infinity);
console.log([] * Infinity);
console.log(NaN + Infinity);
console.log(0 * Infinity);
console.log(-0 * Infinity);
console.log(0 - Infinity);
console.log(-0 - Infinity);
console.log(0 / Infinity);
console.log(-0 / Infinity);
console.log(Infinity / Infinity);
console.log(-Infinity / Infinity);
console.log(1 / 0);
console.log(-1 / 0);
console.log(0 / 0);
console.log(-0 / 0);
console.log(-0 / -0);

//在这里打印:
//Infinity
//-Infinity
//0
//-0
//Infinity
//-Infinity
//NaN
//Infinity
//-Infinity
//Infinity
//Infinity
//NaN
//NaN
//NaN
//NaN
//NaN
//NaN
//NaN
//-Infinity
//-Infinity
//0
//-0
//NaN
//NaN
//Infinity
//-Infinity
//NaN
//NaN
//NaN
</code></pre><blockquote>
<p>polyfill兼容模拟判断一个数值是-0</p>
</blockquote>
<p><b>例子</b></p>
<pre><code>if(!Number.isNagetiveZero) {
    Number.isNagetiveZero = function(num) {
        return typeof num === &quot;number&quot; &amp;&amp; (1 / num === -Infinity);
    };
}
console.log(Number.isNagetiveZero(0));
console.log(Number.isNagetiveZero(-0));
console.log(Number.isNagetiveZero(1 / Infinity));
console.log(Number.isNagetiveZero(-99 / Infinity));
console.log(Number.isNagetiveZero(Infinity / Infinity));
//在这里打印:
//false
//true
//false
//true
//false
</code></pre><blockquote>
<p>parseInt是从字符串首部开始截取字符为数值并转化为数值的函数方法</p>
</blockquote>
<p>parseInt函数方法的第一个参数是要进行首部开始截取字符为数值并转化为数值的字符串,而第二个参数则是转化的进制数;parseInt函数方法当遇到并不是字符串的常量或者变量时,它会先将其隐式类型转换为字符串,再进行首部开始截取字符为数值并转化为数值</p>

<p><b>例子</b></p>
<pre><code>console.log(parseInt(&quot;468Gary743&quot;));
console.log(parseInt(&quot;Gary468743&quot;));
console.log(parseFloat(&quot;48.6Gary733.4&quot;));
console.log(parseFloat(&quot;Gary48.6733.4&quot;));
console.log([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map((item, index) =&gt; parseInt(item, index)));
console.log(parseInt([]));
console.log(parseInt([44]));
console.log(parseInt([89, 96, 44]));
console.log(parseInt(function() {}));
console.log(parseInt({}));
console.log(parseInt(function() {}, 16));
console.log(parseInt(true));
console.log(parseInt(false, 16));
console.log(parseInt(true, 16));
console.log(parseInt(1/0, 19));
console.log(parseInt(function() {}, 8));
console.log(parseInt(1/-0, 19));
console.log(parseInt([1/0, &quot;68&quot;, false, true], 19));

//在这里打印:
//468
//NaN
//48.6
//NaN
//[1, NaN, NaN]
//NaN
//44
//89
//NaN
//NaN
//15
//NaN
//250
//NaN
//18
//NaN
//NaN
//18
</code></pre><blockquote>
<p>try {} catch(err) {} finally {}</p>
</blockquote>
<p>在ES6的let、const块级作用域之前,Google的Tracer团队就是使用try {} catch(a) {}这种方式来模拟块级作用域,浏览器编译后基本上是以下表达式形式:</p>

<p><b>例子</b></p>
<pre><code>function foo() {
    try {
        throw undefined;
    } catch(a) {
        a = 2;
        console.log(a);
    }
    console.log(a);
}
foo();
//在这里打印:
//2
//ReferrenceError: a is not defined
</code></pre><p>使用try…catch()…finally了之后,try表达式中的return返回表达式语句不会被执行,会直接跳过,执行finally中的返回表达式语句:</p>

<p><b>例子</b></p>
<pre><code>function foo(num) {
    try {
        console.log(668);
        console.log(num + 1);
        return 100;
    } catch(error) {
        console.log(error);
    } finally {
        return num;
    }
}    
console.log(foo(999));
//在这里打印:
//668
//1000
//999
</code></pre><blockquote>
<p>== 与 === 的区别</p>
</blockquote>
<p>在初学者阶段,被问到 == 与 === 的区别,我一般都会回答==不校验类型,只校验值,===既校验类型,还校验值;而现在的理解是,==进行隐式强制类型转换,而===不进行强制类型转换。</p>

<p><b>例子</b></p>
<pre><code>console.log(1 == &quot;1&quot;);
console.log(22 === &quot;22&quot;);
console.log(true == 1);
console.log(false === 0);
//在这里打印:
//true
//false
//true
//false
</code></pre><blockquote>
<p>&amp;&amp; 与 ||的优先级</p>
</blockquote>
<p>&amp;&amp;与||是有优先级区分的,&amp;&amp;的优先级是大于||的。</p>

<p><b>例子</b></p>
<pre><code>var a = true,
    b = false,
    c = true;
console.log(b &amp;&amp; a || c);
//在这里打印:
//true   
//说明表达式是执行(b &amp;&amp; a) || c,而不是b &amp;&amp; (a || c),如果是后者,那返回就应该是false
</code></pre><blockquote>
<p>JSON.stringify将JS对象转化为JSON字符串</p>
</blockquote>
<p>JSON.stringify进行转化时,遇到非JSON语法的表达式语句,会转化成undefined或者null,当遇到undefined或者function() {}时,会转化为undefined;当遇到NaN时,会转化为null;当遇到在数组对象中的非JSON语法的表达式语句,会全部转化为null;当遇到对象中的非JSON语法的表达式语句时,会删除掉非法的属性或者属性值</p>

<p><b>例子</b></p>
<pre><code>console.log(JSON.stringify(undefined));
console.log(JSON.stringify(null));
console.log(JSON.stringify(function() {}));
console.log(JSON.stringify(NaN));
console.log(JSON.stringify([]));
console.log(JSON.stringify([function() {}, NaN, null, true, {}, 66, undefined]));
console.log(JSON.stringify({}));
console.log(JSON.stringify({a: function() {}, b: NaN, c: null, d: true, e: 88, f: undefined, g: [], h: [undefined, NaN, function() {}]}));
//在这里打印:
//undefined
//null
//undefined
//null
//[]
//[null, null, null, true, {}, 66, null]
//{b: null, c: null, d: true, e: 88, g: [], h: [null, null, null]}
</code></pre>]]></content>
      <categories>
        <category>你不知道的Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-05-21 Javascript数据结构与算法</title>
    <url>/2018/05/21/Javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h1><blockquote>
<p>栈是数据结构中比较简单的顺序数据结构,特点是: <b>后进先出</b>,新的元素或者你也可以理解为待删除的元素更接近与栈顶,而旧的元素更接近于栈底,生活中有很多栈的例子,比如说堆在一起的书,再比如说特别拥挤的地铁,你可以理解为任何只有一个出口的事物,都可以作为栈来使用,在Javascript中,我们可以使用数组来模拟栈的实现,首先是ES5版本</p>
</blockquote>
<pre><code>//全局声明一个数组变量: stack_mock
let stack_mock = [];
//声明一个函数,这里当作栈Stack的类
function Stack (){

}

//向栈内添加元素
Stack.prototype.push = function(element) {
    return stack_mock.push(element);
};

//栈顶删除元素
Stack.prototype.pop = function() {
    return stack_mock.pop();
};

//校验栈是否为空
Stack.prototype.isEmpty = function() {
    return stack_mock.length === 0;
};

//获取栈顶的元素
Stack.prototype.peek = function() {
    let len = stack_mock.length;
    return stack_mock[len - 1];  
};

//获取栈内元素的个数
Stack.prototype.size = function() {
    return stack_mock.length;
};

//对栈内所有元素进行打印
Stack.prototype.print = function() {
    return stack_mock.toString();
};

//对栈进行清空
Stack.prototype.clear = function() {
    stack_mock = [];
};

//声明一个栈Stack类的实例
let stack = new Stack();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//向栈中添加元素
stack.push(&quot;Gary&quot;);
stack.push(&quot;Lily&quot;);
stack.push(&quot;Frank&quot;);
stack.push(&quot;Simon&quot;);
//在这里打印添加元素之后的返回值
//这里打印栈内的元素个数:
//5
console.log(stack.push(&quot;Aaron&quot;));
//在这里打印栈是否为空
//这里打印:
//false
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//5
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Aaron&quot;
console.log(stack.peek());
//在这里打印栈内所有的元素
//这里打印:
//Gary,Lily,Frank,Simon,Aaron
console.log(stack.print());
//在这里对栈内元素从栈顶进行删除
//这里打印:
//Aaron
console.log(stack.pop());
//在这里打印栈内元素的个数
//这里打印:
//4
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Simon&quot;
console.log(stack.peek());
//对栈进行清空
stack.clear();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
</code></pre><blockquote>
<p>这种方式stack_mock数组变量暴露在全局中,其他人可以随意修改,很不安全,且一个类的实例只能对应一个类似stack_mock的数组变量,很不方便,所以最好放在类的内部或者与类进行映射,下面是改进之后的ES6版本</p>
</blockquote>
<pre><code>//声明一个类函数,这里当作栈Stack的类
class Stack {
    constructor() {
        //在类函数内部定义stack_mock属性,并初始化为空数组
        this[&quot;stack_mock&quot;] = [];
    }

    //向栈内添加元素
    push(element) {
        return this[&quot;stack_mock&quot;].push(element);
    }

    //栈顶删除元素
    pop() {
        return this[&quot;stack_mock&quot;].pop();
    }

    //校验栈是否为空
    isEmpty() {
        return this[&quot;stack_mock&quot;].length === 0;
    }

    //获取栈顶元素
    peek() {
        let len = this[&quot;stack_mock&quot;].length;
        return this[&quot;stack_mock&quot;][len - 1];
    }

    //获取栈内元素的个数
    size() {
        return this[&quot;stack_mock&quot;].length;
    }

    //对栈内所有元素进行打印
    print() {
        return this[&quot;stack_mock&quot;].toString();
    }

    //对栈进行清空
    clear() {
        this[&quot;stack_mock&quot;] = [];
    }
}

//声明一个栈Stack类的实例
let stack = new Stack();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//向栈中添加元素
stack.push(&quot;Gary&quot;);
stack.push(&quot;Lily&quot;);
stack.push(&quot;Frank&quot;);
stack.push(&quot;Simon&quot;);
//在这里打印添加元素之后的返回值
//这里打印栈内的元素个数:
//5
console.log(stack.push(&quot;Aaron&quot;));
//在这里打印栈是否为空
//这里打印:
//false
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//5
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Aaron&quot;
console.log(stack.peek());
//在这里打印栈内所有的元素
//这里打印:
//Gary,Lily,Frank,Simon,Aaron
console.log(stack.print());
//在这里对栈内元素从栈顶进行删除
//这里打印:
//Aaron
console.log(stack.pop());
//在这里打印栈内元素的个数
//这里打印:
//4
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Simon&quot;
console.log(stack.peek());
//对栈进行清空
stack.clear();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
</code></pre><blockquote>
<p>这种方式不仅避免了数组变量暴露在全局被随意修改的风险,还避免了一个数组变量只能对应一个类的实例的窘境,但是在类函数内部的属性,通过实例是可以进行获取和修改的,所以内部属性被随意修改的问题又暴露了出来,类似于这样</p>
</blockquote>
<pre><code>//声明一个栈Stack类的实例
let stack = new Stack();
//获取到类函数内部属性&quot;stack_mock&quot;
let stack_mock = stack[&quot;stack_mock&quot;];
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//向栈中添加元素
stack.push(&quot;Gary&quot;);
stack.push(&quot;Lily&quot;);
stack.push(&quot;Frank&quot;);
stack.push(&quot;Simon&quot;);
//在这里打印添加元素之后的返回值
//这里打印栈内的元素个数:
//5
console.log(stack.push(&quot;Aaron&quot;));
//设置类函数内部属性&quot;stack_mock&quot;为空数组
stack[&quot;stack_mock&quot;] = [];
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//undefined
console.log(stack.peek());
//在这里打印栈内所有的元素
//这里打印:
//&quot;&quot;
console.log(stack.print());
//在这里对栈内元素从栈顶进行删除
//这里打印:
//undefined
console.log(stack.pop());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//undefined
console.log(stack.peek());
//对栈进行清空
stack.clear();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
</code></pre><blockquote>
<p>明明已经添加到栈内的元素,直接被外部设置内部属性为空数组,给删除掉了,这岂不是很尴尬,所以想要利用Symbol ES6中这种枚举新语法进行改进</p>
</blockquote>
<pre><code>//声明一个可公用的Symbol的枚举变量: stack_mock
//为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
let Stack = (function (){
    let stack_mock = Symbol();
    //声明一个类函数,这里当作栈Stack的类
    class Stack {
        constructor() {
            //在类函数内部定义stack_mock Symbol属性,并初始化为空数组
            this[stack_mock] = [];
        }

        //向栈内添加元素
        push(element) {
            return this[stack_mock].push(element);
        }

        //栈顶删除元素
        pop() {
            return this[stack_mock].pop();
        }

        //校验栈是否为空
        isEmpty() {
            return this[stack_mock].length === 0;
        }

        //获取栈顶元素
        peek() {
            let len = this[stack_mock].length;
            return this[stack_mock][len - 1];
        }

        //获取栈内元素的个数
        size() {
            return this[stack_mock].length;
        }

        //对栈内所有元素进行打印
        print() {
            return this[stack_mock].toString();
        }

        //对栈进行清空
        clear() {
            this[stack_mock] = [];
        }
    }
    //返回类函数Stack
    return Stack;
})();

//声明一个栈Stack类的实例
let stack = new Stack();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//向栈中添加元素
stack.push(&quot;Gary&quot;);
stack.push(&quot;Lily&quot;);
stack.push(&quot;Frank&quot;);
stack.push(&quot;Simon&quot;);
//在这里打印添加元素之后的返回值
//这里打印栈内的元素个数:
//5
console.log(stack.push(&quot;Aaron&quot;));
//在这里打印栈是否为空
//这里打印:
//false
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//5
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Aaron&quot;
console.log(stack.peek());
//在这里打印栈内所有的元素
//这里打印:
//Gary,Lily,Frank,Simon,Aaron
console.log(stack.print());
//在这里对栈内元素从栈顶进行删除
//这里打印:
//Aaron
console.log(stack.pop());
//在这里打印栈内元素的个数
//这里打印:
//4
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Simon&quot;
console.log(stack.peek());
//对栈进行清空
stack.clear();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
</code></pre><blockquote>
<p>这时候外部类的实例,看样子好想完全拿不到内部的Symbol枚举属性,其实有两种方式可以完全拿到:getOwnPropertySymbols(仅可以拿到对象的Symbol枚举属性,包含继承)和Reflect.ownKeys(无论是Symbol枚举属性还是对象自身所拥有的属性都可以拿到,也包含继承),这时候去获取到Symbol枚举属性,并进行设置为空数组,依然可以在外部删除内部枚举属性数组的元素,类似于这样</p>
</blockquote>
<pre><code>//声明一个栈Stack类的实例
let stack = new Stack();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//向栈中添加元素
stack.push(&quot;Gary&quot;);
stack.push(&quot;Lily&quot;);
stack.push(&quot;Frank&quot;);
stack.push(&quot;Simon&quot;);
//在这里打印添加元素之后的返回值
//这里打印栈内的元素个数:
//5
console.log(stack.push(&quot;Aaron&quot;));
//获取内部的Symbol枚举属性
//两种方式都可以
//let stack_mock = Object.getOwnPropertySymbols(stack)[0];
let stack_mock = Reflect.ownKeys(stack)[0];
//设置内部的Symbol枚举属性值为空数组
stack[stack_mock] = [];
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//undefined
console.log(stack.peek());
//在这里打印栈内所有的元素
//这里打印:
//&quot;&quot;
console.log(stack.print());
//在这里对栈内元素从栈顶进行删除
//这里打印:
//undefined
console.log(stack.pop());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//undefined
console.log(stack.peek());
//对栈进行清空
stack.clear();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
</code></pre><blockquote>
<p>针对这种情况,尝试使用WeakMap集合来解决,WeakMap是Map的一种形式,它只能设置key为对象的属性,且在无法通过类实例的任何方法来获取并设置</p>
</blockquote>
<pre><code>let Stack = (function (){
    //声明一个可公用的WeakMap的集合变量: stack_mock
    //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
    let stack_mock = new WeakMap();
    //声明一个类函数,这里当作栈Stack的类
    class Stack {
        constructor() {
            //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组
            stack_mock.set(this, []);
        }

        //向栈内添加元素
        push(element) {
            let stack_arr = stack_mock.get(this);
            let stack_index = stack_arr.push(element);
            stack_mock.set(this, stack_arr);
            return stack_index;
        }

        //栈顶删除元素
        pop() {
            let stack_arr = stack_mock.get(this);
            let stack_item = stack_arr.pop();
            stack_mock.set(this, stack_arr);
            return stack_item;
        }

        //校验栈是否为空
        isEmpty() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.length === 0;
        }

        //获取栈顶元素
        peek() {
            let stack_arr = stack_mock.get(this),
                len = stack_arr.length;
            return stack_arr[len - 1];
        }

        //获取栈内元素的个数
        size() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.length;
        }

        //对栈内所有元素进行打印
        print() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.toString();
        }

        //对栈进行清空
        clear() {
            stack_mock.set(this, []);
        }
    }
    //返回类函数Stack
    return Stack;
})();
//声明一个栈Stack类的实例
let stack = new Stack();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//向栈中添加元素
stack.push(&quot;Gary&quot;);
stack.push(&quot;Lily&quot;);
stack.push(&quot;Frank&quot;);
stack.push(&quot;Simon&quot;);
//在这里打印添加元素之后的返回值
//这里打印栈内的元素个数:
//5
console.log(stack.push(&quot;Aaron&quot;));
//在这里打印栈是否为空
//这里打印:
//false
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//5
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Aaron&quot;
console.log(stack.peek());
//在这里打印栈内所有的元素
//这里打印:
//Gary,Lily,Frank,Simon,Aaron
console.log(stack.print());
//在这里对栈内元素从栈顶进行删除
//这里打印:
//Aaron
console.log(stack.pop());
//在这里打印栈内元素的个数
//这里打印:
//4
console.log(stack.size());
//在这里打印栈顶的元素
//这里打印:
//&quot;Simon&quot;
console.log(stack.peek());
//对栈进行清空
stack.clear();
//在这里打印栈是否为空
//这里打印:
//true
console.log(stack.isEmpty());
//在这里打印栈内元素的个数
//这里打印:
//0
console.log(stack.size());
</code></pre><blockquote>
<p>这样就完美的写出了一个栈 Stack类函数,内部WeakMap集合属性设置类的数组,不可获取且修改,全局下也不可轻易的拿到且进行随意的修改,具有良好的封装性、安全性、扩展性以及可维护性</p>
</blockquote>
<h2 id="使用栈解决计算机科学中的经典算法问题"><a href="#使用栈解决计算机科学中的经典算法问题" class="headerlink" title="使用栈解决计算机科学中的经典算法问题"></a>使用栈解决计算机科学中的经典算法问题</h2><h3 id="十进制转化为二进制"><a href="#十进制转化为二进制" class="headerlink" title="十进制转化为二进制"></a>十进制转化为二进制</h3><blockquote>
<p>首先你要知道十进制转化二进制的原理,先从二进制转化为十进制说起,二进制中只有0和1,在相加时就是足2进1,比如说10这个十进制整数,转化为二进制就是1010,二进制分离转化十进制:1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0相加就是10这个十进制整数,所以十进制转化为二进制,就需要对2取余,取余之后再除以2到达下一位数,依次将余数添加进栈中,再依次从栈顶取出并删除栈顶元素,十进制转化为二进制是遵从栈<b>后进先出</b>的特点的</p>
</blockquote>
<pre><code>let Stack = (function (){
    //声明一个可公用的WeakMap的集合变量: stack_mock
    //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
    let stack_mock = new WeakMap();
    //声明一个类函数,这里当作栈Stack的类
    class Stack {
        constructor() {
            //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组
            stack_mock.set(this, []);
        }

        //向栈内添加元素
        push(element) {
            let stack_arr = stack_mock.get(this);
            let stack_index = stack_arr.push(element);
            stack_mock.set(this, stack_arr);
            return stack_index;
        }

        //栈顶删除元素
        pop() {
            let stack_arr = stack_mock.get(this);
            let stack_item = stack_arr.pop();
            stack_mock.set(this, stack_arr);
            return stack_item;
        }

        //校验栈是否为空
        isEmpty() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.length === 0;
        }

        //获取栈顶元素
        peek() {
            let stack_arr = stack_mock.get(this),
                len = stack_arr.length;
            return stack_arr[len - 1];
        }

        //获取栈内元素的个数
        size() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.length;
        }

        //对栈内所有元素进行打印
        print() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.toString();
        }

        //对栈进行清空
        clear() {
            stack_mock.set(this, []);
        }
    }
    //返回类函数Stack
    return Stack;
})();

/**进行十进制转化为二进制的函数
 * @params decimal 传进去的十进制参数
 */
let DecimalConversionBinary = (decimal)=&gt; {
    //声明一个栈Stack类的实例
    let stack = new Stack(),
        //声明一个承接%2之后的余数的变量
        decimal_remainder,
        //声明一个承接最终二进制的字符串变量,初始化为空字符串
        result_binary = &quot;&quot;,
        //声明一个承接十进制的变量
        decimal_integer = decimal;
    //在十进制的变量除以2还不为0时,继续执行循环    
    while(decimal_integer / 2){
        //将十进制的变量对2进行取余,余数赋值给承接余数的变量
        decimal_remainder = decimal_integer % 2;
        //将余数添加进栈中
        stack.push(decimal_remainder);
        //十进制的变量取余后,再除以2向下取整,到达下一位数,复制给十进制的变量
        decimal_integer = Math.floor(decimal_integer / 2);
    }
    //检测栈是否为空,如果不为空,则继续执行循环
    while(!stack.isEmpty()){
        //承接二进制字符串的变量不断的拼接栈顶的元素,而栈顶元素也不断在被删除
        result_binary += stack.pop();
    }
    //待到栈顶元素彻底删除完毕,栈为空栈了,就返回最终的二进制变量
    return result_binary;
};
let binary = DecimalConversionBinary(10);
//在这里打印:
//1010
console.log(binary);
</code></pre><h3 id="十进制转化为任何进制"><a href="#十进制转化为任何进制" class="headerlink" title="十进制转化为任何进制"></a>十进制转化为任何进制</h3><blockquote>
<p>十进制转化为任何进制的原理跟二进制是一样的,只不过除以的数值变了,所以需要外部传入,这样做的比较通用</p>
</blockquote>
<pre><code>let Stack = (function (){
    //声明一个可公用的WeakMap的集合变量: stack_mock
    //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
    let stack_mock = new WeakMap();
    //声明一个类函数,这里当作栈Stack的类
    class Stack {
        constructor() {
            //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组
            stack_mock.set(this, []);
        }

        //向栈内添加元素
        push(element) {
            let stack_arr = stack_mock.get(this);
            let stack_index = stack_arr.push(element);
            stack_mock.set(this, stack_arr);
            return stack_index;
        }

        //栈顶删除元素
        pop() {
            let stack_arr = stack_mock.get(this);
            let stack_item = stack_arr.pop();
            stack_mock.set(this, stack_arr);
            return stack_item;
        }

        //校验栈是否为空
        isEmpty() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.length === 0;
        }

        //获取栈顶元素
        peek() {
            let stack_arr = stack_mock.get(this),
                len = stack_arr.length;
            return stack_arr[len - 1];
        }

        //获取栈内元素的个数
        size() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.length;
        }

        //对栈内所有元素进行打印
        print() {
            let stack_arr = stack_mock.get(this);
            return stack_arr.toString();
        }

        //对栈进行清空
        clear() {
            stack_mock.set(this, []);
        }
    }
    //返回类函数Stack
    return Stack;
})();

/**进行十进制转化为任何进制的函数
 * @params decimal 传进去的十进制参数
 * @params radix 表示十进制要转化的进制类型
 */
let DecimalConversionRadix = (decimal, radix)=&gt; {
    //声明一个栈Stack类的实例
    let stack = new Stack(),
        //声明一个承接%radix之后的余数的变量
        decimal_remainder,
        //声明一个承接最终外部传入进制的字符串变量,初始化为空字符串
        result_radix = &quot;&quot;,
        //声明一个承接十进制的变量
        decimal_integer = decimal,
        //各个进制栈中的进制位数所对应的字符文本,最多十六进制,最少二进制
        radix_formatter = &quot;0123456789ABCDEF&quot;;
    //在十进制的变量除以radix还不为0时,继续执行循环    
    while(decimal_integer / radix){
        //将十进制的变量对radix进行取余,余数赋值给承接余数的变量
        decimal_remainder = decimal_integer % radix;
        //将余数添加进栈中
        stack.push(decimal_remainder);
        //十进制的变量取余后,再除以radix向下取整,到达下一位数,复制给十进制的变量
        decimal_integer = Math.floor(decimal_integer / radix);
    }
    //检测栈是否为空,如果不为空,则继续执行循环
    while(!stack.isEmpty()){
        //承接外部传入进制字符串的变量不断的拼接栈顶的元素所对应的字符文本,而栈顶元素也不断在被删除
        result_radix += radix_formatter[stack.pop()];
    }
    //待到栈顶元素彻底删除完毕,栈为空栈了,就返回最终的外部传入进制变量
    return result_radix;
};
//这里传入的进制类型是二进制
let radix = DecimalConversionRadix(10, 2);
//在这里打印:
//1010
console.log(radix);
//这里传入的进制类型是十六进制
let radix_ano = DecimalConversionRadix(100, 16);
//在这里打印:
//64
console.log(radix_ano);
</code></pre><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h1><blockquote>
<p>队列也是数据结构中比较简单的顺序数据结构,和栈相似,特点是: <b>先进先出</b>,新的元素都会添加到队列的末尾,等待队列中之前已经添加的元素删除掉,现实生活中也有好多队列的例子,排队就是很常见的例子,在医院排队挂号、在食堂排队打饭、在抢票软件中排队抢票等等一系列都是队列的表现,经过栈Stack一系列的对类函数Stack的优化改进,在和栈Stack相似的队列Queue这里就不再赘述,我们直接写最终的优化改进的ES6版本</p>
</blockquote>
<pre><code>let Queue = (function() {
    //声明一个可公用的WeakMap的集合变量: queue_mock
    //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
    let queue_mock = new WeakMap();
    //声明一个类函数,这里当作队列Queue的类
    class Queue {
        constructor(){
            //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组
            queue_mock.set(this, []);
        }

        //向队列末尾中添加新的元素
        enqueue(element) {
            let queue_arr = queue_mock.get(this);
            let queue_index = queue_arr.push(element);
            queue_mock.set(this, queue_arr);
            return queue_index;
        }

        //将队列列头的元素删除掉
        dequeue() {
            let queue_arr = queue_mock.get(this);
            let queue_item = queue_arr.shift();
            queue_mock.set(this, queue_arr);
            return queue_item;
        }

        //检测队列是否为空
        isEmpty() {
            return queue_mock.get(this).length === 0;
        }

        //获取队列中元素的个数
        size() {
            return queue_mock.get(this).length;
        }

        //将队列清空
        clear() {
            queue_mock.set(this, []);
        }

        //将队列中所有的元素进行打印
        print() {
            return queue_mock.get(this).toString();
        }

        //获取队列列头的元素
        front() {
            return queue_mock.get(this)[0];
        }
    }
})();

//声明一个队列Queue类实例
let queue = new Queue();
//这里判断队列是否为空
//在这里打印:
//true
console.log(queue.isEmpty());
//向队列中添加元素
queue.enqueue(&quot;Gary&quot;);
queue.enqueue(&quot;Lily&quot;);
queue.enqueue(&quot;Simon&quot;);
queue.enqueue(&quot;Aaron&quot;);
//这里打印队列添加元素的返回值
//在这里打印队列中元素的个数:
//5
console.log(queue.enqueue(&quot;Frank&quot;));
//这里判断队列是否为空
//在这里打印:
//false
console.log(queue.isEmpty());
//这里打印队列中元素的个数
//在这里打印:
//5
console.log(queue.size());
//这里打印队列中列头的元素
//在这里打印:
//&quot;Gary&quot;
console.log(queue.front());
//这里打印队列中所有的元素
//在这里打印:
//Gary,Lily,Simon,Aaron,Frank
console.log(queue.print());
//这里将队列列头的元素删除
//在这里打印列头的元素:
//&quot;Gary&quot;
console.log(queue.dequeue());
queue.dequeue();
queue.dequeue();
//这里打印队列中元素的个数
//在这里打印:
//2
console.log(queue.size());
//这里打印队列中列头的元素
//在这里打印:
//&quot;Aaron&quot;
console.log(queue.front());
//将队列清空
queue.clear();
//这里判断队列是否为空
//在这里打印:
//true
console.log(queue.isEmpty());
//这里打印队列中元素的个数
//在这里打印:
//0
console.log(queue.size());
</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><blockquote>
<p>队列有时需要根据某些参数进行优先级处理,比如我们乘坐飞机,购买飞机票,分为头等舱、商务舱和经济舱,头等舱的优先级最高,经济舱的优先级最低,所以在进行队列处理时,需要根据优先级进行排列</p>
</blockquote>
<pre><code>let Queue = (function () {
    //声明一个可公用的WeakMap的集合变量: queue_mock
    //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
    let queue_mock = new WeakMap();
    //声明一个队列优先级类函数
    //生成队列元素优先级实例
    class Queue_Prior {
        constructor(element, prior) {
            this.element = element;
            this.prior = prior;
        }
    }
    //声明一个类函数,这里当作队列Queue的类
    class Queue {
        constructor() {
            //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组
            queue_mock.set(this, []);
        }
        //根据优先级向队列中添加优先级实例元素
        enqueue(element, prior) {
            //生成队列优先级实例元素
            let queue_prior = new Queue_Prior(element, prior),
                //获取现状态的队列
                queue_arr = queue_mock.get(this),
                len = queue_arr.length,
                index = 0;
            //循环现状态的队列,假如队列中存在元素优先级比实例优先级小的,就插入到小优先级队列元素之前
            while(index &lt; len) {
                if(queue_arr[index][&quot;prior&quot;] &gt; queue_prior[&quot;prior&quot;]) {
                    queue_arr.splice(index, 0, queue_prior);
                    queue_mock.set(this, queue_arr);
                    return index + 1;
                }
                index++;
            }
            //假如不存在,就直接添加到队列列尾
            index = queue_arr.push(queue_prior);
            queue_mock.set(this, queue_arr);
            return index;   
        }

        //对队列列头的元素进行删除
        dequeue() {
            let queue_arr = queue_mock.get(this);
            let queue_index = queue_arr.shift();
            queue_mock.set(this, queue_arr);
            return queue_index;
        }

        //判断队列是否为空
        isEmpty() {
            return queue_mock.get(this).length === 0;
        }

        //获取队列中的元素个数
        size() {
            return queue_mock.get(this).length;
        }

        //对队列进行清空
        clear() {
            queue_mock.set(this, []);
        }

        //获取队列列头的元素
        front() {
            return queue_mock.get(this)[0];
        }

        //对队列中的所有的元素进行打印
        print() {
            let queue_arr = queue_mock.get(this);
            let len = queue_arr.length;
            let queue_toString_arr = [];
            for(let i = 0; i &lt; len; i++) {
                queue_toString_arr.push(queue_arr[i][&quot;element&quot;]);
            }
            return queue_toString_arr.toString();
        }
    }
    //返回队列Queue队列
    return Queue;   
})();

//声明一个优先队列Queue类实例
let queue = new Queue();
//这里判断优先队列是否为空
//在这里打印:
//true
console.log(queue.isEmpty());
//向优先队列中添加元素
queue.enqueue(&quot;Gary&quot;, 1);
queue.enqueue(&quot;Lily&quot;, 2);
queue.enqueue(&quot;Simon&quot;, 1);
queue.enqueue(&quot;Aaron&quot;, 3);
//这里打印优先队列添加元素的返回值
//在这里打印优先队列添加元素的位置:
//4
console.log(queue.enqueue(&quot;Frank&quot;, 2));
//这里判断优先队列是否为空
//在这里打印:
//false
console.log(queue.isEmpty());
//这里打印优先队列中元素的个数
//在这里打印:
//5
console.log(queue.size());
//这里打印优先队列中列头的元素
//在这里打印:
//{element: &quot;Gary&quot;, prior: 1}
console.log(queue.front());
//这里打印优先队列中所有的元素
//在这里打印:
//Gary,Simon,Lily,Frank,Aaron
console.log(queue.print());
//这里将优先队列列头的元素删除
//在这里打印列头的元素:
//{element: &quot;Gary&quot;, prior: 1}
console.log(queue.dequeue());
queue.dequeue();
queue.dequeue();
//这里打印优先队列中元素的个数
//在这里打印:
//2
console.log(queue.size());
//这里打印优先队列中列头的元素
//在这里打印:
//{element: &quot;Frank&quot;, prior: 2}
console.log(queue.front());
//将优先队列清空
queue.clear();
//这里判断优先队列是否为空
//在这里打印:
//true
console.log(queue.isEmpty());
//这里打印优先队列中元素的个数
//在这里打印:
//0
console.log(queue.size());
</code></pre><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="使用循环队列解决计算机经典算法-击鼓传花"><a href="#使用循环队列解决计算机经典算法-击鼓传花" class="headerlink" title="使用循环队列解决计算机经典算法 - 击鼓传花"></a>使用循环队列解决计算机经典算法 - 击鼓传花</h3><blockquote>
<p>用队列来实现击鼓传花,再合适不过了,给定一个数组以及传递的次数作为函数的参数</p>
</blockquote>
<pre><code>let Queue = (function () {
    //声明一个可公用的WeakMap的集合变量: queue_mock
    //为了避免此变量在全局中可以轻易拿到并进行随意修改,在外包一层自执行函数表达式,用函数作用域来保证它在全局中拿不到,且也修改不了
    let queue_mock = new WeakMap();
    //声明一个类函数,这里当作队列Queue的类
    class Queue {
        constructor() {
            //在类函数内部通过WeakMap集合变量设置本类,并初始化为空数组
            queue_mock.set(this, []);
        }

        //向队列末尾中添加新的元素
        enqueue(element) {
            let queue_arr = queue_mock.get(this);
            let queue_index = queue_arr.push(element);
            queue_mock.set(this, queue_arr);
            return queue_index;
        }

        //将队列列头的元素删除掉
        dequeue() {
            let queue_arr = queue_mock.get(this);
            let queue_item = queue_arr.shift();
            queue_mock.set(this, queue_arr);
            return queue_item;
        }

        //检测队列是否为空
        isEmpty() {
            return queue_mock.get(this).length === 0;
        }

        //获取队列中的元素个数
        size() {
            return queue_mock.get(this).length;
        }

        //对队列进行清空
        clear() {
            queue_mock.set(this, []);
        }

        //对队列中的所有的元素进行打印
        print() {
            return queue_mock.get(this).toString();
        }

        //对队列中的所有的元素进行打印
        front() {
            return queue_mock.get(this)[0];
        }
    }
    return Queue;
})();

//击鼓传花函数
//@params queueList 数组
//@params count 传递的次数
function passThePaperFlower(queueList, count) {
    //声明一个循环队列Queue类的实例
    let queue = new Queue();
    //遍历数组,将数组元素添加到队列中
    for(let i = 0; i &lt; queueList.length; i++) {
        queue.enqueue(queueList[i]);
    }
    //只要队列中的元素大于1,就继续循环
    while(queue.size() &gt; 1) {
        //遍历传递的次数,将队列列头的元素(就是击鼓传花中要淘汰的人)删除掉,再添加到队列的列尾
        for(let j = 0; j &lt; count; j++) {
            queue.enqueue(queue.dequeue());
        }
        //获取到传递完之后,队列列头的元素
        let queueItem = queue.dequeue();
        console.log(`${queueItem}被淘汰~`);
    }
    //返回队列中仅剩的最后的击鼓传花大赢家
    return queue.front();
}
//给定的进行击鼓传花的人
let paperFlowerParticipant = [&quot;Gary&quot;, &quot;Lily&quot;, &quot;Aaron&quot;, &quot;Alice&quot;, &quot;Simon&quot;, &quot;Frank&quot;];
//队列中仅剩的最后的击鼓传花大赢家
let finallyGet = passThePaperFlower(paperFlowerParticipant, 10);
//对最后的击鼓传花大赢家进行打印
console.log(&quot;最后的赢家是:&quot; + finallyGet);
</code></pre><h1 id="链表-LinkList"><a href="#链表-LinkList" class="headerlink" title="链表 LinkList"></a>链表 LinkList</h1><blockquote>
<p>前面说了栈和队列简单的顺序数据结构,下面介绍一下最后的顺序数据结构: 链表 LinkList,链表相比于栈和队列的优点在于: 栈和队列会直接对内部元素进行添加、修改以及删除的操作,使得其他内存元素的位置发生改变(其他元素前移或者后移),大量的消耗内存,而链表不会破坏内存元素的位置,假如进行添加、修改以及删除的操作,直接断开中间的一个环节,将这个环节的前一个环节以及后一个环节重连就可以了,生活中也有很多链表的例子: 比如说火车,火车的车厢都是一环连着一环的,和链表差不多</p>
</blockquote>
<pre><code>let LinkList = (function() {
    //定义链表头部的链表元素,并在初始化时设置为null
    //定义链表的长度,并在初始化时设置为0
    let head = new WeakMap(),
        length = new WeakMap();

    //声明链表元素Node对象的类函数
    //初始化有两个参数
    //@param node 现链表元素的值
    //@param next 用来链接下一个链表元素
    class Node {
        constructor(node) {
            this.node = node;
            this.next = null;
        }
    }

    //声明链表LinkList对象的类函数
    class LinkList {
        constructor() {
            head.set(this, null);
            length.set(this, 0);
        }

        //向链表中添加链表元素
        insert(element) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                node = new Node(element);
            if(!headElement) {
                headElement = node;
            } else {
                while(current.next) {
                    current = current.next;
                }
                current.next = node;
            }
            lengths++;
            head.set(this, headElement);
            length.set(this, lengths);
            return lengths;
        }
        //向链表的指定位置添加链表元素
        insertAt(element, position) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                previous,
                node = new Node(element);
            if(position &gt;=0 &amp;&amp; position &lt; lengths) {
                if(!headElement) {
                    headElement = node;
                } else {
                    if(position === 0) {
                        node.next = current;
                        headElement = node;
                    } else {
                        while(index++ &lt; position) {
                            previous = current;
                            current = current.next;
                        }
                        previous.next = node;
                        node.next = current;
                    }
                }
                lengths++;
                head.set(this, headElement);
                length.set(this, lengths);
                return position;
            }
            return false;
        }
        //删除链表中的指定链表元素
        remove(element) {
            const {indexOf, removeAt} = this;
            let index = indexOf.bind(this)(element);
            return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : index;
        }

        //获取指定链表元素的位置
        indexOf(element) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0;

            while(index++ &lt; lengths) {
                if(element === current.node) {
                    return index - 1;
                }
                current = current.next;
            }
            return false;
        }

        //删除链表中指定位置的链表元素
        removeAt(position) {
            let headElement = head.get(this),
                lengths = length.get(this),
                index = 0,
                previous,
                current = headElement;
            if(position &gt;=0 &amp;&amp; position &lt; lengths) {
                if(!head) {
                    return false;
                } else {
                    if(lengths === 1) {
                        headElement = null;
                    } else {
                        if(position === 0) {
                            headElement = current.next;
                        } else {
                            while(index++ &lt; position) {
                                previous = current;
                                current = current.next;
                            }
                            previous.next = current.next;
                        }
                    }
                }
                lengths--;
                head.set(this, headElement);
                length.set(this, lengths);
                return position;
            }
            return false;
        }

        //获取链表中所有的链表结构
        toString() {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                result = ``;
            while(index++ &lt; lengths) {
                result = `${result}${current.node}|~`;
                current = current.next;
            }
            return result;
        }

        //获取链表的头部链表元素
        headElement() {
            return head.get(this).node;
        }

        //获取链表的长度
        size() {
            return length.get(this);
        }

        //判断链表是否为空
        isEmpty() {
            return length.get(this) === 0;
        }

        //获取链表的真实结构
        valueOf() {
            return head.get(this);
        }

        //将链表清空
        clear() {
            head.set(this, null);
            length.set(this, 0);
        }
    }

    //返回链表LinkList类函数
    return LinkList;
})();

//声明链表类函数的实例
let link_list = new LinkList();
//这里判断链表是否是空链表
//在这里打印:
//true
console.log(link_list.isEmpty());
//这里获取链表的长度
//在这里打印:
//0
console.log(link_list.size());
//这里打印链表元素的数量:
//在这里打印:
//1
console.log(link_list.insert(104));
link_list.insert(99);
link_list.insert(155);
link_list.insert(34);
link_list.insert(16);
//这里判断链表是否是空链表
//在这里打印:
//false
console.log(link_list.isEmpty());
//这里获取链表的长度
//在这里打印:
//5
console.log(link_list.size());
//这里打印链表中所有的链表元素
//在这里打印:
//104
//99
//155
//34
//16
console.log(link_list.toString());
//这里获取链表的头部链表元素
//在这里打印:
//104
console.log(link_list.headElement());
//这里在链表下标为2处插入链表元素
//在这里打印:
//2
console.log(link_list.insertAt(88, 2));
//这里打印链表中所有的链表元素
//在这里打印:
//104
//99
//88
//155
//34
//16
console.log(link_list.toString());
//这里打印链表中所有的链表结构
//在这里打印:
//{element: 104, next: {element: 99, next: {element: 88, next: {element: 155, next: {element: 34, next: {element: 16, next: null}}}}}}
console.log(link_list.valueOf());
//这里删除链表下标为3处的链表元素
//在这里打印:
//3
console.log(link_list.removeAt(3));
link_list.removeAt(4);
//这里打印链表中所有的链表元素
//在这里打印:
//104
//99
//88
//34
console.log(link_list.toString());
//这里删除链表中链表元素为88的链表元素
//在这里打印:
//2
console.log(link_list.remove(88));
//这里打印链表中所有的链表元素
//在这里打印:
//104
//99
//34
link_list.toString();
//这里打印链表中的头部链表元素
//在这里打印:
//104
console.log(link_list.headElement());
link_list.clear();
//这里判断链表是否是空链表
//在这里打印:
//true
console.log(link_list.isEmpty());
//这里获取链表的长度
//在这里打印:
//0
console.log(link_list.size());
</code></pre><h2 id="双向链表-DoublyLinkList"><a href="#双向链表-DoublyLinkList" class="headerlink" title="双向链表 DoublyLinkList"></a>双向链表 DoublyLinkList</h2><blockquote>
<p>双向链表和单向链表的模式,唯一的区别: 双向链表多出了一个尾部链表元素,且链表元素类实例不仅仅有next属性,还有prev属性,next指向下一个链表元素,prev指向上一个链表元素</p>
</blockquote>
<pre><code>let DoublyLinkList = (function() {
    //定义链表头部的链表元素,并在初始化时设置为null
    //定义链表尾部的链表元素,并在初始化时设置为null
    //定义链表的长度,并在初始化时设置为0
    let head = new WeakMap(),
        tail = new WeakMap(),
        length = new WeakMap();

    //声明链表元素Node对象的类函数
    //初始化有三个参数
    //@param node 现链表元素的值
    //@param next 用来链接下一个链表元素
    //@param prev 用来链接上一个链表元素
    class Node {
        constructor(node) {
            this.node = node;
            this.next = null;
            this.prev = null;
        }
    }

    //声明双向链表DoublyLinkList对象的类函数
    class DoublyLinkList {
        constructor() {
            head.set(this, null);
            tail.set(this, null);
            length.set(this, 0);
        }

        //向链表中添加链表元素
        insert(element) {
            let headElement = head.get(this),
                tailElement = tail.get(this),
                lengths = length.get(this),
                current = headElement,
                node = new Node(element);
            if(!headElement) {
                headElement = node;
                tailElement = node;
            } else {
                while(current.next) {
                    current = current.next;
                }
                current.next = node;
                node.prev = current;
                tailElement = node;
            }
            lengths++;
            head.set(this, headElement);
            tail.set(this, tailElement);
            length.set(this, lengths);
            return lengths;
        }

        //向链表的指定位置添加链表元素
        insertAt(element, position) {
            let headElement = head.get(this),
                tailElement = tail.get(this),
                current = headElement,
                lengths = length.get(this),
                node = new Node(element),
                previous,
                index = 0;
            if(position &gt;=0 &amp;&amp; position &lt; lengths) {
                if(!headElement) {
                    headElement = node;
                    tailElement = node;
                } else {
                    if(position === 0) {
                        node.next = current;
                        current.prev = node;
                        headElement = node;
                    } else if(position === lengths - 1) {
                        node.prev = tailElement;
                        tailElement.next = node;
                        tailElement = node;
                    } else {
                        while(index++ &lt; position) {
                            previous = current;
                            current = current.next;
                        }
                        previous.next = node;
                        node.prev = previous;
                        node.next = current;
                        current.prev = node;
                    }
                }
                lengths++;
                head.set(this, headElement);
                tail.set(this, tailElement);
                length.set(this, lengths);
                return position;
            }
            return false;
        }

        //删除链表中指定位置的链表元素
        removeAt(position) {
            let headElement = head.get(this),
                tailElement = tail.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                previous;
            if(position &gt;=0 &amp;&amp; position &lt; lengths) {
                if(!headElement) {
                    return false;
                } else {
                    if(lengths === 1) {
                        headElement = null;
                        tailElement = null;
                    } else {
                        if(position === 0) {
                            headElement = current.next;
                            headElement.prev = null;
                        } else if (position === lengths - 1) {
                            tailElement = tailElement.prev;
                            tailElement.next = null;
                        } else {
                            while(index++ &lt; position) {
                                previous = current;
                                current = current.next;
                            }
                            previous.next = current.next;
                            current.next.prev = previous;
                        }
                    }
                    lengths--;
                    head.set(this, headElement);
                    tail.set(this, tailElement);
                    length.set(this, lengths);
                    return position;
                }
            }
            return false;
        }

        //获取链表指定的元素位置
        indexOf(element) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0;
            while(index++ &lt; lengths) {
                if(current.node === element) {
                    return index - 1;
                }
                current = current.next;
            }
            return false;  
        }

        //删除链表中的指定链表元素
        remove(element) {
            const {indexOf, removeAt} = this;
            let index = indexOf.bind(this)(element);
            return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : false;
        }

        //获取链表的长度
        size() {
            return length.get(this);
        }

        //判断链表是否为空数组
        isEmpty() {
            return length.get(this) === 0;
        }

        //打印链表中所有的链表元素
        toString() {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                result = ``;
            while(index++ &lt; lengths) {
                result = `${result}${current.node}~|~`;
                current = current.next;
            }   
            return result; 
        }

        //获取链表中所有的链表结构
        valueOf() {
            return head.get(this);
        }

        //将链表清空
        clear() {
            head.set(this, null);
            tail.set(this, null);
            length.set(this, 0);
        }

        //获取链表的头部链表元素
        headElement() {
            return head.get(this).node;
        }

        //获取链表的尾部链表元素
        tailElement() {
            return tail.get(this).node;
        }
    }

    //返回双向链表DoublyLinkList类函数
    return DoublyLinkList;
})();    

let doubly_link = new DoublyLinkList();
//这里打印链表是否为空链表
//在这里打印:
//true
console.log(doubly_link.isEmpty());
//这里打印链表的长度
//在这里打印:
//0
console.log(doubly_link.size());
//这里打印插入新的链表元素后链表的长度
//在这里打印:
//1
console.log(doubly_link.insert(111));
doubly_link.insert(88);
doubly_link.insert(99);
doubly_link.insert(77);
doubly_link.insert(222);
//这里打印链表是否为空链表
//在这里打印:
//false
console.log(doubly_link.isEmpty());
//这里打印链表的长度
//在这里打印:
//5
console.log(doubly_link.size());
//这里打印链表的头部链表元素
//在这里打印:
//111
console.log(doubly_link.headElement());
//这里打印链表的尾部链表元素
//在这里打印:
//222
console.log(doubly_link.tailElement());
//这里打印链表的所有链表元素
//在这里打印:
//111~|88~|99~|77~|222~|
console.log(doubly_link.toString());
//这里打印链表的所有链表结构
//在这里打印:
//{prev: null, element: 111, next: {prev: {//上一个链表元素 ...}, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 77, next: {//上一个链表元素 ...}, element: 222, next: null}}}}}
console.log(doubly_link.valueOf());
//这里打印插入到3号位置的新的链表元素的下标位置
//在这里打印:
//3
console.log(doubly_link.insertAt(66, 3));
//这里打印链表的所有链表元素
//在这里打印:
//111~|88~|99~|66~|77~|222~|
console.log(doubly_link.toString());
//这里打印链表的所有链表结构
//在这里打印:
//{prev: null, element: 111, next: {prev: {//上一个链表元素 ...}, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 66, next: {prev: {//上一个链表元素 ...}, element: 77, next: {//上一个链表元素 ...}, element: 222, next: null}}}}}}
console.log(doubly_link.valueOf());
//这里打印删除4号位置的链表元素的下标位置
//在这里打印:
//4
console.log(doubly_link.removeAt(4));
doubly_link.removeAt(0);
//这里打印删除指定的链表元素的下标位置
//在这里打印:
//2
doubly_link.remove(66);
//这里打印链表的所有链表元素
//在这里打印:
//88~|99~|222~|
console.log(doubly_link.toString());
//这里打印链表的所有链表结构
//在这里打印:
//{prev: null, element: 88, next: {prev: {//上一个链表元素 ...}, element: 99, next: {prev: {//上一个链表元素 ...}, element: 222, next: null}}}
console.log(doubly_link.valueOf());
//这里打印链表的头部链表元素
//在这里打印:
//88
console.log(doubly_link.headElement());
//这里打印链表的尾部链表元素
//在这里打印:
//222
console.log(doubly_link.tailElement());
doubly_link.clear();
//这里打印链表是否为空链表
//在这里打印:
//true
console.log(doubly_link.isEmpty());
//这里打印链表的长度
//在这里打印:
//0
console.log(doubly_link.size());
</code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="自己封装Set集合"><a href="#自己封装Set集合" class="headerlink" title="自己封装Set集合"></a>自己封装Set集合</h2><blockquote>
<p>接下来学习下一种非顺序线性数据结构,那就是集合。在实义上指的是具有某种特定性质的事物的总体,俗话讲的好,”物以类聚,人以群分”,这是对集合相当恰当的写照,在ES6中,新语法对象Set也是用来实现集合的,下面我们也来封装一下Set集合,并封装一些ES6 Set语法中不存在的方法,比如:交集、并集、差集和子集</p>
</blockquote>
<pre><code>let Set = (function () {
    //设置集合的容器,并在初始化时设置为空对象{}
    let set = new WeakMap();

    //设置集合类
    class Set {
        constructor() {
            set.set(this, {});
        }

        //在集合中添加集合项
        add(value) {
            let set_add = set.get(this);
            set_add[value] = value;
            set.set(this, set_add);
            return true;
        }

        //判断集合中是否存在此集合项
        has(value) {
            let set_has = set.get(this);
            return set_has.hasOwnProperty(value);
        }

        //删除集合中的指定集合项
        delete(value) {
            let set_delete = set.get(this);
            if(set_delete.hasOwnProperty(value)) {
                delete set_delete[value];
                set.set(this, set_delete);
                return true;
            }
            return false;
        }

        //获取集合的长度
        size() {
            let set_size = set.get(this),
                index = 0;
            for(let [key, value] of Object.entries(set_size)) {
                index++;
            }
            return index;
        }

        //判断集合是否为空
        isEmpty() {
            let set_isEmpty = set.get(this);
            for(let [key, value] of Object.entries(set_isEmpty)) {
                if(set_isEmpty.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        }

        //获取集合的属性值数组
        values() {
            let set_values = set.get(this);
            return Object.values(set_values);
        }

        //清空集合
        clear() {
            set.set(this, {});
            return true;
        }

        //并集
        union(union_ano) {
            let union_this = this,
                union_new = new Set();
            for(let [key_this, value_this] of union_this.values().entries()) {
                union_new.add(value_this);
            }
            for(let [key_ano, value_ano] of union_ano.values().entries()) {
                union_new.add(value_ano);
            }
            return union_new.values();
        }

        //交集
        intersection(intersection_ano) {
            let intersection_this = this,
                intersection_new = new Set();
            for(let [key_this, value_this] of intersection_this.values().entries()) {
                if(intersection_ano.has(value_this)) {
                    intersection_new.add(value_this);
                }
            }
            return intersection_new.values();
        }

        //差集
        differenceSet(differenceSet_ano) {
            let differenceSet_this = this,
                differenceSet_new = new Set();
            for(let [key, value] of differenceSet_this.values().entries()) {
                if(!differenceSet_ano.has(value)) {
                    differenceSet_new.add(value);
                }
            }
            return differenceSet_new.values();
        }

        //子集
        subset(subset_ano) {
            let subset_this = this;
            for(let [key, value] of subset_this.values().entries()) {
                if(!subset_ano.has(value)) {
                    return false;
                }
            }
            return true;
        }
    }

    //返回集合类
    return Set;
})();

let set = new Set();
//这里判断集合是否为空
//在这里打印:
//true
console.log(set.isEmpty());
//这里查看集合的长度
//在这里打印:
//0
console.log(set.size());
//这里在集合中添加集合项,并返回true
//在这里打印:
//true
console.log(set.add(&quot;Gary&quot;));
set.add(&quot;Simon&quot;);
set.add(&quot;Frank&quot;);
set.add(&quot;Lily&quot;);
set.add(&quot;Alice&quot;);
set.add(&quot;Tom&quot;);
set.add(&quot;Tommy&quot;);
//这里判断集合是否为空
//在这里打印:
//false
console.log(set.isEmpty());
//这里查看集合的长度
//在这里打印:
//7
console.log(set.size());
//这里判断集合中是否存在此集合项&quot;Gary&quot;
//在这里打印:
//true
console.log(set.has(&quot;Gary&quot;));
//这里判断集合中是否存在此集合项&quot;Alice&quot;
//在这里打印:
//true
console.log(set.has(&quot;Alice&quot;));
//这里判断集合中是否存在此集合项&quot;Clay&quot;
//在这里打印:
//false
console.log(set.has(&quot;Clay&quot;));
//这里获取集合的属性值数组
//在这里打印:
//[&quot;Gary&quot;, &quot;Simon&quot;, &quot;Frank&quot;, &quot;Lily&quot;, &quot;Alice&quot;, &quot;Tom&quot;, &quot;Tommy&quot;]
console.log(set.values());
//这里删除集合中的指定集合项
//在这里打印:
//true
console.log(set.delete(&quot;Simon&quot;));
set.delete(&quot;Alice&quot;);
//这里查看集合的长度
//在这里打印:
//5
console.log(set.size());
//这里获取集合的属性值数组
//在这里打印:
//[&quot;Gary&quot;, &quot;Frank&quot;, &quot;Lily&quot;, &quot;Tom&quot;, &quot;Tommy&quot;]
console.log(set.values());
set.clear();
//这里判断集合是否为空
//在这里打印:
//true
console.log(set.isEmpty());
//这里打印集合的长度
//在这里打印:
//0
console.log(set.size());
let _set = new Set();
let _set_ano = new Set();
_set.add(45);
_set.add(66);
_set.add(100);
_set.add(52);
_set.add(28);
_set.add(89);
_set_ano.add(28);
_set_ano.add(52);
_set_ano.add(111);
_set_ano.add(120);
_set_ano.add(18);
//这里查询两个集合属于_set集合或者属于_set_ano集合的并集
//在这里打印:
//[45, 66, 100, 52, 28, 89, 111, 120, 18]
console.log(_set.union(_set_ano));
//这里查询两个集合既属于_set集合又属于_set_ano集合的交集
//在这里打印:
//[28, 52]
console.log(_set.intersection(_set_ano));
//这里查询两个集合属于_set集合但不属于_set_ano集合的差集
//在这里打印:
//[45, 66, 100, 89]
console.log(_set.differenceSet(_set_ano));
//这里查询_set集合是否是_set_ano的子集
//在这里打印:
//false
console.log(_set.subset(_set_ano));
</code></pre><h2 id="ES6-Set集合"><a href="#ES6-Set集合" class="headerlink" title="ES6 Set集合"></a>ES6 Set集合</h2><blockquote>
<p>之前说过ES6中使用Set来表现集合,ES6的Set也有add、has、delete和clear等方法,当然size是以属性来存储集合的长度,而也拥有keys、values和entries等遍历的方式来返回属性数组、属性值数组以及[属性, 属性值]数组,但是Set并没有封装union(并集)、intersection(交集)、differenceSet(差集)和subset(子集)等方法,我们可以利用它现有的属性和方法来封装一下</p>
</blockquote>
<pre><code>//封装ES6 Set集合union并集方法
Set.prototype.union = function(set_ano) {
    let set_this = this,
        set_new = new Set(),
        set_union = [];
    for(let [key, value] of set_this.entries()) {
        set_new.add(key);
    }

    for(let [key, value] of set_ano.entries()) {
        set_new.add(key);
    }

    for(let [key, value] of set_new.entries()) {
        set_union = [...set_union, key];
    }

    return set_union;
};

//封装ES6 Set集合intersection交集方法
Set.prototype.intersection = function(set_ano) {
    let set_this = this,
        set_new = new Set(),
        set_intersection = [];
    for(let [key, value] of set_this.entries()) {
        if(set_ano.has(key)) {
            set_new.add(key);
        }
    }

    for(let [key, value] of set_new.entries()) {
        set_intersection = [...set_intersection, key];
    }

    return set_intersection;
};

//封装ES6 Set集合differenceSet差集方法
Set.prototype.differenceSet = function(set_ano) {
    let set_this = this,
        set_new = new Set(),
        set_differenceSet = [];
    for(let [key, value] of set_this.entries()) {
        if(!set_ano.has(key)) {
            set_new.add(key);
        }
    }

    for(let [key, value] of set_new.entries()) {
        set_differenceSet = [...set_differenceSet, key];
    }

    return set_differenceSet;
};

//封装ES6 Set集合subset子集方法
Set.prototype.subset = function(set_ano) {
    let set_this = this;
    for(let [key, value] of set_this.entries()) {
        if(!set_ano.has(key)) {
            return false;
        }
    }
    return true;
};

let set = new Set(),
    set_ano = new Set();
set.add(45);
set.add(66);
set.add(100);
set.add(52);
set.add(28);
set.add(89);
set_ano.add(28);
set_ano.add(52);
set_ano.add(111);
set_ano.add(120);
set_ano.add(18);
//这里查询属于set集合或者属于set_ano集合的并集
//在这里打印:
//[45, 66, 100, 52, 28, 89, 111, 120, 18]
console.log(set.union(set_ano));
//这里查询既属于set集合又属于set_ano集合的交集
//在这里打印:
//[52, 28]
console.log(set.intersection(set_ano));
//这里查询属于set集合但不属于set_ano集合的差集
//在这里打印:
//[45, 66, 100, 89]
console.log(set.differenceSet(set_ano));
//这里查询set集合是否是set_ano集合的子集
//在这里打印:
//false
console.log(set.subset(set_ano));
</code></pre><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><blockquote>
<p>除了集合这种线性的非顺序结构以外,还有两种线性的非顺序结构: 字典和散列表,如果说集合是具有某种特征性质事物的总量的话,那字典就是具有某种特征性质事物的分集(分类集合),ES6中用Map来表现字典,下面我们就来介绍一下字典</p>
</blockquote>
<pre><code>let Map = (function () {
    //设置字典的容器,并在初始化时设置为空对象{}
    let map = new WeakMap();

    //定义Map字典类
    class Map {
        constructor() {
            map.set(this, {});
        }

        //在字典中添加字典项
        set(key, value) {
            let map_set = map.get(this);
            map_set[key] = value;
            map.set(this, map_set);
            return true;
        }

        //获取字典指定的字典项
        get(key) {
            let map_get = map.get(this);
            if(map_get.hasOwnProperty(key)) {
                return map_get[key];
            }
            return false;
        }

        //判断字典是否存在指定的字典项
        has(key) {
            let map_has = map.get(this);
            return map_has.hasOwnProperty(key);
        }

        //删除字典指定的字典项
        delete(key) {
            let map_delete = map.get(this);
            if(map_delete.hasOwnProperty(key)){
                delete map_delete[key];
                map.set(this, map_delete);
                return true;
            }
            return false;
        }

        //清空字典
        clear() {
            map.set(this, {});
            return true;
        }

        //获取字典的属性数组
        keys() {
            let map_keys = map.get(this);
            return Object.keys(map_keys);
        }

        //获取字典的属性值数组
        values() {
            let map_values = map.get(this);
            return Object.values(map_values);
        }

        //获取字典的长度
        size() {
            let map_size = map.get(this);
            return Object.keys(map_size).length;
        }

        //判断字典是否为空
        isEmpty() {
            let map_isEmpty = map.get(this);
            return Object.keys(map_isEmpty).length === 0;
        }
    }

    //返回Map字典类
    return Map;
})();

let map = new Map();
//这里判断字典是否为空
//在这里打印:
//true
console.log(map.isEmpty());
//这里获取字典的长度
//在这里打印:
//0
console.log(map.size());
//这里在字典中添加制定的字典项
//在这里打印:
//true
console.log(map.set(&quot;Gary&quot;, &quot;gary@gmail.com&quot;));
map.set(&quot;Simon&quot;, &quot;simon@gmail.com&quot;);
map.set(&quot;Lily&quot;, &quot;lily@gmail.com&quot;);
map.set(&quot;Alice&quot;, &quot;alice@gmail.com&quot;);
map.set(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;);
//这里判断字典是否为空
//在这里打印:
//false
console.log(map.isEmpty());
//这里获取字典的长度
//在这里打印:
//5
console.log(map.size());
//这里获取字典指定的字典项
//在这里打印:
//gary@gmail.com
console.log(map.get(&quot;Gary&quot;));
//这里获取字典指定的字典项
//在这里打印:
//lily@gmail.com
console.log(map.get(&quot;Alice&quot;));
//这里判断是否存在指定的字典项
//在这里打印:
//true
console.log(map.has(&quot;Lily&quot;));
//这里获取字典的属性数组
//在这里打印:
//[&quot;Gary&quot;, &quot;Simon&quot;, &quot;Lily&quot;, &quot;Alice&quot;, &quot;Aaron&quot;]
console.log(map.keys());
//这里获取字典的属性值数组
//在这里打印:
//[&quot;gary@gmail.com&quot;, &quot;simon@gmail.com&quot;, &quot;lily@gmail.com&quot;, &quot;alice@gmail.com&quot;, &quot;aaron@gmail.com&quot;]
console.log(map.values());
//这里删除字典的执行字典项
//在这里打印:
//true
console.log(map.delete(&quot;Alice&quot;));
//这里判断是否存在指定的字典项
//在这里打印:
//false
console.log(map.has(&quot;Alice&quot;));
//这里清空字典
//在这里打印:
//true
console.log(map.clear());
//这里获取字典指定的字典项
//在这里打印:
//false
console.log(map.get(&quot;Gary&quot;));
//这里判断字典是否为空
//在这里打印:
//true
console.log(map.isEmpty());
//这里获取字典的长度
//在这里打印:
//0
console.log(map.size());
</code></pre><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><blockquote>
<p>另外一种线性非顺序数据结构就是散列表了,也就是我们在Java中常用的HashTable,当然单纯的用HashTable会出现很多问题,最显著的一点就是容易一个值被另外一个值所覆盖,下面我们来介绍一下HashTable散列表</p>
</blockquote>
<pre><code>let HashTable = (function () {
    //设置散列表的容器,并初始化为空数组[]
    let hash_table = new WeakMap();

    //定义散列表类
    class HashTable {
        constructor() {
            hash_table.set(this, []);
        }

        //定义设计散列表的算法为loseLose算法
        //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数
        //然后对任何一个质数取余
        //最后进行返回
        loseLoseHashTable(key) {
            let hash_key = 13,
                result_index = 0;
            for(let i = 0; i &lt; key.length; i++) {
                result_index += i * hash_key + key.charCodeAt(i);
            }
            return result_index % 37;
        }

        //在散列表中添加散列表项
        put(key, value) {
            let hashTable = hash_table.get(this);
            const {loseLoseHashTable} = this;
            let index = loseLoseHashTable.bind(this)(key);
            hashTable[index] = value;
            hash_table.set(this, hashTable);
            return true;
        }

        //获取散列表指定的散列表项
        get(key) {
            let hashTable = hash_table.get(this);
            const {loseLoseHashTable} = this;
            let index = loseLoseHashTable.bind(this)(key);
            if(hashTable[index] !== undefined) {
                return hashTable[index];
            }
            return false;
        }

        //删除散列表中指定的散列表项
        remove(key) {
            let hashTable = hash_table.get(this);
            const {loseLoseHashTable} = this;
            let index = loseLoseHashTable.bind(this)(key);
            if(hashTable[index] !== undefined) {
                hashTable[index] = undefined;
                hash_table.set(this, hashTable);
                return true;
            }
            return false;
        }

        //获取散列表拥有值的字符串项
        toString() {
            let hashTable = hash_table.get(this),
                result_str = ``;
            for(let [key, value] of hashTable.entries()) {
                if(value !== undefined) {
                    result_str = `${result_str}${value} -&gt; `;
                }
            }
            return result_str;
        }

        //获取散列表的具体结构
        valueOf() {
            let hashTable = hash_table.get(this);
            return hashTable;
        }
    }

    //返回散列表类
    return HashTable;
})();

let hash_table = new HashTable();
//这里在散列表中添加散列表项
//在这里打印:
//true
console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;));
hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;);
hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;);
hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;);
hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;);
hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;);
hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;);
hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;);
hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;);
hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;);
hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;);
//这里获取散列表指定的散列表项
//在这里打印:
//tommy@gmail.com
console.log(hash_table.get(&quot;Aaron&quot;));
//这里获取散列表指定的散列表项
//在这里打印:
//tom@gmail.com
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表拥有值的字符串项
//在这里打印:
//martin@gmail.com -&gt; lily@gmail.com -&gt; tom@gmail.com -&gt; alice@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; helen@gmail.com -&gt; tommy@gmail.com -&gt; frank@gmail.com -&gt; 
console.log(hash_table.toString());
//这里获取散列表的具体结构
//在这里打印:
//[&quot;martin@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 2, &quot;tom@gmail.com&quot;, empty × 5, &quot;alice@gmail.com&quot;, empty × 2, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 8, &quot;helen@gmail.com&quot;, empty × 4, &quot;tommy@gmail.com&quot;, &quot;frank@gmail.com&quot;]
console.log(hash_table.valueOf());
//这里删除散列表中指定的散列表项
//在这里打印:
//true
console.log(hash_table.remove(&quot;Aaron&quot;));
hash_table.remove(&quot;Tom&quot;);
//这里获取散列表中指定的散列表项
//在这里打印:
//false
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表拥有值的字符串项
//在这里打印:
//martin@gmail.com -&gt; lily@gmail.com -&gt; alice@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; helen@gmail.com -&gt; frank@gmail.com -&gt; 
console.log(hash_table.toString());
//这里获取散列表的具体结构
//在这里打印:
//[&quot;martin@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 2, undefined, empty × 5, &quot;alice@gmail.com&quot;, empty × 2, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 8, &quot;helen@gmail.com&quot;, empty × 4, undefined, &quot;frank@gmail.com&quot;]
console.log(hash_table.valueOf());
</code></pre><blockquote>
<p>不知道你们注意到了没,有一些散列表项被覆盖了,比如说key属性为Aaron的散列表项的value属性值竟然是<a href="mailto:tommy@gmail.com" target="_blank" rel="noopener">tommy@gmail.com</a>,再比如说我将key属性为Aaron的散列表项删除掉,key属性为Tommy的散列表项也消失了,变为了undefined,说明key属性为Tommy和key属性为Aaron的散列表项经过loseLose算法解析散列表项后是同一个散列表项,所以散列表项被覆盖了,所以用单纯的用HashTable是不适当的,要解决这个比较显著的问题,有两种解决方式:链表查询以及散列表巡航迭代</p>
</blockquote>
<h2 id="链表查询"><a href="#链表查询" class="headerlink" title="链表查询"></a>链表查询</h2><blockquote>
<p>链表查询就是用链表来作为散列表项,假如已经存在loseLose算法解析散列表项后的散列表项,就添加到此位置链表的最后,这样的话就不会发生覆盖的事情了,下面我们就用链表查询来解决散列表项覆盖的问题吧</p>
</blockquote>
<pre><code>let LinkList = (function () {
    //定义链表头部的链表元素,并在初始化时设置为null
    //定义链表的长度,并在初始化时设置为0
    let head = new WeakMap(),
        length = new WeakMap();

    //声明链表元素Node对象的类函数
    //初始化有两个参数
    //@param node 现链表元素的值
    //@param next 用来链接下一个链表元素
    class Node {
        constructor(node) {
            this.node = node;
            this.next = null;
        }
    }

    //定义链表类
    class LinkList {
        constructor() {
            head.set(this, null);
            length.set(this, 0);
        }

        //向链表中添加链表元素
        insert(element) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                node = new Node(element);
            if(!headElement) {
                headElement = node;
            } else {
                while(current.next) {
                    current = current.next;
                }
                current.next = node;
            }
            lengths++;
            head.set(this, headElement);
            length.set(this, lengths);
            return lengths;
        }

        //向链表的指定位置添加链表元素
        insertAt(element, position) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                previous,
                node = new Node(element);
            if(position &gt;= 0 &amp;&amp; position &lt; lengths) {
                if(!headElement) {
                    headElement = node;
                } else {
                    if(position === 0) {
                        node.next = current;
                        headElement = node;
                    } else {
                        while(index++ &lt; position) {
                            previous = current;
                            current = current.next;
                        }
                        previous.next = node;
                        node.next = current;
                    }
                }
                lengths++;
                head.set(this, headElement);
                length.set(this, lengths);
                return position;   
            }
            return false; 
        }

        //删除链表中指定位置的链表元素
        removeAt(position) {
            let headElement = head.get(this),
                lengths = length.get(this),
                index = 0,
                current = headElement,
                previous;
            if(position &gt;= 0 &amp;&amp; position &lt; lengths) {
                if(!headElement) {
                    return false;
                } else {
                    if(lengths === 1) {
                        headElement = null;
                    } else {
                        if(position === 0) {
                            headElement = current.next;
                        } else {
                            while(index++ &lt; position) {
                                previous = current;
                                current = current.next;
                            }
                            previous.next = current.next;
                        }
                    }
                    lengths--;
                    head.set(this, headElement);
                    length.set(this, lengths);
                    return position;
                }
            }
            return false;
        }

        //删除链表中的指定链表元素
        remove(element) {
            const {indexOf, removeAt} = this;
            let index = indexOf.bind(this)(element);
            return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : false;
        }

        //删除链表中散列表链表查询中的链表项
        removeKey(key) {
            const {indexOfKeyPosition, removeAt} = this;
            let index = indexOfKeyPosition.bind(this)(key);
            return typeof index === &quot;number&quot; ? removeAt.bind(this)(index) : index;
        }

        //获取链表指定的元素位置
        indexOf(element) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0;
            while(index++ &lt; lengths) {
                if(current.node === element) {
                    return index - 1;
                }
                current = current.next;
            }
            return false;
        }

        //判断链表中是否存在散列表链表查询中的key
        indexOfKey(key) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0;
            while(index++ &lt; lengths) {
                if(key === current.node.key) {
                    return true;
                }
                current = current.next;
            }
            return false;   
        }

        //获取链表指定的散列表链表查询中的链表项位置
        indexOfKeyPosition(key) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0;
            while(index++ &lt; lengths) {
                if(key === current.node.key) {
                    return index - 1;
                }
                current = current.next;
            }
            return false;
        }

        //获取链表中散列表链表查询中的链表项
        indexOfNode(key) {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0;
            while(index++ &lt; lengths) {
                if(key === current.node.key) {
                    return current.node;
                }
                current = current.next;
            }
            return false; 
        }

        //获取链表的长度
        size() {
            return length.get(this);
        }

        //判断链表是否为空
        isEmpty() {
            return length.get(this) === 0;
        }

        //获取链表的头部链表元素
        headElement() {
            return head.get(this).node;
        }

        //获取链表中所有的链表结构
        toString() {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                result_str = ``;
            while(index++ &lt; lengths) {
                result_str = `${result_str}${current.node} =&gt; `;
                current = current.next;
            }
            return result_str;   
        }

        //获取链表中所有散列表查询的链表结构
        toStringKey() {
            let headElement = head.get(this),
                lengths = length.get(this),
                current = headElement,
                index = 0,
                result_str = ``;
            while(index++ &lt; lengths) {
                result_str = `${result_str}{key: ${current.node.key}, value: ${current.node.value}} =&gt; `;
                current = current.next;
            }
            return result_str;
        }

        //获取链表的真实结构
        valueOf() {
            return head.get(this);
        }

        //将链表清空
        clear() {
            head.set(this, null);
            length.set(this, 0);
        }
    }

    //返回链表类
    return LinkList;
})();

let HashTable = (function (){
    //设置散列表的容器,并初始化为空数组[]
    let hash_table = new WeakMap();

    //设置散列表中的链表类
    //@params key
    //@params value
    class Node {
        constructor(key, value) {
            this.key = key;
            this.value = value;
        }
    }

    //设置散列表类
    class HashTable {
        constructor() {
            hash_table.set(this, []);
        }

        //定义设计散列表的算法为loseLose算法
        //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数
        //然后对任何一个质数取余
        //最后进行返回
        loseLoseHashTable(key) {
            let hash_key = 13,
                index = 0;
            for(let i = 0; i &lt; key.length; i++) {
                index += i * hash_key + key.charCodeAt(i);
            }
            return index % 37;
        }

        //在散列表中添加散列表链表查询项
        put(key, value) {
            const {loseLoseHashTable} = this;
            let hashTable = hash_table.get(this),
                index = loseLoseHashTable.bind(this)(key),
                node = new Node(key, value),
                linkList;
            if(hashTable[index] === undefined) {
                linkList = new LinkList();
                linkList.insert(node);
                hashTable[index] = linkList;
            } else {
                linkList = hashTable[index];
                if(linkList.indexOfKey(key)) {
                    return false;
                } else {
                    linkList = hashTable[index];
                    linkList.insert(node);
                    hashTable[index] = linkList;
                }
            }
            hash_table.set(this, hashTable);
            return true;
        }

        //获取散列表指定的散列表链表查询项
        get(key) {
            const {loseLoseHashTable} = this;
            let hashTable = hash_table.get(this),
                index = loseLoseHashTable.bind(this)(key),
                linkList,
                node;
            if(hashTable[index] !== undefined) {
                linkList = hashTable[index];
                if(linkList.indexOfKey(key)) {
                    node = linkList.indexOfNode(key);
                    return node.value;
                } else {
                    return false;
                }
            }
            return false;
        }

        //删除散列表中指定的散列表链表查询项
        remove(key) {
            const {loseLoseHashTable} = this;
            let hashTable = hash_table.get(this),
                index = loseLoseHashTable.bind(this)(key),
                linkList;
            if(hashTable[index] !== undefined) {
                linkList = hashTable[index];
                if(linkList.indexOfKey(key)) {
                    linkList.removeKey(key);
                    if(linkList.isEmpty()){
                        hashTable[index] = undefined;
                    } else {
                        hashTable[index] = linkList;
                    }
                    return true;
                } else {
                    return false;
                }
            }
            return false;
        }

        //获取散列表链表查询拥有值的字符串项
        toString() {
            let hashTable = hash_table.get(this),
                result_str = ``;
            for(let [key, value] of hashTable.entries()) {
                if(value !== undefined) {
                    result_str = `${result_str}${value.toStringKey()} -&gt; `;
                }
            }
            return result_str;
        }

        //获取散列表链表查询的具体结构
        valueOf() {
            return hash_table.get(this);
        }
    }

    //返回散列表类
    return HashTable;
})();

let hash_table = new HashTable();
//这里在散列表中添加散列表链表查询项
//在这里打印:
//true
console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;));
hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;);
hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;);
hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;);
hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;);
hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;);
hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;);
hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;);
hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;);
hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;);
hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;);
//这里在散列表中获取散列表链表查询项
//在这里打印:
//aaron@gmail.com
console.log(hash_table.get(&quot;Aaron&quot;));
//这里在散列表中获取散列表链表查询项
//在这里打印:
//tom@gmail.com
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表链表查询拥有值的字符串项
//在这里打印:
//{key: Gary, value: gary@gmail.com} =&gt; {key: Martin, value: martin@gmail.com} =&gt;  -&gt; {key: Lily, value: lily@gmail.com} =&gt;  -&gt; {key: Tom, value: tom@gmail.com} =&gt;  -&gt; {key: Alice, value: alice@gmail.com} =&gt;  -&gt; {key: Simon, value: simon@gmail.com} =&gt;  -&gt; {key: Betty, value: betty@gmail.com} =&gt;  -&gt; {key: Helen, value: helen@gmail.com} =&gt;  -&gt; {key: Aaron, value: aaron@gmail.com} =&gt; {key: Tommy, value: tommy@gmail.com} =&gt;  -&gt; {key: Frank, value: frank@gmail.com} =&gt;  -&gt; 
console.log(hash_table.toString());
//这里获取散列表链表查询的具体结构
//在这里打印:
//[LinkList, empty × 6, LinkList, empty × 2, LinkList, empty × 5, LinkList, empty × 2, LinkList, empty, LinkList, empty × 8, LinkList, empty × 4, LinkList, LinkList]
console.log(hash_table.valueOf());
//这里删除散列表中指定的散列表链表查询项
//在这里打印:
//true
console.log(hash_table.remove(&quot;Aaron&quot;));
hash_table.remove(&quot;Tom&quot;);
hash_table.remove(&quot;Tommy&quot;);
//这里在散列表中获取散列表链表查询项
//在这里打印:
//false
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表链表查询拥有值的字符串项
//在这里打印:
//{key: Gary, value: gary@gmail.com} =&gt; {key: Martin, value: martin@gmail.com} =&gt;  -&gt; {key: Lily, value: lily@gmail.com} =&gt;  -&gt; {key: Alice, value: alice@gmail.com} =&gt;  -&gt; {key: Simon, value: simon@gmail.com} =&gt;  -&gt; {key: Betty, value: betty@gmail.com} =&gt;  -&gt; {key: Helen, value: helen@gmail.com} =&gt;  -&gt; {key: Frank, value: frank@gmail.com} =&gt;  -&gt;
console.log(hash_table.toString());
//这里获取散列表链表查询的具体结构
//在这里打印:
//[LinkList, empty × 6, LinkList, empty × 2, undefined, empty × 5, LinkList, empty × 2, LinkList, empty, LinkList, empty × 8, LinkList, empty × 4, undefined, LinkList]
console.log(hash_table.valueOf());
</code></pre><h2 id="散列表巡航迭代"><a href="#散列表巡航迭代" class="headerlink" title="散列表巡航迭代"></a>散列表巡航迭代</h2><blockquote>
<p>散列表巡航迭代其实就是利用位置迭代解决问题,假如根据loseLose算法解析散列表项后的散列表项,所在位置已经存在散列表项,就去查询所在位置的下一个位置,依次迭代下去,直到查询到位置的散列表项为没有定义的值为止,下面我们就用散列表巡航迭代来解决散列表项覆盖的问题吧</p>
</blockquote>
<pre><code>let HashTable = (function () {
    //设置散列表的容器,并初始化为空数组[]
    let hash_table = new WeakMap();

    //设置散列表中的对象类
    //@params key
    //@params value
    class Node {
        constructor(key, value) {
            this.key = key;
            this.value = value;
        }
    }

    //设置散列表类
    class HashTable {
        constructor() {
            hash_table.set(this, []);
        }

        //定义设计散列表的算法为loseLose算法
        //loseLose算法就是将HashTable中的key的每一个字符所对应的ASCII码值加上所处位置乘以任何一个质数
        //然后对任何一个质数取余
        //最后进行返回
        loseLoseHashTable(key) {
            let hash_key = 13,
                index = 0;
            for(let i = 0; i &lt; key.length; i++) {
                index += i * hash_key + key.charCodeAt(i);
            }
            return index % 37;
        }

        //在散列表中添加散列表巡航迭代项
        put(key, value) {
            const {loseLoseHashTable} = this;
            let hash_key = loseLoseHashTable.bind(this)(key),
                hashTable = hash_table.get(this),
                node = new Node(key, value);
            if(hashTable[hash_key] === undefined) {
                hashTable[hash_key] = node;
            } else {
                while(hashTable[hash_key] !== undefined) {
                    if(hashTable[hash_key].key === key) {
                        return false;
                    }
                    hash_key++;
                }
                if(hashTable[hash_key] === undefined) {
                    hashTable[hash_key] = node;
                }
            }
            hash_table.set(this, hashTable);
            return true;
        }

        //获取散列表指定的散列表巡航迭代项
        get(key) {
            const {loseLoseHashTable} = this;
            let hash_key = loseLoseHashTable.bind(this)(key),
                hashTable = hash_table.get(this);
            if(hashTable[hash_key] === undefined) {
                return false;
            } else {
                while(hashTable[hash_key] !== undefined) {
                    if(hashTable[hash_key].key === key) {
                        return hashTable[hash_key].value;
                    }
                    hash_key++;
                }
            }
            return false;
        }

        //删除散列表中指定的散列表巡航迭代项
        remove(key) {
            const {loseLoseHashTable} = this;
            let hash_key = loseLoseHashTable.bind(this)(key),
                hashTable = hash_table.get(this);
            if(hashTable[hash_key] === undefined) {
                return false;
            } else {
                while(hashTable[hash_key] !== undefined) {
                    if(hashTable[hash_key].key === key) {
                        hashTable[hash_key] = undefined;
                        hash_table.set(this, hashTable);
                        return true;
                    }
                    hash_key++;
                }
            }
            return false;
        }

        //获取散列表巡航迭代拥有值的字符串项
        toString() {
            let hashTable = hash_table.get(this),
                result_str = ``;
            for(let [key, value] of hashTable.entries()) {
                if(value !== undefined) {
                    result_str = `${result_str}{key: ${value[&quot;key&quot;]}, value: ${value[&quot;value&quot;]}} -&gt; `;
                }
            }
            return result_str;
        }

        //获取散列表巡航迭代的具体结构
        valueOf() {
            return hash_table.get(this);
        }
    }

    //返回散列表类
    return HashTable;
})();

let hash_table = new HashTable();
//这里在散列表中添加散列表巡航迭代项
//在这里打印:
//true
console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;));
hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;);
hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;);
hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;);
hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;);
hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;);
hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;);
hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;);
hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;);
hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;);
hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;);
//这里在散列表中获取散列表巡航迭代项
//在这里打印:
//aaron@gmail.com
console.log(hash_table.get(&quot;Aaron&quot;));
//这里在散列表中获取散列表巡航迭代项
//在这里打印:
//tom@gmail.com
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表巡航迭代拥有值的字符串项
//在这里打印:
//{key: Gary, value: gary@gmail.com} -&gt; {key: Martin, value: martin@gmail.com} -&gt; {key: Lily, value: lily@gmail.com} -&gt; {key: Tom, value: tom@gmail.com} -&gt; {key: Alice, value: alice@gmail.com} -&gt; {key: Simon, value: simon@gmail.com} -&gt; {key: Betty, value: betty@gmail.com} -&gt; {key: Helen, value: helen@gmail.com} -&gt; {key: Aaron, value: aaron@gmail.com} -&gt; {key: Tommy, value: tommy@gmail.com} -&gt; {key: Frank, value: frank@gmail.com} -&gt; 
console.log(hash_table.toString());
//这里获取散列表巡航迭代的具体结构
//在这里打印:
//[Node, Node, empty × 5, Node, empty × 2, Node, empty × 5, Node, empty × 2, Node, empty, Node, empty × 8, Node, empty × 4, Node, Node, Node]
console.log(hash_table.valueOf());
//这里删除散列表中指定的散列表巡航迭代项
//在这里打印:
//true
console.log(hash_table.remove(&quot;Aaron&quot;));
hash_table.remove(&quot;Tom&quot;);
//这里在散列表中获取散列表巡航迭代项
//在这里打印:
//false
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表巡航迭代拥有值的字符串项
//在这里打印:
//{key: Gary, value: gary@gmail.com} -&gt; {key: Martin, value: martin@gmail.com} -&gt; {key: Lily, value: lily@gmail.com} -&gt; {key: Alice, value: alice@gmail.com} -&gt; {key: Simon, value: simon@gmail.com} -&gt; {key: Betty, value: betty@gmail.com} -&gt; {key: Helen, value: helen@gmail.com} -&gt; {key: Tommy, value: tommy@gmail.com} -&gt; {key: Frank, value: frank@gmail.com} -&gt; 
console.log(hash_table.toString());
//这里获取散列表巡航迭代的具体结构
//在这里打印:
//[Node, Node, empty × 5, Node, empty × 2, undefined, empty × 5, Node, empty × 2, Node, empty, Node, empty × 8, Node, empty × 4, undefined, Node, Node]
console.log(hash_table.valueOf());
</code></pre><h2 id="djb2算法解决一切问题"><a href="#djb2算法解决一切问题" class="headerlink" title="djb2算法解决一切问题"></a>djb2算法解决一切问题</h2><blockquote>
<p>还有一种既不使用链表查询,也不使用巡航迭代的方法,那就是展示散列表更广的djb2算法,使用djb2算法就可以直接解决loseLose算法解析后散列表项覆盖的问题,下面我们就用djb2算法来解决散列表项覆盖的问题吧</p>
</blockquote>
<pre><code>let HashTable = (function() {
    //设置散列表的容器,并初始化为空数组[]
    let hash_table = new WeakMap();

    //设置散列表类
    class HashTable {
        constructor() {
            hash_table.set(this, []);
        }

        //定义设计散列表的算法为djb2算法
        //djb2算法和loseLose算法相近,都是定义一个质数(数值比较大的质数)乘以属性的每一个字符所在的位置,再加上属性每一个字符所对应的ASCII码值
        //然后对任何一个质数(数值比较大的质数)取余
        //最后再返回
        djb2HashTable(key) {
            let hash_key = 5381,
                index = 0;
            for(let i = 0; i &lt; key.length; i++) {
                index += i * hash_key + key.charCodeAt(i);
            }
            return index % 1013;    
        }

        //在散列表中添加散列表项
        put(key, value) {
            const {djb2HashTable} = this;
            let hashTable = hash_table.get(this),
                hash_key = djb2HashTable.bind(this)(key);
            if(hashTable[hash_key] !== undefined) {
                return false;
            }
            hashTable[hash_key] = value;
            return true;
        }

        //获取散列表指定的散列表项
        get(key) {
            const {djb2HashTable} = this;
            let hashTable = hash_table.get(this),
                hash_key = djb2HashTable.bind(this)(key);
            if(hashTable[hash_key] === undefined) {
                return false;
            }    
            return hashTable[hash_key];
        }

        //删除散列表中指定的散列表项
        remove(key) {
            const {djb2HashTable} = this;
            let hashTable = hash_table.get(this),
                hash_key = djb2HashTable.bind(this)(key);
            if(hashTable[hash_key] === undefined) {
                return false;
            }
            hashTable[hash_key] = undefined;
            return true;
        }

        //获取散列表拥有值的字符串项
        toString() {
            let hashTable = hash_table.get(this),
                result_str = ``;
            for(let [key, value] of hashTable.entries()) {
                if(value !== undefined) {
                    result_str = `${result_str}${value} -&gt; `;
                }
            }
            return result_str;
        }

        //获取散列表的具体结构
        valueOf() {
            return hash_table.get(this);
        }
    }

    //返回散列表类
    return HashTable;
})();

let hash_table = new HashTable();
//这里在散列表中添加散列表项
//在这里打印:
//true
console.log(hash_table.put(&quot;Gary&quot;, &quot;gary@gmail.com&quot;));
hash_table.put(&quot;Helen&quot;, &quot;helen@gmail.com&quot;);
hash_table.put(&quot;Lily&quot;, &quot;lily@gmail.com&quot;);
hash_table.put(&quot;Alice&quot;, &quot;alice@gmail.com&quot;);
hash_table.put(&quot;Simon&quot;, &quot;simon@gmail.com&quot;);
hash_table.put(&quot;Aaron&quot;, &quot;aaron@gmail.com&quot;);
hash_table.put(&quot;Tom&quot;, &quot;tom@gmail.com&quot;);
hash_table.put(&quot;Tommy&quot;, &quot;tommy@gmail.com&quot;);
hash_table.put(&quot;Betty&quot;, &quot;betty@gmail.com&quot;);
hash_table.put(&quot;Frank&quot;, &quot;frank@gmail.com&quot;);
hash_table.put(&quot;Martin&quot;, &quot;martin@gmail.com&quot;);
//这里获取散列表中指定的散列表项
//在这里打印:
//aaron@gmail.com
console.log(hash_table.get(&quot;Aaron&quot;));
//这里获取散列表中指定的散列表项
//在这里打印:
//tom@gmail.com
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表拥有值的字符串项
//在这里打印:
//tom@gmail.com -&gt; gary@gmail.com -&gt; lily@gmail.com -&gt; martin@gmail.com -&gt; alice@gmail.com -&gt; helen@gmail.com -&gt; aaron@gmail.com -&gt; frank@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; tommy@gmail.com -&gt; 
console.log(hash_table.toString());
//这里获取散列表的具体结构
//在这里打印:
//[empty × 239, &quot;tom@gmail.com&quot;, empty × 33, &quot;gary@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 13, &quot;martin@gmail.com&quot;, empty × 304, &quot;alice@gmail.com&quot;, empty × 13, &quot;helen@gmail.com&quot;, empty × 4, &quot;aaron@gmail.com&quot;, &quot;frank@gmail.com&quot;, empty × 19, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 13, &quot;tommy@gmail.com&quot;]
console.log(hash_table.valueOf());
//这里删除散列表中指定的散列表项
//在这里打印:
//true
console.log(hash_table.remove(&quot;Aaron&quot;));
hash_table.remove(&quot;Tom&quot;);
//这里获取散列表中指定的散列表项
//在这里打印:
//false
console.log(hash_table.get(&quot;Tom&quot;));
//这里获取散列表拥有值的字符串项
//在这里打印:
//gary@gmail.com -&gt; lily@gmail.com -&gt; martin@gmail.com -&gt; alice@gmail.com -&gt; helen@gmail.com -&gt; frank@gmail.com -&gt; simon@gmail.com -&gt; betty@gmail.com -&gt; tommy@gmail.com -&gt; 
console.log(hash_table.toString());
//这里获取散列表的具体结构
//在这里打印:
//[empty × 239, undefined, empty × 33, &quot;gary@gmail.com&quot;, empty × 6, &quot;lily@gmail.com&quot;, empty × 13, &quot;martin@gmail.com&quot;, empty × 304, &quot;alice@gmail.com&quot;, empty × 13, &quot;helen@gmail.com&quot;, empty × 4, undefined, &quot;frank@gmail.com&quot;, empty × 19, &quot;simon@gmail.com&quot;, empty, &quot;betty@gmail.com&quot;, empty × 13, &quot;tommy@gmail.com&quot;]
console.log(hash_table.valueOf());
</code></pre><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><blockquote>
<p>这是我们学习的第一种非线性非顺序的数据结构 —— <b>树</b>,后面还会学到更多,比如说<b>图</b>。树只有一个根节点,每一个节点都可能有一个或者多个子节点 —— <b>子叶</b>,今天我们实现的二叉树,每个节点最多只能有两个子叶,left的子叶比其父节点数值小,right的子叶比其父节点数值大,下面我们来介绍一下二叉树</p>
</blockquote>
<pre><code>let Tree = (function () {
    //设置二叉树的容器,并初始化为null
    let head = new WeakMap();

    //定义二叉树子叶节点类
    //@params node
    //@params left
    //@params right
    class Node {
        constructor(node) {
            this.node = node;
            this.left = null;
            this.right = null;
        }
    }

    //定义二叉树类
    class Tree {
        constructor() {
            head.set(this, null);
        }

        //在二叉树中添加子叶节点
        insert(node) {
            const {insertNode} = this;
            let head_tree = head.get(this);
            head_tree = insertNode.bind(this)(head_tree, node);
            head.set(this, head_tree);
            return true;
        }

        //二叉树中添加子叶节点执行方法
        //利用当前的子叶节点和添加的子叶节点数值进行比较
        //假如小于添加的子叶节点数值,就查询当前子叶节点的右子叶节点
        //假如大于添加的子叶节点数值,就查询当前子叶节点的左子叶节点
        //直到查询到节点为null为止,然后添加新的子叶节点
        insertNode(node, node_key) {
            const {insertNode} = this;
            if(!node) {
                node = new Node(node_key);
            } else if(node.node &gt; node_key) {
                node.left = insertNode.bind(this)(node.left, node_key);
            } else {
                node.right = insertNode.bind(this)(node.right, node_key);
            }
            return node;
        }

        //在二叉树中删除指定的子叶节点
        remove(node) {
            const {removeNode} = this;
            let head_tree = head.get(this);
            if(!head_tree) {
                return false;
            }
            head_tree = removeNode.bind(this)(head_tree, node);
            head.set(this, head_tree);
            return true;
        }

        //二叉树中删除指定的子叶节点执行方法
        //利用当前的子叶节点和删除的子叶节点数值进行比较
        //假如小于删除的子叶节点,就查询当前子叶节点的右子叶节点
        //假如大于删除的子叶节点,就查询当前子叶节点的左子叶节点
        //直到等于删除的子叶节点数值,分为三种情况
        //第一种,删除的子叶节点底下没有其左右子叶节点,就直接将删除的子叶节点置为null
        //第二种,删除的子叶节点底下的左右子叶节点有一边为null,就直接将删除的子叶节点置为左右子叶节点不为null的一边
        //第三种,删除的子叶节点底下其左右子叶节点都不为null,就直接去查询删除的子叶节点其右子叶节点底下的最小的子叶节点,并将删除的子叶节点的数值置为这个最小的子叶节点的数值,再将删除的子叶节点其右子叶节点底下的最小的子叶节点删除
        removeNode(node, node_key) {
            const {removeNode, findTheLeftNode} = this;
            if(node.node &gt; node_key) {
                node.left = removeNode.bind(this)(node.left, node_key);
            } else if(node.node &lt; node_key){
                node.right = removeNode.bind(this)(node.right, node_key);
            } else {
                if(!node.left &amp;&amp; !node.right) {
                    node = null;
                } else if (!node.left) {
                    node = node.right;
                } else if (!node.right) {
                    node = node.left;
                } else {
                    let aux = findTheLeftNode.bind(this)(node.right);
                    node.node = aux.node;
                    node.right = removeNode.bind(this)(node.right, aux.node);
                }
            }
            return node;
        }

        //查询子叶节点底下的最小的(最左边的)子叶节点
        findTheLeftNode(node) {
            const {findTheLeftNode} = this;
            if(node.left) {
                return findTheLeftNode.bind(this)(node.left);
            }
            return node;
        }

        //在二叉树中获取最小的(最左边的)子叶节点数值
        min() {
            const {minNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;最小的子叶:&quot;);
            return minNode.bind(this)(head_tree).node;
        }

        //二叉树中获取最小的(最左边的)子叶节点执行方法
        minNode(node) {
            const {minNode} = this;
            if(node.left) {
                return minNode.bind(this)(node.left);
            }
            return node;
        }

        //在二叉树中获取最大的(最右边的)子叶节点数值
        max() {
            const {maxNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;最大的子叶:&quot;);
            return maxNode.bind(this)(head_tree).node;
        }

        //二叉树中获取最大的(最右边的)子叶节点执行方法
        maxNode(node) {
            const {maxNode} = this;
            if(node.right) {
                return maxNode.bind(this)(node.right);
            }
            return node;
        }

        //在二叉树获取先序遍历
        preorderTraversal(method) {
            const {preorderTraversalNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;先序遍历:&quot;);
            preorderTraversalNode.bind(this)(head_tree, method);
        }

        //二叉树先序遍历执行方法
        preorderTraversalNode(node, method) {
            const {preorderTraversalNode} = this;
            if(node) {
                method.bind(this)(node);
                preorderTraversalNode.bind(this)(node.left, method);
                preorderTraversalNode.bind(this)(node.right, method);
            }
        }

        //在二叉树中获取中序遍历
        inorderTraversal(method) {
            const {inorderTraversalNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;中序遍历:&quot;);
            inorderTraversalNode.bind(this)(head_tree, method);
        }

        //二叉树中序遍历执行方法
        inorderTraversalNode(node, method) {
            const {inorderTraversalNode} = this;
            if(node) {
                inorderTraversalNode.bind(this)(node.left, method);
                method.bind(this)(node);
                inorderTraversalNode.bind(this)(node.right, method);
            }
        }

        //在二叉树中获取后序遍历
        postorderTraversal(method) {
            const {postorderTraversalNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;后序遍历:&quot;);
            postorderTraversalNode.bind(this)(head_tree, method);
        }

        //二叉树后序遍历执行方法
        postorderTraversalNode(node, method) {
            const {postorderTraversalNode} = this;
            if(node) {
                postorderTraversalNode.bind(this)(node.left, method);
                postorderTraversalNode.bind(this)(node.right, method);
                method.bind(this)(node);
            }
        }

        //在二叉树中获取二叉树的具体结构
        valueOf() {
            let head_tree = head.get(this);
            return head_tree;
        }
    }

    //返回二叉树类
    return Tree;
})();

let tree = new Tree();
//这里在二叉树中添加子节点
//在这里打印:
//true
console.log(tree.insert(15));
tree.insert(10);
tree.insert(18);
tree.insert(20);
tree.insert(17);
tree.insert(16);
tree.insert(25);
tree.insert(5);
tree.insert(8);
tree.insert(55);
tree.insert(30);
tree.insert(35);
tree.insert(40);
tree.insert(45);
tree.insert(50);
//这里在二叉树中获取最小的(最左边的)子叶节点数值
//在这里打印:
//最小的子叶:
//5
console.log(tree.min());
//这里在二叉树中获取最大的(最右边的)子叶节点数值
//在这里打印:
//最大的子叶:
//55
console.log(tree.max());
//这里在二叉树中获取中序遍历
//在这里打印:
//中序遍历:
//5
//8
//10
//15
//16
//17
//18
//20
//25
//30
//35
//40
//45
//50
//55
tree.inorderTraversal((node)=&gt;{
    console.log(node.node);
});
//这里在二叉树中获取先序遍历
//在这里打印:
//先序遍历:
//15
//10
//5
//8
//18
//17
//16
//20
//25
//55
//30
//35
//40
//45
//50
tree.preorderTraversal((node)=&gt;{
    console.log(node.node);
});
//这里在二叉树中获取后序遍历
//在这里打印:
//后序遍历:
//8
//5
//10
//16
//17
//50
//45
//40
//35
//30
//55
//25
//20
//18
//15
tree.postorderTraversal((node)=&gt;{
    console.log(node.node);
});
//这里在二叉树中获取二叉树的具体结构
//在这里打印:
//Node {node: 15, left: Node, right: Node}
console.log(tree.valueOf());
//这里在二叉树中删除指定的子叶节点
//在这里打印:
//true
console.log(tree.remove(50));
tree.remove(40);
tree.remove(15);
//这里在二叉树中获取二叉树的具体结构
//在这里打印:
//Node {node: 16, left: Node, right: Node}
console.log(tree.valueOf());
</code></pre><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><blockquote>
<p>介绍并封装完了二叉树之后,我们来介绍一下平衡二叉树,其实平衡二叉树就是每一个二叉树上面的节点的平衡因子的绝对值不可以超过1,也就是说-1 &lt;= 平衡因子 &lt;= 1,所谓的平衡因子就是二叉树节点子树节点级数,-1 &lt;= 左子树级数 - 右子树级数 &lt;= 1,下面就让我们来介绍一下平衡二叉树吧</p>
</blockquote>
<pre><code>let AVLTree = (function () {
    //设置平衡二叉树的容器,并初始化为null
    let head = new WeakMap();

    //定义平衡二叉树子叶节点类
    //@params node
    //@params left
    //@params right
    class Node {
        constructor(node) {
            this.node = node;
            this.left = null;
            this.right = null;
        }
    }

    //定义平衡二叉树类
    class AVLTree {
        constructor() {
            head.set(this, null);
        }

        //在平衡二叉树中添加子叶节点
        insert(node) {
            const {insertNode} = this;
            let head_tree = head.get(this);
            head_tree = insertNode.bind(this)(head_tree, node);
            head.set(this, head_tree);
            return true;
        }

        //平衡二叉树中添加子叶节点执行方法
        //利用当前的子叶节点和添加的子叶节点数值进行比较
        //假如小于添加的子叶节点数值,就查询当前子叶节点的右子叶节点
        //假如大于添加的子叶节点数值,就查询当前子叶节点的左子叶节点
        //直到查询到节点为null为止,然后添加新的子叶节点
        insertNode(node, node_key) {
            const {insertNode, findBalanceFactor, LLBalanceNode, LRBalanceNode, RRBalanceNode, RLBalanceNode} = this;
            if(!node) {
                node = new Node(node_key);
            } else if(node.node &gt; node_key) {
                node.left = insertNode.bind(this)(node.left, node_key);
                if(findBalanceFactor.bind(this)(node.left) - findBalanceFactor.bind(this)(node.right) &gt; 1) {
                    if(node_key &lt; node.left.node) {
                        node = LLBalanceNode.bind(this)(node);
                    } else {
                        node = LRBalanceNode.bind(this)(node);
                    }
                }
            } else {
                node.right = insertNode.bind(this)(node.right, node_key);
                if(findBalanceFactor.bind(this)(node.right) - findBalanceFactor.bind(this)(node.left) &gt; 1) {
                    if(node_key &gt; node.right.node) {
                        node = RRBalanceNode.bind(this)(node);
                    } else {
                        node = RLBalanceNode.bind(this)(node);
                    }
                }
            }
            return node;
        }

        //平衡二叉树使用LL算法来解决添加的新的子叶节点数值小于其父子叶节点(左边父子叶节点)的数值的平衡问题
        LLBalanceNode(node) {
            let target = node.left;
            node.left = target.right;
            target.right = node;
            return target;
        }

        //平衡二叉树使用LL算法来解决添加的新的子叶节点数值大于其父子叶节点(左边父子叶节点)的数值的平衡问题
        LRBalanceNode(node) {
            const {RRBalanceNode, LLBalanceNode} = this;
            node.left = RRBalanceNode.bind(this)(node.left);
            return LLBalanceNode.bind(this)(node);
        }

        //平衡二叉树使用RR算法来解决添加的新的子叶节点数值大于其父子叶节点(右边父子叶节点)的数值的平衡问题
        RRBalanceNode(node) {
            let target = node.right;
            node.right = target.left;
            target.left = node;
            return target;
        }

        //平衡二叉树使用RR算法来解决添加的新的子叶节点数值小于其父子叶节点(右边父子叶节点)的数值的平衡问题
        RLBalanceNode(node) {
            const {RRBalanceNode, LLBalanceNode} = this;
            node.right = LLBalanceNode.bind(this)(node.right);
            return RRBalanceNode.bind(this)(node);
        }

        //获取每个平衡二叉树节点的平衡因子
        findBalanceFactor(node) {
            const {findBalanceFactor} = this;
            if(!node) {
                return -1;
            } else {
                return Math.max(findBalanceFactor.bind(this)(node.left), findBalanceFactor.bind(this)(node.right)) + 1;
            }
        }

        //在平衡二叉树中删除指定的子叶节点
        remove(node) {
            const {removeNode} = this;
            let head_tree = head.get(this);
            if(!head_tree) {
                return false;
            }
            head_tree = removeNode.bind(this)(head_tree, node);
            head.set(this, head_tree);
            return true;
        }

        //平衡二叉树中删除指定的子叶节点执行方法
        //利用当前的子叶节点和删除的子叶节点数值进行比较
        //假如小于删除的子叶节点,就查询当前子叶节点的右子叶节点
        //假如大于删除的子叶节点,就查询当前子叶节点的左子叶节点
        //直到等于删除的子叶节点数值,分为三种情况
        //第一种,删除的子叶节点底下没有其左右子叶节点,就直接将删除的子叶节点置为null
        //第二种,删除的子叶节点底下的左右子叶节点有一边为null,就直接将删除的子叶节点置为左右子叶节点不为null的一边
        //第三种,删除的子叶节点底下其左右子叶节点都不为null,就直接去查询删除的子叶节点其右子叶节点底下的最小的子叶节点,并将删除的子叶节点的数值置为这个最小的子叶节点的数值,再将删除的子叶节点其右子叶节点底下的最小的子叶节点删除
        removeNode(node, node_key) {
            const {removeNode, findTheLeftNode} = this;
            if(node.node &gt; node_key) {
                node.left = removeNode.bind(this)(node.left, node_key);
            } else if(node.node &lt; node_key){
                node.right = removeNode.bind(this)(node.right, node_key);
            } else {
                if(!node.left &amp;&amp; !node.right) {
                    node = null;
                } else if (!node.left) {
                    node = node.right;
                } else if (!node.right) {
                    node = node.left;
                } else {
                    let aux = findTheLeftNode.bind(this)(node.right);
                    node.node = aux.node;
                    node.right = removeNode.bind(this)(node.right, aux.node);
                }
            }
            return node;
        }

        //查询子叶节点底下的最小的(最左边的)子叶节点
        findTheLeftNode(node) {
            const {findTheLeftNode} = this;
            if(node.left) {
                return findTheLeftNode.bind(this)(node.left);
            }
            return node;
        }

        //在平衡二叉树中获取最小的(最左边的)子叶节点数值
        min() {
            const {minNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;最小的子叶:&quot;);
            return minNode.bind(this)(head_tree).node;
        }

        //平衡二叉树中获取最小的(最左边的)子叶节点执行方法
        minNode(node) {
            const {minNode} = this;
            if(node.left) {
                return minNode.bind(this)(node.left);
            }
            return node;
        }

        //在平衡二叉树中获取最大的(最右边的)子叶节点数值
        max() {
            const {maxNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;最大的子叶:&quot;);
            return maxNode.bind(this)(head_tree).node;
        }

        //平衡二叉树中获取最大的(最右边的)子叶节点执行方法
        maxNode(node) {
            const {maxNode} = this;
            if(node.right) {
                return maxNode.bind(this)(node.right);
            }
            return node;
        }

        //在平衡二叉树获取先序遍历
        preorderTraversal(method) {
            const {preorderTraversalNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;先序遍历:&quot;);
            preorderTraversalNode.bind(this)(head_tree, method);
        }

        //平衡二叉树先序遍历执行方法
        preorderTraversalNode(node, method) {
            const {preorderTraversalNode} = this;
            if(node) {
                method.bind(this)(node);
                preorderTraversalNode.bind(this)(node.left, method);
                preorderTraversalNode.bind(this)(node.right, method);
            }
        }

        //在平衡二叉树中获取中序遍历
        inorderTraversal(method) {
            const {inorderTraversalNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;中序遍历:&quot;);
            inorderTraversalNode.bind(this)(head_tree, method);
        }

        //平衡二叉树中序遍历执行方法
        inorderTraversalNode(node, method) {
            const {inorderTraversalNode} = this;
            if(node) {
                inorderTraversalNode.bind(this)(node.left, method);
                method.bind(this)(node);
                inorderTraversalNode.bind(this)(node.right, method);
            }
        }

        //在平衡二叉树中获取后序遍历
        postorderTraversal(method) {
            const {postorderTraversalNode} = this;
            let head_tree = head.get(this);
            console.log(&quot;后序遍历:&quot;);
            postorderTraversalNode.bind(this)(head_tree, method);
        }

        //平衡二叉树后序遍历执行方法
        postorderTraversalNode(node, method) {
            const {postorderTraversalNode} = this;
            if(node) {
                postorderTraversalNode.bind(this)(node.left, method);
                postorderTraversalNode.bind(this)(node.right, method);
                method.bind(this)(node);
            }
        }

        //在平衡二叉树中获取二叉树的具体结构
        valueOf() {
            let head_tree = head.get(this);
            return head_tree;
        }
    }

    //返回平衡二叉树类
    return AVLTree;
})();

let tree = new AVLTree();
//这里在平衡二叉树中添加子节点
//在这里打印:
//true
console.log(tree.insert(15));
tree.insert(10);
tree.insert(18);
tree.insert(20);
tree.insert(17);
tree.insert(16);
tree.insert(25);
tree.insert(5);
tree.insert(8);
tree.insert(55);
tree.insert(30);
tree.insert(35);
tree.insert(40);
tree.insert(45);
tree.insert(50);
//这里在平衡二叉树中获取最小的(最左边的)子叶节点数值
//在这里打印:
//最小的子叶:
//5
console.log(tree.min());
//这里在平衡二叉树中获取最大的(最右边的)子叶节点数值
//在这里打印:
//最大的子叶:
//55
console.log(tree.max());
//这里在平衡二叉树中获取中序遍历
//在这里打印:
//中序遍历:
//5
//8
//10
//15
//16
//17
//18
//20
//25
//30
//35
//40
//45
//50
//55
tree.inorderTraversal((node)=&gt;{
    console.log(node.node);
});
//这里在平衡二叉树中获取先序遍历
//在这里打印:
//先序遍历:
//17
//15
//8
//5
//10
//16
//30
//20
//18
//25
//40
//35
//50
//45
//55
tree.preorderTraversal((node)=&gt;{
    console.log(node.node);
});
//这里在平衡二叉树中获取后序遍历
//在这里打印:
//后序遍历:
//5
//10
//8
//16
//15
//18
//25
//20
//35
//45
//55
//50
//40
//30
//17
tree.postorderTraversal((node)=&gt;{
    console.log(node.node);
});
//这里在平衡二叉树中获取二叉树的具体结构
//在这里打印:
//Node {node: 17, left: Node, right: Node}
console.log(tree.valueOf());
//这里在平衡二叉树中删除指定的子叶节点
//在这里打印:
//true
console.log(tree.remove(50));
tree.remove(40);
tree.remove(15);
//这里在平衡二叉树中获取二叉树的具体结构
//在这里打印:
//Node {node: 17, left: Node, right: Node}
console.log(tree.valueOf());
</code></pre>]]></content>
      <categories>
        <category>Javascript数据结构和算法</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
